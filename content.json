{"meta":{"title":"猿七笔记","subtitle":null,"description":"fed","author":"猿七","url":"https://guanqi.xyz"},"pages":[{"title":"","date":"2019-01-19T09:43:18.395Z","updated":"2019-01-19T09:43:18.395Z","comments":true,"path":"README.html","permalink":"https://guanqi.xyz/README.html","excerpt":"","text":"blog"},{"title":"tags","date":"2019-01-16T01:31:24.000Z","updated":"2019-01-16T01:32:25.407Z","comments":false,"path":"tags/index.html","permalink":"https://guanqi.xyz/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-01-16T01:32:14.000Z","updated":"2019-01-16T01:32:29.712Z","comments":false,"path":"categories/index.html","permalink":"https://guanqi.xyz/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"使用node创建一个http服务","slug":"node-http","date":"2019-03-08T09:35:01.000Z","updated":"2019-03-08T09:57:07.327Z","comments":true,"path":"2019-03-08/node-http/","link":"","permalink":"https://guanqi.xyz/2019-03-08/node-http/","excerpt":"","text":"现在，我开始使用node的http模块创建一个简单http服务。 请确保你的计算机安装了node环境。 目录 引进http模块 创建服务请求和响应 监听端口 启动服务 引进http模块我在一个目录下面新建一个http.js的文件夹，然后引入http模块的代码。 const http = require(&#39;http&#39;) 温馨提示：这个require是CommonJS的一个引进模块的方法，node采用了CommonJS 模块的格式。 创建服务请求和响应下面开始创建一个服务请求和响应的代码。 12345const server = http.createServer((req,res) =&gt; &#123; if (req.url == '/favicon.ico') &#123; return false; &#125; if (req.url == '/') &#123; res.write('hello,world!') &#125; res.end();&#125;) createServer这个是一个创建服务的方法，里面接受一个回调函数，用来获取信息。 监听端口一个服务应该有一个对应的端口，才可以进行访问，客户端默认的端口是8080，也可以自定义端口。 1server.listen('3000',() =&gt; &#123; console.log('server is running on port 3000!'); &#125;) 启动服务打开你的命令行工具，我这使用的是cmd，你也可以使用git-bash或者power shell。 输入这行命令node http.js，然后在游览器中开一个空白标签页，输入http://localhost:3000 你会发现请求响应了，显示出一行文本 hello,world，说明启动成功。 写在最后这个小例子证明了node可以创建http服务来处理客户端的请求，并且返回响应的数据。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/tags/nodejs/"},{"name":"http","slug":"http","permalink":"https://guanqi.xyz/tags/http/"}]},{"title":"表单输入验证案例","slug":"front-form-eg","date":"2019-02-01T08:33:21.000Z","updated":"2019-03-08T03:47:00.365Z","comments":true,"path":"2019-02-01/front-form-eg/","link":"","permalink":"https://guanqi.xyz/2019-02-01/front-form-eg/","excerpt":"","text":"之前已经说过了事件的来龙去脉和属性以及方法，今天就说一下表单的案例。 案例步骤 1.建好表单结构和样式； 2.获取输入内容进行验证； 3.不正确进行文字提示； 4.输入成功后提交表单 代码展示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;form action=\"\" method=\"get\" name=\"myform\" id=\"myform\" onsubmit=\"return returnForm();\" onreset=\"return confirmForm();\"&gt; &lt;p&gt; &lt;label for=\"username\"&gt;昵称：&lt;/label&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" placeholder=\"请输入用户名称\"&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;密码：&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" placeholder=\"请输入用户密码\"&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;性别：&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"man\" value=\"man\"&gt;&lt;label for=\"man\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"woman\" value=\"woman\"&gt;&lt;label for=\"woman\"&gt;女&lt;/label&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"hobbies\"&gt;爱好：&lt;/label&gt; &lt;input type=\"checkbox\" name=\"hobbies\" id=\"song\" value=\"song\"&gt;&lt;label for=\"song\"&gt;唱歌&lt;/label&gt; &lt;input type=\"checkbox\" name=\"hobbies\" id=\"read\" value=\"read\"&gt;&lt;label for=\"read\"&gt;看书&lt;/label&gt; &lt;input type=\"checkbox\" name=\"hobbies\" id=\"sport\" value=\"sport\"&gt;&lt;label for=\"sport\"&gt;运动&lt;/label&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;城市：&lt;/label&gt; &lt;select name=\"city\" id=\"city\"&gt; &lt;option value=\"bj\" selected&gt;北京&lt;/option&gt; &lt;option value=\"tj\"&gt;天津&lt;/option&gt; &lt;option value=\"cq\"&gt;重庆&lt;/option&gt; &lt;option value=\"sh\"&gt;上海&lt;/option&gt; &lt;option value=\"hz\"&gt;杭州&lt;/option&gt; &lt;option value=\"nj\"&gt;南京&lt;/option&gt; &lt;option value=\"gz\"&gt;广州&lt;/option&gt; &lt;option value=\"sz\"&gt;深圳&lt;/option&gt; &lt;option value=\"xa\"&gt;西安&lt;/option&gt; &lt;/select&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"headimg\"&gt;头像：&lt;/label&gt; &lt;input type=\"file\" name=\"headimg\" id=\"headimg\"&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;input type=\"hidden\" name=\"token\" value=\"20190201\" id=\"token\"&gt; &lt;p&gt; &lt;label for=\"comment\"&gt;介绍：&lt;/label&gt;&lt;br&gt; &lt;textarea name=\"comment\" id=\"comment\" cols=\"30\" rows=\"10\" placeholder=\"自我介绍一下吧！\"&gt;&lt;/textarea&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"reset\" id=\"reset\" value=\"重置\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"提交\"&gt; &lt;/p&gt;&lt;/form&gt;&lt;script src=\"https://gitguanqi.github.io/fedemo/public/js/gjs.min.js\"&gt;&lt;/script&gt; 温馨提示：前提是你要引入一个js文件，分别是gjs.js 123.tips &#123; color: #f00;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//禁止默认提交function returnForm() &#123; return false;&#125;//确定重置提示function confirmForm() &#123; var reset = confirm('你确定要清空所有输入的内容吗？'); return reset;&#125;//验证表单内容var tips = $g.ecls('tips');var btn = document.myform.submit;$g.addEvent(btn, 'click', checkFrom, false);function checkFrom() &#123; //正则表达式 var formreg = /\\w&#123;5,&#125;/; //表单元素 var myform = document.myform; var username = myform.username.value; var password = myform.password.value; var sex = myform.sex.value; var hobbies = myform.hobbies; var city = myform.city.value; var headimg = myform.headimg.value; var comment = myform.comment.value; var flag = false; if (username == '') &#123; tips[0].innerText = '昵称不能为空'; flag = false; &#125; else if (!formreg.test(username)) &#123; tips[0].innerText = '请输入6-10位名字'; flag = false; &#125; else &#123; tips[0].innerText = ''; flag = false; &#125; if (password == '') &#123; tips[1].innerText = '密码不能为空'; flag = false; &#125; else if (!formreg.test(password)) &#123; tips[1].innerText = '请输入至少6位密码'; flag = false; &#125; else &#123; tips[1].innerText = ''; flag = false; &#125; if (sex == '') &#123; tips[2].innerText = '性别不能为空'; flag = false; &#125; else &#123; tips[2].innerText = ''; flag = false; &#125; var isChecked; for (var i = 0; i &lt; hobbies.length; i++) &#123; var checked = hobbies[i].checked; if (checked) &#123; isChecked = true; &#125; &#125; if (!isChecked) &#123; tips[3].innerText = '爱好不能为空'; flag = false; &#125; else &#123; tips[3].innerText = ''; flag = false; &#125; if (city == '') &#123; tips[4].innerText = '城市不能为空'; flag = false; &#125; else &#123; tips[4].innerText = ''; flag = false; &#125; if (headimg == '') &#123; tips[5].innerText = '头像不能为空'; flag = false; &#125; else &#123; tips[5].innerText = ''; flag = false; &#125; if (comment == '') &#123; tips[6].innerText = '自我介绍不能为空'; flag = false; &#125; else &#123; tips[6].innerText = ''; flag = true; &#125; return flag;&#125; 效果展示这个例子是兼容IE5-11，Firefox，Google Chrome等游览器的。 如果你想要看效果，请点击【这里】前去GitHub查看。","categories":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/categories/前端案例/"}],"tags":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/tags/前端案例/"},{"name":"表单验证","slug":"表单验证","permalink":"https://guanqi.xyz/tags/表单验证/"}]},{"title":"鼠标和键盘事件案例","slug":"front-event-mouse-key-eg","date":"2019-02-01T02:33:21.000Z","updated":"2019-03-08T04:01:55.968Z","comments":true,"path":"2019-02-01/front-event-mouse-key-eg/","link":"","permalink":"https://guanqi.xyz/2019-02-01/front-event-mouse-key-eg/","excerpt":"","text":"之前已经说过了事件的来龙去脉和属性以及方法，今天就说一下鼠标和键盘事件的案例。 温馨提示前提是你要引入一个gjs.js文件 https://gitguanqi.github.io/fedemo/public/js/gjs.min.js 才可以运行。 1&lt;script src=\"https://gitguanqi.github.io/fedemo/public/js/gjs.min.js\"&gt;&lt;/script&gt; 鼠标和键盘事件鼠标和键盘事件就是设备相关的事件，可以使用鼠标和键盘对文档进行操作，触发相应的事件。 鼠标事件案例既然之前已经知道了如何使用鼠标事件，那本节就提出两个案例，来对学过的知识的实践。 本节有两个案例，第一个是有关右击鼠标显示自定义菜单的；第二个是有关如何使用鼠标进行拖拽元素。 鼠标右击自定义菜单原理： 当鼠标右键按下后，获取鼠标坐标，然后赋值并且显示菜单元素； 当鼠标左键按下后，隐藏菜单元素； 菜单样式123456&lt;ul id=\"list\"&gt; &lt;li&gt;&lt;a href=\"#menu1\"&gt;菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#menu2\"&gt;菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#menu3\"&gt;菜单3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#menu4\"&gt;菜单4&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627#list &#123; margin: 0; padding: 0; width: 150px; height: 240px; border: 1px solid #eee; box-shadow: 1px 1px 5px #eee; list-style: none;&#125;#list li &#123; width: 150px; height: 60px; line-height: 60px; text-align: center;&#125;#list li:hover &#123; background-color: #ddd;&#125;#list li:hover a &#123; color: #333;&#125;#list li a &#123; display: inline-block; width: 100%; color: #666; text-decoration: none;&#125; 动效js操作1234567891011var uls = $g.eid('list');$g.addEvent(document, 'contextmenu', function (e) &#123; $g.prevent(e); $g.stoppro(e); uls.style.left = e.clientX + 'px'; uls.style.top = e.clientY + 'px'; uls.style.display = 'block';&#125;, false);$g.addEvent(document, 'click', function () &#123; uls.style.display = 'none';&#125;, false); 这个案例就到此为止，请点这里在GitHub上查看效果。 元素拖拽示例原理： 1.当点击鼠标，获取到鼠标坐标位置；然后减去元素距离左/上边的距离； 2.当移动元素，获取到元素距离左上的距离；用鼠标的坐标值减去上一步的值； 3.当放开鼠标，禁用鼠标移动事件和按下事件； 【如图所示】： 拖拽图 元素和样式1&lt;div class=\"box\"&gt; 123456789101112.box &#123; position: absolute; right: 0; top: 0; width: 150px; height: 150px; line-height: 150px; background-color: #f00; color: #fff; font-size: 20px; text-align: center;&#125; js动效1234var box = $g.eone('.box');var box1 = $g.eone('.box1');new $g.Drag(box);new $g.Drag(box1); 这个案例就到此为止，请点这里在GitHub上查看效果。 键盘事件案例键盘事件案例一般是用于鼠标事件案例的替代选择，如果用户的设备只支持键盘，就可以使用键盘事件代替是鼠标事件。 大多数事件都是有鼠标事件对应的键盘事件，两个事件都是可以触发同一函数方法的。 这个案例就是模拟聊天窗口，按住Enter键盘键，然后发送聊天内容。 聊天窗口模拟案例原理：当输入框输完内容后，按下键盘上的Enter发送聊天内容。 123&lt;div id=\"box\"&gt;&lt;/div&gt;&lt;input type=\"text\" name=\"con\" id=\"con\" placeholder=\"请输入聊天内容\"&gt;&lt;button id=\"send\"&gt;发送&lt;/button&gt; 1234567891011121314151617181920212223242526#box &#123; padding: 10px 15px; width: 250px; height: 400px; background-color: #f9f9f9; border: 1px solid #eee; overflow: auto;&#125;#con &#123; margin: 10px 0; padding: 0 10px; width: 200px; height: 30px; line-height: 30px; color: #333;&#125;#send &#123; position: relative; top: 2px; width: 50px; height: 35px; line-height: 35px; border: none; border: 1px solid #f8f8f8; cursor: pointer;&#125; 1234567891011121314151617181920212223242526272829var box = $g.eid('box');var con = $g.eid('con');var send = $g.eid('send');$g.addEvent(send, 'click', sendCon, false);function sendCon() &#123; if (con.value == '') &#123; alert('请输入内容！'); return; &#125; box.innerHTML += '&lt;p style=\"margin:2px auto;\"&gt;' + con.value + '&lt;/p&gt;&lt;br&gt;' con.value = '';&#125;$g.addEvent(con, 'keypress', sendKey, false);function sendKey(e) &#123; var e = e || window.event; var code = e.code; if (code == 'Enter' || e.keyCode == 13) &#123; if (con.value == '') &#123; alert('请输入内容！'); return; &#125; box.innerHTML += '&lt;p style=\"margin:2px auto;\"&gt;' + con.value + '&lt;/p&gt;&lt;br&gt;' con.value = ''; &#125;&#125; 如果想看效果，可以点这里在GitHub上查看。","categories":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/categories/前端案例/"}],"tags":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/tags/前端案例/"},{"name":"表单键盘案例","slug":"表单键盘案例","permalink":"https://guanqi.xyz/tags/表单键盘案例/"}]},{"title":"js之事件解读","slug":"js-events","date":"2019-01-31T02:33:21.000Z","updated":"2019-03-08T03:25:22.280Z","comments":true,"path":"2019-01-31/js-events/","link":"","permalink":"https://guanqi.xyz/2019-01-31/js-events/","excerpt":"","text":"在js中，具有交互性程序的是事件驱动。它可以很好的和用户进行互动，增强网页的趣味性和互动效果，提高更好的用户体验。今天我分享一篇有关事件驱动的文章，讲诉事件的来龙去脉，文章有不妥之处，还请电邮反馈。 事件的起源这节开始说事件的起源，也就是原始事件模型。这是最初始的事件处理模式，通常把它当作0级DOM的一部分，所有游览器都支持。 事件以及事件类型事件就是当用户在用鼠标或者键盘对网页进行操作时所，触发了的网页调用某个方法，反馈给用户的结果。不同的事件类型，生成的事件也不一样，反馈效果也不一样。 在原始事件模型中，事件不能被js直接操作，是游览器从内部提取的。这些事件类型都是响应事件调用时的事件句柄名称。HTML属性就可以用来处理这些事件代码。 下面是收集总结的事件句柄列表： 序号 事件句柄 触发条件 支持元素 1 onload 文档加载完毕 &lt;body&gt; 2 unonload 文档卸载完毕 &lt;body&gt; 3 onresize 调整窗口大小 &lt;body&gt; 4 onabort 图像加载被中断 &lt;img&gt; 5 onerror 图像加载发生错误 &lt;img&gt; 6 onclick 鼠标按下被释放 大多数元素 7 ondbclick 双击鼠标 大多数元素 8 onmousedown 鼠标键被按下 大多数元素 9 onmousemove 鼠标移动 大多数元素 10 onmouseup 释放鼠标键 大多数元素 11 onmouseover 鼠标移到元素上 大多数元素 12 onmouseout 鼠标离开元素 大多数元素 13 onkeydown 键盘被按下 表单元素、&lt;body&gt; 14 onkeyup 键盘被按下后释放 表单元素、&lt;body&gt; 15 onkeypress 键盘按下被释放，返回false取消默认 表单元素、&lt;body&gt; 16 onblur 元素失去焦点 &lt;body&gt;&lt;input&gt;&lt;textarea&gt;&lt;button&gt;&lt;select&gt; 17 onfocus 元素得到焦点 &lt;body&gt;&lt;input&gt;&lt;textarea&gt;&lt;button&gt;&lt;select&gt; 18 onchange 得到焦点使值发生了改变 &lt;input&gt;&lt;textarea&gt;&lt;select&gt; 19 onselect 选中表单文本 &lt;input&gt;&lt;select&gt;&lt;textarea&gt; 20 onreset 表单重置，返回false取消 &lt;form&gt; 21 onsubmit 表单提交，返回false取消 &lt;form&gt; 以上是一些定义的事件列表，仔细点，你会发现列表中可以大致的分为鼠标事件、键盘事件、表单事件以及其他事件。后面会详细介绍。 html属性的事件之前说过，事件是用户在对html标签进行触发时调用的js方法，用来执行一些相关的任务。 所以在html中，以上列表的事件可以被当作html的属性来使用。这里部分大小写，但是我还是习惯小写。 【例如】：给一个按钮加上事件，弹出内容。 1&lt;button onclick=\"alert('你好啊，事件！');\"&gt;点我&lt;/button&gt; js属性的事件如果不想再html属性值里面写js的方法，字符串，可以在js中写这样一个方法，然后在html属性中进行调用，同样也可以的。 【例如】：给一个输入框加上提示。 1&lt;input type=\"text\" name=\"username\" onchange=\"tips(event);\"&gt; 1234567function tips(event) &#123; var val = event.target.value; var nameReg = /^[\\u4e00-\\u9fa5]&#123;0,&#125;$/; if (!nameReg.test(val)) &#123; alert('请输入中文！'); &#125;&#125; 还可以这样写。 1&lt;input type=\"text\" name=\"username\"&gt; 1234567891011121314151617var username = document.getElementsByName('username')[0];username.onchange = tips;function tips(event) &#123; var val = event.target.value; var nameReg = /^[\\u4e00-\\u9fa5]&#123;0,&#125;$/; if (!nameReg.test(val)) &#123; alert('请输入中文！'); &#125;&#125;// 或者这样username.onchange = function (event) &#123; var val = event.target.value; var nameReg = /^[\\u4e00-\\u9fa5]&#123;0,&#125;$/; if (!nameReg.test(val)) &#123; alert('请输入中文！'); &#125;&#125; js事件的返回值大多数情况下，事件都有返回值，如果是true就执行，不是就取消。 比如说：onclick事件，如果返回true就执行，否则不执行。 【例如】:提交表单不执行默认提交方法。 1234&lt;form name=\"login\" onsubmit=\"return checkForm();\"&gt; &lt;input type=\"text\" name=\"username\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 123function checkForm() &#123; return false;&#125; 其实还有表单重置事件也是这样，你可以私下里去练习一下。 this关键词js中的this是一个很神奇的存在，一般情况下，它都指向的是Window顶层全局对象，也包括函数调用。 【例如】：你打印一下这个this，你会发现结果是Window。 12345console.log(this); // Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;function hello() &#123; console.log(this); // Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;&#125;hello(); 但是也有其他情况，比如说对象方法调用，事件调用。这种情况下，就是谁调用，指向谁。对象里面的方法调用会指向对象本身。 【例如】： 1.对象方法调用 12345678910//对象方法调用var obj = &#123; name: 'mark', sayName: function () &#123; console.log(this); // &#123;name: \"mark\", sayName: ƒ&#125; console.log(this.name); // mark return this.name; &#125;&#125;console.log(obj.sayName()); // mark 注意:如果把对象中的方法赋予另一个变量，由于这个变量是Window下的变量、属性，所以再次打印this会指向Window对象。 123456789//对象方法调用var obj = &#123; name: 'mark', sayName: function () &#123; console.log(this); // Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125; &#125;&#125;var fn = obj.sayName;console.log(fn()); 2.事件调用 1&lt;button id=\"tip\"&gt;点我&lt;/button&gt; 123456//事件方法调用var tip = document.getElementById('tip');tip.onclick = function(event) &#123; console.log(this); // &lt;button id=\"tip\"&gt;点我&lt;/button&gt; console.log(this.id); // tip&#125; 作用域在js中，有变量作用域，有函数作用域，但是所有作用域的顶层都是全局对象。 在事件句柄中，也存在作用域，但是这个作用域只是适用于html属性的事件句柄。 例如：在一个button按钮中调用了名为form的变量，那么就会解析成form属性。 1234&lt;form&gt; &lt;input type=\"text\" name=\"username\" value=\"hello\"&gt; &lt;button onclick=\"alert(this.form.username.value);\"&gt;点我&lt;/button&gt;&lt;/form&gt; 在此案例中，当点我按钮点击后会把form解析成这个表单属性，从而获取到旁边输入框的值hello。 事件的2级DOM标准在经历了原始事件模型后，DOM又进行了扩展，定义了一些高级的事件处理方法。这些方法除了ie游览器外其他的游览器都支持。ie有自己的处理方法，这些方法会在第三节进行补充。 事件传播在0级DOM事件模型中，是游览器负责把事件分配到发生事件的元素，如果那个元素有合适的事件类型就会触发，不会再执行其他的操作。 但是2级DOM标准中规定的是只要事件发生在文档元素（目标元素）上，就会触发。它的上级元素也有机会触发该事件。 此时就有了事件传播，它主要是分为3个阶段进行。 事件传播的捕捉阶段(capturing)这个阶段事件从Document对象沿着DOM树向下传播给那个目标节点。 这个阶段是从上到下进行传播，如果在途中有目标节点的祖先注册了捕捉事件句柄，就会先执行这个事件。 事件传播的第二个阶段(self)这个阶段已经到达了目标元素本身，直接注册在元素本身的事件就会执行。 事件传播的起泡阶段(bubbling)这个阶段，目标元素已经执行完自身的事件句柄了，所以这个阶段的事件就会沿着DOM树向上回到Document对象。如果在途中有目标节点的祖先有合适的事件句柄，就会先执行这个事件。 但是并非所有的事件类型都起泡，像表单这种form元素执行完自身事件后再往Document对象走没有意义。 一般来说，原始事件起泡，而高级语义的事件不起泡。 下面一张表就列出了哪些适用于哪个阶段的事件传播。 序号 事件类型 接口 B(起泡) C(捕捉) 支持元素/属性 1 abort Event yes no &lt;img&gt; 2 blur Event no no &lt;a&gt;&lt;area&gt;&lt;button&gt;&lt;input&gt;&lt;select&gt;&lt;textarea&gt; 3 change Event yes no &lt;input&gt;&lt;select&gt;&lt;textarea&gt; 4 click MouseEvent yes yes screenX,screenY,clientX,clientY,altKey,ctrlKey 5 error Event yes no &lt;body&gt;,&lt;frameset&gt;&lt;img&gt; 6 focus Event no no &lt;a&gt;&lt;area&gt;&lt;button&gt;&lt;input&gt;&lt;select&gt;&lt;textarea&gt; 7 load Event no no &lt;body&gt;&lt;frameset&gt;&lt;iframe&gt;&lt;img&gt; 8 mousedown MouseEvent yes yes screenX,screenY,clientX,clientY,altKey,ctrlKey 9 mousemove MouseEvent yes no screenX,screenY,clientX,clientY,altKey,ctrlKey 10 mouseout MouseEvent yes yes screenX,screenY,clientX,clientY,altKey,ctrlKey 11 mouseover MouseEvent yes yes screenX,screenY,clientX,clientY,altKey,ctrlKey 12 mouseup MouseEvent yes yes screenX,screenY,clientX,clientY,altKey,ctrlKey 13 reset Event yes no &lt;form&gt; 14 resize Event yes no &lt;body&gt;&lt;iframe&gt;&lt;frameset&gt; 15 scroll Event yes no &lt;body&gt; 16 select Event yes no &lt;input&gt;&lt;textarea&gt; 17 submit Event yes yes &lt;form&gt; 18 unload Event no no &lt;body&gt;&lt;frameset&gt; 19 DOMActivate UIEvent yes yes detail 20 DOMFocusIn UIEvent yes no none 21 DOMFocusOut UIEvent yes no none 温馨提示: 在事件传播的过程中，任何事件句柄都可以使用表示事件的Event对象提供的stopPropagation()方法来停止事件的传播。 也有一些事件会引起游览器对元素的默认动作，比如a标签，默认动作是超链接跳转。在事件传播阶段结束后，便会进行默认动作。可以使用Event对象提供的preventDefault()方法来阻止默认动作的发生。 在0级DOM模型中，只能为特定对象的特定类型的事件注册一个事件句柄，但是在2级模型中，就可以为特定对象的特定类型的事件注册多个事件句柄。 事件句柄注册在0级DOM事件中，通过html属性或者js来为元素注册事件;但在2级DOM事件中，可以调用addEventListener()方法来为某个元素注册事件,该方法有3个参数。 第一个参数是事件类型，不加前缀on，比如：onmouseover要写成mouseover; 第二个参数是句柄函数，也就是事件发生时调用的函数;这个函数只接受唯一的Event对象； 第三个参数是布尔值，值为true，那就用于捕捉事件，否则就是直接发生在元素本身的事件； 这个注册方法只对注册的元素有用，是独立的，可以为一个元素注册多个事件而互相不受影响的。 【例如】： 为按钮注册一个点击事件。 1&lt;button id=\"clickme\"&gt;点我&lt;/button&gt; 12345var clickme = document.getElementById('clickme');clickme.addEventListener('click',clickMe,false);function clickMe(e) &#123; console.log(this.id); // clickme&#125; 监听一个元素中发生的所有鼠标移入事件 1&lt;button id=\"overme\"&gt;点我&lt;/button&gt; 12345var overme = document.getElementById('overme');overme.addEventListener('mouseover',handlerMouse,true);function handlerMouse(e) &#123; console.log(this.id); // clickme&#125; 既然有注册，也就有注销事件，与之对应的是方法是removeEventListener(),它和注册方法接受的参数一样，不过是从元素上面移除了这个事件。 12345var overme = document.getElementById('overme');overme.removeEventListener('mouseover',handlerMouse,true);function handlerMouse(e) &#123; console.log(this.id); // clickme&#125; 小提示：这个注册方法中第二个参数的函数内部的this是指向注册事件的元素。 事件模块在2级DOM中，事件是模块化的，所以你可以使用以下方法来测试游览器是否支持2级DOM事件模块。 下面是我封装的一个方法，只需要传入两个参数就可以查询是否支持。 123456789101112function searchDomSupport(name,version) &#123; if (document.implementation &amp;&amp; document.implementation.hasFeature &amp;&amp; document.implementation.hasFeature(name,version) ) &#123; return true; &#125; else &#123; return false; &#125;&#125;var res = searchDomSupport('Event','2.0');console.log(res); // true; Event接口和Event2级DOM API提供了事件发生时事件的一些额外信息，包括事件发生的时间，类型，元素的属性等等。事件是模块化的，所以一个模块就有一个相关的事件接口，声明了该事件类型的详细信息。 Event接口就是这个事件接口，它包括以下几部分： 序号 模块名 事件接口 事件类型 1 HTMLEvents Eevent abort,blur,change,load,resize,scroll,select 2 MouseEvents MouseEvent click,mousedown,mouseup,mouseover,mouseout 3 UIEvents UIEvent DOMActivate,DOMFocusIn,DOMFocusOut Event的属性 type,发生事件的类型，和注册事件名称一样，比如：click，mouseover； target,发生事件的节点信息； currentTarget,发生当前事件的节点,在事件传播过程中和target的值不一样； eventPhase,一个数字表明当前所处的传播阶段，是一个常量； timeStamp,一个Date()对象，表面事件发生的时间； bubbles,一个布尔值，声明该事件是否在文档中起泡； cancelable,一个布尔值，声明该事件是否能用preventDefault()方法； 【例如】：获取按钮的点击事件的属性。 1&lt;button id=\"tips\"&gt;点我&lt;/button&gt; 1234567891011var tips = document.getElementById('tips');tips.onclick = function (e) &#123; var e = e || window.event; console.log(e.type); // click console.log(e.target); // target: button#tips console.log(e.currentTarget); // null console.log(e.eventPhase); // 2 console.log(e.timeStamp); // 3006.099999998696 console.log(e.bubbles); // true console.log(e.cancelable); // true&#125; Event的方法 stopPropagation(),阻止事件从当前正在处理它的节点传播； preventDefault()，阻止游览器执行节点的默认动作； 【例如】: 12345678// 调用此函数function clickMe(e) &#123; e.stopPropagation();&#125;//超链接跳转禁用function clickMe(e) &#123; e.preventDefault();&#125; UIEvent的属性 view,发生事件的Window对象； detail，对于鼠标点击事件来说，值为1就是点击1次，为2就是点击2次。如果值为2，说明之前还有一个点击为1的事件； MouseEvent的属性 button,一个数字，声明在mousedown,mouseup,click事件中，哪个鼠标键改变了状态。0为左键，1为中间键，2为右键； altKey、ctrlKey、metaKey、shiftKey,这四个值都是布尔值，声明在鼠标事件发生时，是否同时按住了这四个键盘键；alt,ctrl,shift,meta; clientX、clientY,声明鼠标指针位于游览器窗口的X坐标和Y坐标；不考虑文档滚动，如果在顶部则clientY始终是0；在ie以外，要转换成文档坐标，而不是游览器窗口坐标；可以使用window.pageXOffset和window.pageYOffset来获取。 screenX、screenY,声明鼠标指针位于用户显示器的左上角的X坐标和Y坐标; relatedTarget,引用事件的节点相关的节点。比如：对于mouseover，是鼠标移入目标节点离开时的那个节点； 【例如】：按钮的点击事件属性 1&lt;button id=\"tips\"&gt;点我&lt;/button&gt; 12345678var tips = document.getElementById('tips');tips.onclick = function (e) &#123; console.log(e.button); // 0 console.log(e.altKey,e.ctrlKey,e.metaKey,e.shiftKey); // false false false true console.log(e.clientX,e.clientY); // 22 17 console.log(e.screenX,e.screenY); // 22 119 console.log(e.relatedTarget); // null&#125; 温馨提示：2级DOM事件模型是可以兼容0级DOM事件的一些属性和方法。这叫混合事件模型。 IE事件模型本节介绍的是IE4、5、6支持的中间模型，它介于0级模型和2级DOM事件模型之间。包括以下几部分： Event对象，和2级DOM事件模型的Event属性有些相似； IE事件的传播、注册和内存泄漏 Event对象的属性 type,发生事件的类型，和2级DOM中的type属性兼容。比如：click，mouseover； srcElement,发生事件的文档元素，和2级DOM中的target属性兼容； button,声明鼠标被按下的鼠标键；值为1是左键，2为右键，4为中间键； clientX、clientY,声明鼠标指针位于游览器窗口的X坐标和Y坐标；要转换成文档坐标,需要加文档滚动的量； offsetX、offsetY,声明鼠标指针位于元素的位置； altKey、ctrlKey、shiftKey,这四个值都是布尔值，声明在鼠标事件发生时，是否同时按住了这三个键盘键; keyCode,声明在键盘事件(keydown,keyup,keypress)中的键盘码；可以用String.fromCharCode()方法把字符代码转换成字符串； fromElement、toElement,fromElement声明mouseover事件移动过的文档元素，toElement声明mouseout事件移到的文档元素； cancelBubble,布尔值为true时阻止当前事件进一步起泡到上一层次的元素；相当于2级DOM中的stopPropagation()方法； returnValue,布尔值为false时可以阻止游览器执行默认动作，相当于2级DOM中的preventDefault()方法； 【例如】：在ie游览器中进行点击事件。 1&lt;button id=\"tips\"&gt;点我&lt;/button&gt; 1234567891011var tips = document.getElementById('tips');tips.onclick = function (e) &#123; console.log(e.type); // click console.log(e.srcElement); // &lt;button id=\"tips\"&gt;点我&lt;/button&gt; console.log(e.button); // 0 console.log(e.clientX,e.clientY); // 30.399999618530273 14.399999618530273 console.log(e.offsetX,e.offsetY); // 29.399999618530273 11.800000190734863 console.log(e.altKey,e.ctrlKey,e.shiftKey); // false false false console.log(e.cancelBubble); // false console.log(e.returnValue); // undefined&#125; 温馨提示：IE中事件模型Event对象是作为全局的变量，在Window对象下的，所以要使用必须这样写window.event。 IE事件注册ie4中是和0级模型一样的方法；ie5以及以后的版本是使用attachEvent()方法和detachEvent()方法，类似于2级DOM事件模型中的事件监听注册方法；但是不同的是： IE事件模型不支持事件捕捉，所以这两个方法的参数只要两个； 第一个参数的事件类型名称应该包括on这个前缀；例如：click要写成onclick; attachEvent()方法注册的函数将作为全局函数调用，而不是事件的目标元素，this关键词指向Window; attachEvent()方法允许注册多次，当事件发生时，注册函数的被调用次数和注册次数一样多； 事件起泡:IE事件模型中的事件起泡，想要阻止只能把cancelBubble这个属性设置为true,当新事件生成时，又会自动还原成false。 事件捕捉：IE事件模型中的事件捕捉，可以使用setCapture()和releaseCapture()方法来实现，只是对鼠标事件适用。 内存泄漏：IE6之前的嵌套函数容易引起内存泄漏。 IE兼容性方法下面是我根据原始事件模型、2级DOM事件模型和IE事件模型，封装的一个方法。 1234567891011121314151617181920212223242526272829303132var uniHandler= &#123;&#125;;if (document.addEventListener) &#123; uniHandler.add = function (elem,eventType,handleEvent,isCapture) &#123; elem.addEventListener(eventType,handleEvent,isCapture); &#125; uniHandler.remove = function (elem,eventType,handleEvent,isCapture) &#123; elem.removeEventListener(eventType,handleEvent,isCapture); &#125; uniHandler.stoppro = function () &#123; e.stopPropagation(); &#125;; uniHandler.prevent = function () &#123; e.preventDefault(); &#125;&#125; else if (document.attachEvent) &#123; uniHandler.add = function (elem,eventType,handleEvent) &#123; elem.attachEvent('on'+eventType,handleEvent); &#125; uniHandler.remove = function (elem,eventType,handleEvent) &#123; elem.detachEvent('on'+eventType,handleEvent); &#125; uniHandler.stoppro = function () &#123; e.cancelBubble = true; &#125;; uniHandler.prevent = function () &#123; e.returnValue = false; &#125;&#125; else &#123; uniHandler.eventOrigin = function (elem,eventType,handleEvent) &#123; elem.eventType = handleEvent; &#125;&#125; 【例如】:在ie和非ie游览器中测试，均没有问题；ie包括ie5-11。 一个按钮注册点击事件 1&lt;button id=\"tips\"&gt;点我&lt;/button&gt; 1234var tips = document.getElementById('tips');uniHandler.add(tips,'click',function () &#123; alert('你好！');&#125;,false); 一个链接注册点击事件，并且阻止游览器默认动作 1&lt;a id=\"goto\" href=\"#111\" target=\"_blank\"&gt;链接&lt;/a&gt; 123456var goto = document.getElementById('goto');uniHandler.add(goto,'click',function (e) &#123; var e = e || window.event; uniHandler.prevent(e); alert('我不走！');&#125;,false); 写在最后有关DOM中的事件今天就说到这里，还有不明白的可以到前面去仔细看看，多练练，你就会了。","categories":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/tags/js/"},{"name":"js基础","slug":"js基础","permalink":"https://guanqi.xyz/tags/js基础/"},{"name":"DOM","slug":"DOM","permalink":"https://guanqi.xyz/tags/DOM/"},{"name":"events","slug":"events","permalink":"https://guanqi.xyz/tags/events/"}]},{"title":"js之Cookie的属性和用法","slug":"js-cookie","date":"2019-01-30T09:33:21.000Z","updated":"2019-03-08T03:28:43.458Z","comments":true,"path":"2019-01-30/js-cookie/","link":"","permalink":"https://guanqi.xyz/2019-01-30/js-cookie/","excerpt":"","text":"今天，说一下这个cookie的属性和用法，包括设置cookie,获取cookie,删除cookie。cookie是Document对象的一个属性，可以使js方便的把一些数据放在在本地进行存取操作。cookie还用于客户端脚本化，是http协议的一个标准扩展。 cookie的概念cookie是Web游览器存储的少量命名数据，它作用于某个特定的网页或者网站。它可以在客户端和服务器之间的传递数据，位于服务器端的脚本可以读取到客户端的cookie。 常用的使用场景有以下几个： 用户登录，服务器记录下用户的登录信息，以便验证下次是否重新登录； 电商网站的购物车，记录下用户的购物车购买东西喜好，以便下次推广相关的产品； 网络广告主和网络广告服务商的广告推广，对于不同网站进行用户广告的推送。 温馨提示：由于cookie是http协议的标准扩展，所以要在http协议下的网站和页面才可以使用cookie。不要使用在游览器中打开（类似于：file:///D:/test.html），建议开启http服务（http://localhost:2009/test.html）。 检测是否支持由于用户登录或者购物车需要记录cookie的有关信息，所以首先要检测用户的游览器是否开启了cookie，没有开启要提示用户开启cookie后在操作。 下面是检测游览器的cookie是否开启的方法： 1&lt;p id=\"cookieTips\"&gt;&lt;/p&gt; 12345678910111213141516//isOpenCookie这个方法需要传一个id用来给用户显示提示语。function isOpenCookie(id) &#123; var cookieTips = document.getElementById(id); var result = window.navigator.cookieEnabled; if (result) &#123; cookieTips.style.color = '#269d26'; cookieTips.style.fontSize = '18px'; cookieTips.innerHTML = '您的cookie已激活!'; &#125; else &#123; cookieTips.style.color = '#f00'; cookieTips.style.fontSize = '18px'; cookieTips.innerHTML = '您的cookie未激活，可能不能享受好的服务!'; &#125; return result;&#125;console.log(isOpenCookie('cookieTips')); // true cookie的属性cookie的属性有名字和值，最大期限，当前可以访问cookie信息的文件路径，可以访问cookie的网站域名，还有安全性属性，下面一一介绍。 名字和值这个就是name和value属性了，name是你要存的数据的名字，value是你要存的名字对应的值。 由于这个值是明文可见的，非常的不安全，所以你要进行编码和解码操作，可以使用以下两种方法： 早期的方法：escape()编码，unescape()解码；（已废弃，但可以用） 新的方法：encodeURIComponent()编码，decodeURIComponent()解码。 方法： document.cookie = &quot;&lt;名字&gt;=&lt;值&gt;&quot;。 例如：document.cookie = &quot;title=&quot; + encodeURIComponent(&#39;世界那么大&#39;)。 最大期限最大期限之前是expires属性（已废弃）；现在是max-age来表示，它接收秒作为单位。 方法： document.cookie = &quot;max-age=&lt;数字&gt;&quot;。 例如：document.cookie = &quot;title=&quot; + encodeURIComponent(&#39;你好啊&#39;) + &quot;;max-age=&quot; + 60*60*24*7;。 pathpath就是当前文件所在的目录，在这个目录下的所以网页都可以共享这个cookie信息，但是不在这个路径下的网页就享受不到这个cookie信息了。 比如说：test.html在server这个目录下，test.html的网页设置了cookie，那么这个server下面的其他网页也可以共享这一个cookie信息；但是不在server这个目录下的网页就享受不到这个cookie信息了。 可以通过设置这个属性来告诉游览器哪些目录下的网页可以获取cookie信息。 方法： document.cookie = &quot;path=&#39;&lt;文件路径名字&gt;&#39;&quot;。 例如：document.cookie = &quot;title=&quot; + encodeURIComponent(&#39;你好啊&#39;) + &quot;;max-age=&quot; + 60*60*24*7 + &#39;;path=&#39; + &#39;/&#39;;。 domaindomain就是当前html文件所在的这个网站（不包括二级域名），在这个网站下的所以网页都可以共享这个cookie信息，但是不在这个网站下的网页就享受不到这个cookie信息了。 比如说：test.html在http://www.examle.com这个目录下，test.html的网页设置了cookie，那么这个http://www.examle.com网站下面的其他网页也可以共享这一个cookie信息；但是不在http://www.examle.com这个网站下的网站（比如：http://blog.examle.com）网页就享受不到这个cookie信息了。 可以通过设置这个属性来告诉游览器哪些网站可以获取cookie信息。 方法： document.cookie = &quot;domain=&#39;&lt;网站域名&gt;&#39;&quot;。 例如：document.cookie = &quot;title=&quot; + encodeURIComponent(&#39;你好啊&#39;) + &quot;;max-age=&quot; + 60*60*24*7 + &#39;;domain=&#39; + &#39;127.0.0.1&#39;; 那么其他的比如说localhost下面的网页无法获取cookie信息。 secure这个属性是一个布尔值，如果添加到一条cookie记录中，那么这个cookie只能在带有https安全协议或者其他安全协议的网站下面进行存取。 例如:document.cookie = &quot;title=&quot; + encodeURIComponent(&#39;你好啊&#39;) + &quot;;max-age=&quot; + 60*60*24*7 + &#39;;secure&#39; cookie的方法设置cookie可以通过封装一个方法来方便的设置cookie，下面是我封装的一个设置cookie的方法，里面要传五个参数，分别对于五个属性。 原理就是对传入的参数进行类型检测，然后遍历对象的属性和值进行存储。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function setCookie(name,value,maxAge,path,domain,secure) &#123; //检测flag var cookieinfo = &#123; name: name, value: value, maxAge: maxAge, path: path, domain: domain, secure: secure &#125;; var res = ''; //验证值 for(key in cookieinfo) &#123; var val = cookieinfo[key]; if (key == 'path') &#123; if (!val) &#123; continue; &#125;else if (typeof val != 'string') &#123; throw new Error('Error: path must be an string!'); &#125; &#125;else if (key == 'domain') &#123; if (!val) &#123; continue; &#125;else if (typeof val != 'string') &#123; throw new Error('Error: domain must be an string!'); &#125; &#125;else if (key == 'secure') &#123; if (!val) &#123; continue; &#125;else if (typeof val != 'boolean') &#123; throw new Error('Error: secure must be an boolean!'); &#125; &#125;else if (val == '' || val == undefined || val == null) &#123; throw new Error('Error:' + key + ' not a null value!'); &#125; &#125; //赋值 for (var key in cookieinfo) &#123; var val = cookieinfo[key]; if (val == undefined) &#123; continue; &#125; if (key == 'value') &#123; continue; &#125; if (key == 'name') &#123; res += cookieinfo['name'] + '=' + encodeURIComponent(cookieinfo['value']) + ';'; &#125;else if (key == 'maxAge') &#123; res += 'max-age' + '=' + cookieinfo['maxAge'] + ';'; &#125; else if (key == 'secure' &amp;&amp; cookieinfo['secure'] === true) &#123; res += 'secure;'; &#125; else &#123; res += key + '=' + val + ';'; &#125; &#125; if (res) &#123; document.cookie = res; &#125;&#125;//例如：setCookie('title',document.title,60*60*24*7,'/','127.0.0.1',secure); 读取cookie可以通过封装一个方法来方便的读取cookie，下面是我封装的一个读取cookie的方法，里面要传两个参数，第一个是布尔值，true表示获取全部cookie,false表示不用；第二个参数是你要获取的cookie名字。 原理就是对cookie进行分解，然后再进行对比，返回相应的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function getCookie(isAll,name) &#123; var tisAll = isAll; var tname = name; if (typeof tisAll != 'boolean') &#123; throw new Error('Error: tisAll not an boolean!'); &#125; if (!tisAll) &#123; if (tname == 'undefined' || tname == null || tname == '' || typeof tname == 'object' || typeof tname == 'function') &#123; throw new Error('Error: name not an object or function or undefined!'); &#125; &#125; var cookie = document.cookie; var cookies = cookie.split(';'); var value = ''; var allObj = &#123;&#125;; for(var i=0;i&lt;cookies.length;i++) &#123; var vals = cookies[i].split('='); var allKey = vals[0].trim(); var allVal = decodeURIComponent(vals[1]); if (allKey == '' &amp;&amp; allVal == '') &#123; continue; &#125; else &#123; if (tisAll) &#123; allObj[allKey] = allVal; &#125; else &#123; if (tname == allKey) &#123; value = allVal; &#125; &#125; &#125; &#125; if (!tisAll &amp;&amp; value == '') &#123; throw new Error('Error:' + tname + ' not found!'); &#125; if (tisAll) &#123; for (var key in allObj) &#123; if (key == '' &amp;&amp; allObj[key] == 'undefined') &#123; throw new Error('Error: all cookie not found!'); &#125; &#125; &#125; var res = tisAll ? allObj : value; return res;&#125;//例如：上面的cookie值console.log(getCookie(false,'title')); // 你好啊 删除cookie可以通过封装一个方法来方便的删除cookie，下面是我封装的一个删除cookie的方法，里面要传一个参数，参数是你要删除的cookie名字。 原理：只要设置这个cookie的期限为0，就可以删除这个cookie了。 12345678910111213141516171819202122function removeCookie(name) &#123; if (name == '' || name == undefined || name == null) &#123; throw new Error('Error: name not an null!'); &#125; var cookie = document.cookie; var cookies = cookie.split(';'); var res; for(var i=0;i&lt;cookies.length;i++) &#123; var vals = cookies[i].split('='); var allKey = vals[0].trim(); if (name == allKey) &#123; res = true; &#125; &#125; if (!res) &#123; throw new Error('Error:' + name +' not found!'); &#125; document.cookie = name + '=' + '' + ';max-age=0';&#125;//例如：删除上面的titleremoveCookie('title'); 写在最后有关cookie的知识点就讲这么多，老铁，赶快用起来吧！","categories":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/tags/js/"},{"name":"js方法","slug":"js方法","permalink":"https://guanqi.xyz/tags/js方法/"},{"name":"cookie操作","slug":"cookie操作","permalink":"https://guanqi.xyz/tags/cookie操作/"}]},{"title":"js之DOM详解","slug":"js-dom-use","date":"2019-01-27T01:35:21.000Z","updated":"2019-03-08T03:28:41.091Z","comments":true,"path":"2019-01-27/js-dom-use/","link":"","permalink":"https://guanqi.xyz/2019-01-27/js-dom-use/","excerpt":"","text":"之前说过BOM是游览器对象模型，提供了很多操作游览器、操作窗口的属性和方法。那从今天开始讲述有关DOM的知识点。 DOM的概念DOM英文全称是Document Object Model,简称DOM，含义是文档对象模型。这个是核心的js语法所没有的，是对核心js的扩展。 每个游览器窗口都显示一个HTML文档，那每个窗口就有一个Window对象，而它的属性document就是引用的Document对象。 DOM的发展也是一步步来的，从最开始的Netscape和ie指定的一些DOM操作属性和方法；到1998年10月，W3C组织制定了1级DOM标准，到2000年发布了2级DOM标准，DOM的功能也在不断的扩展补充，从最开始的静态显示到后面的动态读写，逐步完善起来。 注意：这里指的文档是HTML文档，HTML文档被人们习惯性的叫做网页。 0级DOM(旧规范)属性 title,文档的标题；位于&lt;title&gt;&lt;/title&gt;之间的文本； cookie,一个特殊属性,允许js可以读写HTTP Cookie； domain,可以使在同一域中的相互信任的服务器之间进行网页交互避免同源策略安全性的限制； lastModified,文档的修改日期； referrer,文档的URL，包含游览器带到当前文档的链接； URL，等同于Window对象的属性location.href； location,等价于属性URL,（现已废弃）； bgColor,文档的背景颜色，（现已废弃）； 例如： 12345678console.log('文档的标题：',document.title); // 文档的标题： Documentconsole.log('cookie值：',document.cookie); // cookie值： console.log('文档的域：',document.domain); // 文档的域： localhostconsole.log('文档的最新修改日期：',document.lastModified); // 文档的最新修改日期： 01/27/2019 09:02:46console.log('文档的链接：',document.referrer); // 文档的链接： http://localhost:2009/test.htmlconsole.log('文档的背景颜色：',document.bgColor = '#f808080'); // 文档的背景颜色： #f00console.log('文档的当前链接：',document.location); // 文档的当前链接： Location &#123;replace: ƒ, assign: ƒ, href: \"http://localhost:2009/test.html\"…&#125;console.log('文档的链接地址：',document.URL); // 文档的链接地址： http://localhost:2009/test.html 案例防止外链，当游览者在网站的其他页面，可以跳转到当前主页，再去访问其他页。 1234// 检测是否本网站域名，跳转到本网站主页if (document.referrer == '' || document.referrer.indexOf(\"example.com\") == -1) &#123; document.location = 'http://www.example.com';&#125; 方法这个方法就是向当前文档中插入一个文本，它有时会覆盖到已存在的一些文本，所以最好在文档解析完成后再调用此方法。 和open()以及close()方法一起组合会更加好。 例如： 1234567function hello() &#123; var d = window.document; d.open(); d.write('&lt;h2&gt;Hello,world!&lt;/h2&gt;'); d.close();&#125;hello(); 文档对象集合这个也是0级DOM中遗留下来的一些属性和方法，不过它们的值都是数组，可以访问文档的 某些元素。 anchors[], Anchors对象的一个数组，该对象代表文档中的锚，就是&lt;a&gt;的name属性。 links[], Links对象的一个数组，该对象代表文档中的超文本链接，就是&lt;a&gt;的href属性,也包括通过&lt;area&gt;标记创建的热点链接属性。 images[], Images对象的一个数组，该对象代表文档中的&lt;img&gt;元素，Images对象的src属性是可以赋值的。可以实现图像翻滚和简单动画。 forms[], Forms对象的一个数组，该对象代表文档中的&lt;form&gt;表单元素，每个Forms对象都有自己的一个名为elements[]的集合属性。 案例获取表单元素文档中有一个表单名称叫login,有一个表单元素叫username，那么就可以使用命名Document对象的方法，直接用元素的name属性来命名。 123&lt;form name=\"login\"&gt; &lt;input type=\"text\" name=\"username\"&gt;&lt;/form&gt; 1234// 第一个就是表示这个表单，表单的可以用forms[按照文档的顺序第几个表单索引]，表单的元素用elements[这个表单的按照表单里面的顺序第几个元素]。var login = document.forms[0] || document.login;var username = document.forms[0].elements[0] || document.login.username;console.log(login,username); 注意：如果文档中有两个表单name一样，它会返回一个数组，所以要尽量保持name属性在文档中的唯一性。 获取文档中所有的链接123&lt;a href=\"#1\"&gt;链接1&lt;/a&gt;&lt;a href=\"#2\"&gt;链接2&lt;/a&gt;&lt;a href=\"#3\"&gt;链接3&lt;/a&gt; 12var links = document.links;console.log('所有的链接：',links); // 所有的链接： HTMLCollection(7) [a, a, a, a, a, a, a] 1级DOM(W3C标准)之前的DOM都是被一些公司操作着定义着用法内容，是老早的约定俗成的东西，但是缺乏规范和标准。W3C组织在1998年10月发布了DOM的标准，被后人成为1级DOM标准，它规定了DOM的一些属性和方法，包括DOM树，节点操作，属性操作，以及对html文档元素进行的创建、获取、修改、删除以及添加和插入等操作方法。 DOM树html是嵌套的有层级关系的一种超文本标记语言，在DOM就表示对象的一棵树。这个树从树根开始，到下面的元素节点，文本节点，组成了一颗树。 例如：这是最简单的一颗DOM树。 123456789&lt;html&gt;&lt;head&gt; &lt;title&gt;DOM树&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;DOM树&lt;/h2&gt; &lt;p&gt;你好，DOM树！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; DOM节点每一个元素都是一个节点，有元素节点，文本节点等，每个节点都由Node对象定义类型，用nodeType属性来表示。 节点列表: 序号 接口 nodeType常量 nodeType值 1 Element Node.ELEMENT_NODE 1 2 Text Node.TEXT_NODE 3 3 Document Node.DOCUMENT_NODE 9 4 Comment Node.COMMENT_NODE 8 5 DocumentFragment Node.DOCUMENTFRAGMENT_NODE 11 6 Attr Node.ATTRIBUTE_NODE 2 DOM树根部的Node是一个Document对象，这个对象的documentElement属性引用了一个Element对象，代表了文档的根元素。那以此类推，代表body这个节点的就是body。 补充：DOM的节点总的来说分为四个大的板块。 第一个是Document代表文档节点，就是HTMLDocument; 第二个是CharacterData代表就是文本和注释节点，Text和Comment; 第三个就Element代表着元素节点HTMLElement，比如像head、body、title等。 第四个是属性节点Attr，包括元素的各个属性。 节点还有父节点、子节点、兄弟节点等关系的节点，这个关系的节点都有对应的元素。 父节点和元素，parentNode，parentElement； 子节点和元素，childNodes,children; 当前节点的第一个子节点和元素，firstChild,firstElementChild; 当前节点的最后一个子节点和元素，lastChild,lastElementChild; 上一个兄弟节点和元素，previousSibling,previousElementSibling; 下一个兄弟节点和元素，nextSibling,nextElementSibling; 节点案例获取一个元素的各类节点以及元素这个案例就是如何表示一个元素的各类节点。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;DOM树&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;DOM树&lt;/h2&gt; &lt;h3&gt;兄弟&lt;/h3&gt; &lt;p&gt; &lt;span&gt;你好，DOM树！&lt;/span&gt; &lt;span&gt;你好，DOM节点！&lt;/span&gt; &lt;span&gt;你好，DOM节点对应的元素！&lt;/span&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324var helem = document.getElementsByTagName('h3')[0];var pelem = document.getElementsByTagName('p')[0];//1.helem的父节点，爷爷节点以及元素。var parent = helem.parentNode;var grandParent = parent.parentNode;var parentElem = helem.parentElement;var grandParentElem = parentElem.parentElement;console.log(parent,grandParent,parentElem,grandParentElem);//2.helem的子节点，第一个和最后一个子节点以及元素。var childs = pelem.childNodes;var firstChild = pelem.firstChild;var lastChild = pelem.lastChild;var childsElem = pelem.children;var firstChildElem = pelem.firstElementChild;var lastChildElem = pelem.lastElementChild;console.log(childs,firstChild,lastChild,childsElem,firstChildElem,lastChildElem); //3.helem的兄弟节点,下一个兄弟节点，上一个兄弟节点以及元素。var nextSibling = helem.nextSibling;var previousSibling = helem.previousSibling;var nextSiblingElem = helem.nextElementSibling;var previousSiblingElem = helem.previousElementSibling;console.log(nextSibling,previousSibling,nextSiblingElem,previousSiblingElem); 属性操作元素的属性操作方法： 获取属性getAttribute(); 设置属性setAttribute(); 移除属性removeAttribute(); 例如：一个链接元素的属性操作。由于还没有涉及到元素的一些操作，这里还是以0级DOM的方法来做。 1&lt;a href=\"\"&gt;属性操作&lt;/a&gt; 123456789101112131415//获取元素var linka = document.links[0];//设置属性linka.setAttribute('title','属性提示语');linka.setAttribute('class','属性类');console.log(linka); // &lt;a href=\"\" title=\"属性提示语\" class=\"attr\"&gt;属性操作&lt;/a&gt;//获取属性linka.getAttribute('class');console.log(cls); // attr//移除属性linka.removeAttribute('title');console.log(linka); // &lt;a href=\"\" class=\"attr\"&gt;属性操作&lt;/a&gt; 元素的操作下面就是对html文档元素进行的创建、获取、修改、删除以及添加和插入等操作方法。 获取元素获取元素有以下几种方法，都是Document对象下面的方法。分别从不同的方面进行获取元素，如通过id获取元素；通过标签名称获取元素，这个获取到就是类数组，会返回一个类似于数组的结果。 通过元素的id名称来获取：document.getElementById(&lt;id名称&gt;); 通过元素的标签名称来获取：document.getElementsByTagName(&lt;标签名称&gt;); 通过元素的name属性名称来获取：document.getElementsByName(&lt;name属性名称&gt;); 通过元素的class名称来获取：document.getElementsByClassName(&lt;class名称&gt;); 注意:除了id以外，其他的都是类数组，可以用下标来表示某个元素。 例如：获取链接和输入框。 1234&lt;a id=\"food\" class=\"myfood\" href=\"#1\"&gt;香蕉&lt;/a&gt;&lt;a class=\"myfood\" href=\"#2\"&gt;苹果&lt;/a&gt;&lt;a class=\"myfood\" href=\"#3\"&gt;葡萄&lt;/a&gt;&lt;input type=\"text\" name=\"username\"&gt; 12345678910111213141516171819//通过idvar banana = document.getElementById('food');console.log(banana); // &lt;a id=\"food\" class=\"myfood\" href=\"#1\"&gt;香蕉&lt;/a&gt;//通过标签名称var links = document.getElementsByTagName('a');console.log(links); // HTMLCollection(4) [a.attr, a#food.myfood, a.myfood, a.myfood, food: a#food.myfood]// 通过name属性名称var username = document.getElementsByName('username');console.log(username); // NodeList [input]// 通过class名称var myfood = document.getElementsByClassName('myfood');console.log(myfood); // HTMLCollection(3) [a#food.myfood, a.myfood, a.myfood, food: a#food.myfood]// 获取类数组的第一个var myfoodOne = document.getElementsByClassName('myfood')[0];console.log(myfoodOne); // &lt;a id=\"food\" class=\"myfood\" href=\"#1\"&gt;香蕉&lt;/a&gt; 创建元素这个就是用document的方法来创建一个标签元素或者一个文本元素。 方法就是： 标签元素：document.createElement(&#39;&lt;元素名称&gt;&#39;); 文本元素：document.createTextNode(&#39;&lt;文本内容&gt;&#39;); 例如：创建一个a标签，还有一个内容为你好，元素的文本。 1234567// 创建链接元素var linka = document.createElement('a');console.log('linka:',linka); // linka: &lt;a&gt;​&lt;/a&gt;​// 创建打招呼文本var txta = document.createTextNode('你好，元素');console.log('txta:',txta); // txta: \"你好，元素\" 添加元素这个就是把一个元素或者文本添加到另一个元素的内容里面去。 用法：&lt;另一个元素&gt;.appendChild(&lt;要添加的元素&gt;)。 例如：把一个文本添加到一个链接中。 123456789// 创建链接元素var linka = document.createElement('a');// 创建打招呼文本var txta = document.createTextNode('你好，元素');//添加元素linka.appendChild(txta);console.log('linka:',linka); // linka: &lt;a&gt;​你好，元素​&lt;/a&gt;​ 修改元素修改元素的属性可以使用上面讲到的属性操作方法，这里主要讲修改元素的内容。 修改元素的内容有以下几种方法： 往元素里面添加新的文本内容：&lt;要修改的元素&gt;.innerText = &#39;&lt;新的内容&gt;&#39;; 往元素里面添加新的html元素和内容：&lt;要修改的元素&gt;.innerHTML = &#39;&lt;新的内容&gt;&#39; 注意：它们两个的区别就是innerText只是修改元素的内容文本，相当于创建了一个文本节点，然后添加到这个元素中，改变的只有元素的内容；而innerHTML,不仅修改元素的内容文本，还可以添加嵌套的元素和元素自己的属性和内容，相当于创建了一个元素和文本节点，并且赋予元素属性和属性值，然后添加到这个要修改的元素中。 例如:修改段落标签的内容，往段落标签里面添加一个链接，链接的class叫linka,href属性值叫#1,内容叫我是新链接。 12&lt;p id=\"con\"&gt;&lt;/p&gt;&lt;a id=\"linkb\" href=\"#1\"&gt;&lt;/a&gt; 12345678//只添加文本var linkb = document.getElementById('linkb');linkb.innerText = '你好，我的朋友！';console.log(linkb); // &lt;a id=\"linkb\" href=\"#1\"&gt;你好，我的朋友！&lt;/a&gt;//添加元素和文本var con = document.getElementById('con');con.innerHTML = '&lt;a class=\"linka\" href=\"#1\"&gt;我是新链接&lt;/a&gt;';console.log(con); // &lt;p id=\"con\"&gt;&lt;a class=\"linka\" href=\"#1\"&gt;我是新链接&lt;/a&gt;&lt;/p&gt; 其实也可以使用上面的方法来实现，不过比较麻烦一点。 1234567var con = document.getElementById('con');var linkb = document.createElement('a');linkb.setAttribute('href','#1');linkb.setAttribute('class','linka');var txtb = document.createTextNode('我是新链接');linkb.appendChild(txtb);con.appendChild(linkb); 插入元素插入元素就是把一个子元素插入到父元素中，方法就是&lt;父元素&gt;.insertBefore(&lt;子元素&gt;,&lt;插入子元素的位置&gt;)。 例如：往一个列表中插入一个子元素。 12345&lt;ul id=\"list\"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt; 1234567var list = document.getElementById('list');var lia = document.createElement('li');var txtc = document.createTextNode('葡萄');var lastElem = list.lastElementChild;lia.appendChild(txtc);list.insertBefore(lia,lastElem);console.log(list); // &lt;ul id=\"list\"&gt;&lt;li&gt;苹果&lt;/li&gt;&lt;li&gt;香蕉&lt;/li&gt;&lt;li&gt;葡萄&lt;/li&gt;&lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt; 替换元素替换元素就是把当前元素的子元素给替换成另外一个子元素，方法就是&lt;父元素&gt;.removeChild(&lt;要替换的子元素&gt;)。 例如：从列表中把苹果替换成葡萄。 12345&lt;ul id=\"list\"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt; 1234567var list = document.getElementById('list');var apple = list.firstElementChild;var putao = document.createElement('li');var txta = document.createTextNode('葡萄');putao.appendChild(txta);list.replaceChild(putao,apple);console.log(list); // &lt;ul id=\"list\"&gt;&lt;li&gt;葡萄&lt;/li&gt;&lt;li&gt;香蕉&lt;/li&gt;&lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt; 克隆元素克隆元素其实就是复制一个元素，分为以下两种： 深克隆，又叫深拷贝。就是既克隆元素本身，又克隆元素的子节点和节点的内容。 浅克隆，又叫浅拷贝。只是克隆节点本身，不包括节点的内容。 方法就是：&lt;要克隆的节点&gt;.cloneNode(&lt;deep: boolean&gt;),这个参数是接收一个布尔值，true就是深拷贝，false就是浅拷贝。 例如：克隆一个苹果。 12345&lt;ul id=\"list\"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt; 1234567891011var list = document.getElementById('list');var apple = list.firstElementChild;//浅拷贝var appleOne = apple.cloneNode(false);list.appendChild(appleOne);console.log(list); //&lt;ul id=\"list\"&gt;&lt;li&gt;苹果&lt;/li&gt;&lt;li&gt;香蕉&lt;/li&gt;&lt;li&gt;梨子&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;//深拷贝var appleOne = apple.cloneNode(true);list.appendChild(appleOne);console.log(list); //&lt;ul id=\"list\"&gt;&lt;li&gt;苹果&lt;/li&gt;&lt;li&gt;香蕉&lt;/li&gt;&lt;li&gt;梨子&lt;/li&gt;&lt;li&gt;苹果&lt;/li&gt;&lt;/ul&gt; 删除元素删除元素就是把一个子元素从到父元素中删去，方法就是&lt;父元素&gt;.removeChild(&lt;要删除的子元素&gt;)。 例如：从列表中删除最后一个子元素。 12345&lt;ul id=\"list\"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt; 1234var list = document.getElementById('list');var lastElem = list.lastElementChild;list.removeChild(lastElem);console.log(list); // &lt;ul id=\"list\"&gt;&lt;li&gt;苹果&lt;/li&gt;&lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt; 温馨提示:上面这些操作可以写成函数封装起来，日后使用比较方便了。 比如说获取元素是经常用到的，就写一个函数就可以了。 1234567891011121314151617181920212223242526//获取元素function getElem(name) &#123; var result; var $d = document; if (name.indexOf('#') != -1) &#123; name = name.split('#')[1]; result = $d.getElementById(name); &#125; else if (name.indexOf('.') != -1) &#123; name = name.split('.')[1]; result = $d.getElementsByClassName(name); &#125; else if (name.indexOf('%') != -1) &#123; name = name.split('%')[1]; result = $d.getElementsByTagName(name); &#125; else if (name.indexOf('&amp;') != -1) &#123; name = name.split('&amp;')[1]; result = $d.getElementsByName(name); &#125; return result;&#125;//例如：获取p标签var w1 = getElem('#con');var w2 = getElem('.cons');var w3 = getElem('%p');//获取输入框var w4 = getElem('&amp;user'); 12&lt;p id=\"con\" class=\"cons\"&gt;CSS样式脚本化的内容&lt;/p&gt;&lt;input type=\"text\" name=\"user\"&gt; CSSDOMCSSDOM就是DOM对于CSS样式进行脚本化，可以很轻松的创建动态的html文档，之前因为这个原因还出现了DHTML，文档不再是静态的文本和媒体等内容了，而是可以动态的获取和操作。 CSSDOM的操作有以下几种： Document对象的styleSheets来表示； 通过style这个属性来控制元素的样式变化的， 通过className可以给元素添加类名。 styleSheets[]数组通过Document对象引用的CSSStyleSheet对象属性和方法。可以用这个document.styleSheets[]就可以获取到所有的样式。 如果这个文档中引用了3个样式表，那么就会返回这3个样式表所定义的样式规则内容。 第一个样式表就可以用这样来表示document.styleSheets[0]。 属性：每个样式表都有以下几个属性 cssRules和rules，这里面记录着每一条规则的内容； disabled，这个属性表示这个样式表是否禁用掉，默认是false； href，这个属性表示这个样式表的url地址； type，这个样式表的类型。 例如： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;CSS样式脚本化&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"jbh.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;CSS样式脚本化&lt;/h2&gt; &lt;p&gt;CSS样式脚本化的内容&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112body &#123; margin: 0; padding: 0;&#125;h2 &#123; color: #f00; font-size: 20px;&#125;p &#123; padding: 5px 10px; color: #eee;&#125; 123456789var allstyle = document.styleSheets[0];var cssRules = allstyle.cssRules;var disabled = allstyle.disabled;var href = allstyle.href;var type = allstyle.type;console.log('规则：',cssRules); // CSSRuleList &#123;0: CSSStyleRule, 1: CSSStyleRule, 2: CSSStyleRule, length: 3&#125;console.log('是否禁用：',disabled); // falseconsole.log('url地址：',href); // url地址： http://localhost:2009/day/jbh.cssconsole.log('类型：',type); // 类型： text/css style属性控制这个就是通过html的style标签来控制元素的样式，适用于内联样式和内嵌样式。优先级比外部样式表要大，就是可以把外部样式表的样式给覆盖掉。 注意：这个style只是可以获取和改变文档内部的样式规则，对于外链的样式表，无法获取和改变样式的属性。 提示： 例如：给一个链接加上颜色和大小。 1&lt;p&gt;CSS样式脚本化的内容&lt;/p&gt; 123var con = document.getElementById('con');con.style.color = '#f00';con.style.fontSize = '20px'; className这个className就是给元素直接添加类名。只要文档内部或者外链样式表有这个类名的css规则就可以加上去。 用法：&lt;要加类名的元素&gt;.className=&quot;&lt;类名&gt;&quot;。 例如：给一个段落加一个类名。 1&lt;p&gt;给我加类名吧！&lt;/p&gt; 12345.con &#123; padding: 5px 10px; height: 300px; color: #eee;&#125; 123var con = document.getElementsByTagName('p')[0];con.className = 'con';console.log(con); // &lt;p class=\"con\"&gt;给我加类名吧！&lt;/p&gt; classList这个classList就是给元素直接添加多个类名。 用法：&lt;要加类名的元素&gt;.classList=&quot;&lt;类名1 类名2 类名3 ...&gt;&quot;，类名之间要空格。 例如：给一个段落加一个类名。 1&lt;p&gt;给我加多个类名吧！&lt;/p&gt; 123456789.con &#123; padding: 5px 10px;&#125;.con1 &#123; height: 300px;&#125;.con2 &#123; color: #eee;&#125; 123var con = document.getElementsByTagName('p')[0];con.classList = 'con con1 con2';console.log(con); // &lt;p class=\"con con1 con2\"&gt;给我加类名吧！&lt;/p&gt; DOM标准支持表由于游览器的各处林立，导致制定的标准在每个游览器的支持都不一样，下面这个表是有关如何查询游览器支持哪些DOM标准的。 Document对象的implementation引用了DOMImplementation对象，定义了一个方法用来查询是否支持。 方法用法：hasFeature(name,version);里面包含两个参数，第一个是你要查询的标准名称，你要查询的DOM级别。 在这里我封装了一个方法，可以用来查询，如果返回true说明支持，反之则不支持。 123456789101112function searchDomSupport(name,version) &#123; if (document.implementation &amp;&amp; document.implementation.hasFeature &amp;&amp; document.implementation.hasFeature(name,version) ) &#123; return true; &#125; else &#123; return false; &#125;&#125;var res = searchDomSupport('html','1.0');console.log(res); // true; 附表： 序号 特性名称 版本 说明 暗示 1 HTML 1.0 1级的Core和HTML接口 无 2 XML 1.0 1级的Core和XML接口 无 3 Core 2.0 2级的Core接口 无 4 HTML 2.0 2级的HTML接口 Core 5 XML 2.0 2级的XML专有接口 Core 6 Views 2.0 AbstractView接口 Core 7 StyleSheets 2.0 通用样式表遍历 Core 8 CSS 2.0 CSS样式 Core,Views 9 CSS2 2.0 CSS2Properties接口 CSS 10 Events 2.0 事件处理基础结构 Core 11 UIEvents 2.0 用户接口事件(Events+ Views) Events,Views 12 MouseEvents 2.0 Mouse事件 UIEvents 13 HTMLEvents 2.0 HTML事件 Events 提示：有时候这个方法可能不是太准确，兼容性不是很好。 这里提供两个网站，上面有着各个游览器的的兼容性的处理方法。 Peter Paul Koch的著名站点： quirksmode 这个站点提供了作者DOM和CSS标准对于游览器兼容性的进行广泛研究后的成果。 David Hammond的：webdevout 优缺点一个对象的出现，既有优点，又有缺点，不过缺点大于优点。 优点 易用性强 把文档信息都存于内存中，遍历简单方便 缺点 解析速度慢，占内存过高，非常大的文件就不适合操作； 在DOM运行的过程中，创建和修改、删除了大量的对象，机制不健全，导致效率低下，消耗了大量的时间 DOM有风险，使用需谨慎。切记，切记。 写在最后因为DOM在不断的发展，内容规则和标准在不断的扩展。所以今天讲的是0级和1级DOM的有关知识点。因为内容太多，所以有关2级DOM的内容放在以后来说。其实上面的内容已经非常多了，需要慢慢的去使用。实践出真知，理论联系实践，相信你自己一定可以成功的。","categories":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/tags/js/"},{"name":"js基础","slug":"js基础","permalink":"https://guanqi.xyz/tags/js基础/"},{"name":"DOM","slug":"DOM","permalink":"https://guanqi.xyz/tags/DOM/"}]},{"title":"js之BOM的概念和方法","slug":"js-bom-use","date":"2019-01-25T07:35:21.000Z","updated":"2019-03-08T03:28:46.311Z","comments":true,"path":"2019-01-25/js-bom-use/","link":"","permalink":"https://guanqi.xyz/2019-01-25/js-bom-use/","excerpt":"","text":"今天开始介绍一篇有关BOM知识点的总结文章。 BOM顾名思义，就是游览器对象模型，英文是Browser Object Model的简称。这个套模型定义了JavaScript如何操作游览器窗口以及获取游览器本身的一些信息，包括窗口的各种高度和宽度，滚动高度和宽度，历史纪录，url的相关信息，游览器的相关信息等知识。 Window对象在游览器中，javascript的Window对象就等同于全局对象，并且在该全局对象下定义的属性和方法也就等同于Window对象的属性和方法。 例如：一个变量和一个函数 1234var i=10;console.log(window.i) // 10;function fn() &#123; console.log('fn'); &#125;console.log(window.fn) // ƒ fn() &#123; console.log('fn'); &#125; Window对象自身有很多的属性和方法，以下是几种Window对象中常用的属性和方法。这些方法由于是Window对象下面的方法，所以可以省略不写。 窗口信息这个有些方法ie是document.documentElement.方法，谷歌火狐是document.body.方法。 外边框的宽高用法：宽，window.outerWidth；高window.outerHeight。 例如： 1console.log('外边框的宽高:'+window.outerWidth+'*'+window.outerHeight); // 外边框的宽高:1536*824 内边框的宽高用法：宽，window.innerWidth；高window.innerHeight。 例如： 1console.log('内边框的宽高:'+window.innerWidth+'*'+window.innerHeight); // 内边框的宽高:1164*723 可视窗口的宽高用法：宽，document.documentElement.clientWidth；高document.documentElement.clientHeight。 例如： 1console.log('可视窗口的宽高:'+document.documentElement.clientWidth+'*'+document.documentElement.clientHeight); // 可视窗口的宽高:1164*723 滚动窗口的坐标用法：宽，window.scrollX；高window.scrollY。 例如： 1console.log('滚动窗口的坐标:'+window.scrollX+'*'+window.scrollY); // 滚动窗口的坐标:0*0 滚动窗口的左上用法：左，document.documentElement.scrollLeft；上document.documentElement.scrollTop。 例如： 1console.log('滚动窗口的左上:'+document.documentElement.scrollLeft+'*'+document.documentElement.scrollTop); // 滚动窗口的左上:0*0 元素的宽高左右用法： 左：document.documentElement.offsetLeft； 上：document.documentElement.offsetTop， 宽：document.documentElement.offsetWidth， 高：document.documentElement.offsetHeight。 例如： 1&lt;div class=\"box\" style=\"margin:10px;width:100px;height:100px;\"&gt;盒子&lt;/div&gt; 123var box = document.querySelector('.box');console.log('元素距离距离窗口的宽高:'+box.offsetWidth+'*'+box.offsetHeight); // 元素距离距离窗口的宽高:100*100console.log('元素距离距离窗口的左右:'+box.offsetLeft+'*'+box.offsetTop); // 元素距离距离窗口的左右:18*106 屏幕信息这个是Screen对象的有关属性，Window对象的screen属性就是引用的Screen对象。 显示器的大小用法：宽window.screen.width，高window.screen.height。 例如： 1console.log('显示器的大小:'+window.screen.width+'*'+window.screen.height); // 显示器的大小:1536*864 实际可用的显示大小用法：宽window.screen.availWidth，高window.screen.availHeight。 例如： 1console.log('实际可用的显示大小:'+window.screen.availWidth+'*'+window.screen.availHeight); // 实际可用的显示大小:1536*824 屏幕第一个可用位置的坐标用法：宽window.screen.availLeft，高window.screen.availTop。 例如： 1console.log('屏幕第一个可用位置的坐标:'+window.screen.availLeft+'*'+window.screen.availTop); // 屏幕第一个可用位置的坐标:0*0 对话框对话框就是你可以对它进行操作，但是用户体验稍微差点，所以后来慢慢的，这个对话框就变成了程序完成后调试bug的作用了。 对话框还有一点就是，它阻塞了游览器解析进程，你需要对当前对话框进行操作完成后才能进行下一项渲染，或者是看见了页面内容，或者是开始其他操作。 alert()这个方法就是一个简单的对话框，里面接受一个字符作为显示在游览器窗口的内容。向用户显示信息并且需要用户手动关闭。 用法：window.alert(&lt;内容&gt;);，这个方法是Window对象下面的方法，所以可以省略不写。 这样也可以执行的alert(&lt;内容&gt;);。 例如：window.alert(&#39;欢迎光临本网站！&#39;); confirm()这个方法就是一个简单的对话框，里面需要输入内容，有两个按钮，一个是确定，另一个是取消。它的返回值是布尔值，当你点击确定，会返回true；当你点击取消，会返回false。 用法：confirm(&lt;内容&gt;); 例如： 12var res = confirm('你过年回家吗？');console.log(res ? '我回家' : '我不回家'); // 点击确定：我回家；点击取消： 我不回家 prompt()这个方法就是一个简单的对话框，里面需要输入一个字符串，有两个按钮，一个是确定，另一个是取消。它的返回值是你输入框中的内容，当你点击确定，会返回输入框的内容；当你点击取消，会返回null。 用法：prompt(&lt;字符串&gt;); 例如： 12var res = prompt('你喜欢吃什么小吃？'); // 你可以输入任何字符串，例如我输入了沙县小吃console.log(res); // 点击确定：沙县小吃；点击取消： null 定时器定时器是web客户端里面定义的一个全局方法，核心的JavaScript并没有定义这个方法。 定时器的功能就是在未来某个时间进行某段代码的执行，可以有一次的或者多次的执行。 注意：setTimeout只执行一次，setInterval可以一直连续的执行。 setTimeout()这个方法就是用来使一个函数在指定的时间内（单位是毫秒ms）过去之后执行。这个有时候被拿来模拟ajax异步操作。 用法：setTimeout(fn,time);,第一个参数就是一个函数或者函数的名称，第二个参数就是时间。 例如：一秒后打印我爱你 123456789//1.函数名称setTimeout(fn,1000);function fn() &#123; console.log('我爱你'); // 我爱你&#125;//2.函数setTimeout(function()&#123; console.log('我爱你'); // 我爱你&#125;,1000); clearTimeout()这个方法可以取消setTimeout方法中第一个参数函数的执行。 用法：clearTimeout(函数名称);，参数是setTimeout方法中第一个参数的函数名称。 例如： 1234var fn = setTimeout(function()&#123; console.log('我爱你');&#125;,3000);clearTimeout(fn); setInterval()这个方法就是用来使一个函数在指定的时间内（单位是毫秒ms）重复的调用执行。这个有时候被拿来做模拟时钟或者动画。 用法：setInterval(fn,time);,第一个参数就是一个函数或者函数的名称，第二个参数就是时间。 例如：把当前时间显示在游览器窗口中，并且时间是动态走动。 1&lt;div id=\"time\"&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334//1.函数名称var time = document.querySelector('#time');var timer = setInterval(fn,1000);function fn() &#123; var now = new Date(); var year = now.getFullYear(); var month = now.getMonth() + 1; var day = now.getDay(); var hour = now.getHours(); var minute = now.getMinutes(); var second = now.getSeconds(); month = month &gt;= 10 ? month : '0' + month; day = day &gt;= 10 ? day : '0' + day; hour = hour &gt;= 10 ? hour : '0' + hour; minute = minute &gt;= 10 ? minute : '0' + minute; second = second &gt;= 10 ? second : '0' + second; time.innerHTML = year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second;&#125;//2.函数var timer = setInterval(function()&#123; var now = new Date(); var year = now.getFullYear(); var month = now.getMonth() + 1; var day = now.getDay(); var hour = now.getHours(); var minute = now.getMinutes(); var second = now.getSeconds(); month = month &gt;= 10 ? month : '0' + month; day = day &gt;= 10 ? day : '0' + day; hour = hour &gt;= 10 ? hour : '0' + hour; minute = minute &gt;= 10 ? minute : '0' + minute; second = second &gt;= 10 ? second : '0' + second; time.innerHTML = year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second;&#125;,1000); clearInterval()这个方法可以取消setInterval方法中第一个参数函数的执行，停止重复调用这个函数。 用法：clearInterval(函数名称);，参数是setInterval方法中第一个参数的函数名称。 例如：要取消上面那个例子的时钟走动。 1clearInterval(timer); 打开和关闭新窗口这个可以打开或者关闭一个新窗口，但是随着时代经济的发展，越来越多的网站把它用于投放展示广告，导致很多游览器封杀了这两个方法，除非是用户自己点击新窗口。 open()这个方法是可以打开一个新的窗口。 用法：open(一参,二参,三参,四参);，以下是参数说明： 第一参数是你要打开新窗口的url； 第二个参数是你要打开新窗口的名称，可以是a标签的target属性中的值，也可以自定义； 第三个参数是新窗口的一些属性定义，比如说状态了，宽和高，也没有菜单栏等； 第四个参数是是否覆盖掉当前的页面历史纪录，如果是true，那就覆盖掉，否则就新增一条历史记录。 例如：打开一个宽高为300*400的，显示状态栏的，内容为你好，世界，不覆盖当前url的历史纪录的一个新窗口。 12345678910111213&lt;!-- 保存为new.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;新窗口&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;你好，世界&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 1234function openNew() &#123; window.open('new.html','width=200,height=200,status=yes',false);&#125;openNew(); close()这个方法是关闭当前的窗口网页。 用法：close(); 例如： 1234function closeWin() &#123; window.close();&#125;closeWin(); Location对象这个Location对象提供了当前文档的url的一些信息，包括协议，域名，端口号，url参数等信息。 窗口的location属性引用的是Location对象。它代表当前文档的url信息。 location的属性用法：window.location，属性包括： protocol 网页通信协议； host 网页域名（包括域名和端口）； hostname 网页域名名字（）； port 端口号 href 网页地址 hash 哈希值 search 参数内容（包括?号） 123456789101112131415161718console.log('url信息：',window.location); /* url信息：Location &#123; ancestorOrigins: DOMStringList &#123;length: 0&#125; assign: ƒ () hash: \"\" host: \"localhost:2009\" hostname: \"localhost\" href: \"http://localhost:2009/test.html\" origin: \"http://localhost:2009\" pathname: \"test.html\" port: \"2009\" protocol: \"http:\" reload: ƒ reload() replace: ƒ () search: \"\" toString: ƒ toString()*/ location的方法 reload();重新载入当前网页 location或者location.href; 载入新的网页url replace(); 重新载入当前网页（会覆盖掉当前网页的历史纪录） 例如： 1234567//1.重新载入当前网页window.location.reload();//2.载入新的网页urlwindow.location = 'test.html';window.location.href = 'test.html';//3.重新载入当前网页（会覆盖掉当前网页的历史纪录）window.location.replace(); 案例：解析url的参数12345678910111213141516var url = 'http://www.abc.com/index?name=keke&amp;type=1';function getUrlArgs() &#123; var args = new Object(); var query = location.search.substring(1); var pairs = query.split('&amp;'); for(var i=0;i&lt;pairs.length;i++) &#123; var pos = pairs[i].indexOf('='); if (pos == -1) &#123; continue; &#125; var argname = pairs[i].substring(0,pos); var value = pairs[i].substring(pos+1); value = decodeURIComponent(value); args[argname] = value; &#125; return args;&#125;console.log(getUrlArgs()); // &#123; name: \"keke\", type: \"1\" &#125; History对象这个History对象可以允许载入新的文档或者游览器后退或者前进游览过的文档。 窗口的history属性引用的是History对象。 forward()这个方法可以使游览器载入到新文档，和游览器的前进箭头按钮功能一样。 用法：forward();，不需要传参。 例如： 1234function forwardTo() &#123; history.forward();&#125;forwardTo(); back()这个方法可以使游览器后退到以前游览过的网页，和游览器的后退箭头按钮功能一样。 用法：back();，不需要传参。 例如： 1234function backTo() &#123; history.back();&#125;backTo(); go()这个方法可以使游览器前进或者后退到以前游览过的网页。 用法：go();，需要传参，正参就是前进几个历史纪录，负参就是后退几个历史纪录。 例如： 12345function goTo(val) &#123; history.go(val);&#125;goTo(1);goTo(-1); Navigation对象这个Navigation对象可以储存的当前游览器的信息，包括版本号，app名称，游览器内核名称，系统版本等。 Window对象的navigator属性引用的是Navigation对象。 打印查看当前游览器信息直接执行console.log(window.navigator)就可以了。 常用的属性 appName，游览器的简称； appVersion，游览器的内部版本号； appCodeName，游览器的代码名称； platform，运行游览器的硬件平台； userAgent，用户代理，游览器在它的USER-AGENT HTTP头部发送字符串。 例如：打印当前游览器的信息 1234567891011121314151617181920function getnNavigatorInfo() &#123; var obj = new Object(); var proArr = ['appName','appVersion','appCodeName','platform','userAgent']; for (var key in navigator) &#123; for(var i=0;i&lt;proArr.length;i++) &#123; if (key == proArr[i]) &#123; obj[key] = navigator[key]; &#125; &#125; &#125; return obj;&#125;console.log(getnNavigatorInfo());/*appCodeName: \"Mozilla\"appName: \"Netscape\"appVersion: \"5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\"platform: \"Win32\"userAgent: \"Mozilla/5.0 (Windows NT 10.0; ...*/ 案例：检测游览器检测游览器名称1234567891011121314function checkBrowserName () &#123; if (navigator.userAgent.indexOf('Chrome') != -1) &#123; console.log('这是谷歌游览器'); &#125; else if (navigator.userAgent.indexOf('Trident') != -1 || navigator.appVersion.indexOf('MSIE') != -1 ) &#123; console.log('这是ie游览器'); &#125; else if (navigator.userAgent.indexOf('Firefox') != -1) &#123; console.log('这是火狐游览器'); &#125; else if (navigator.userAgent.indexOf('Opera') != -1) &#123; console.log('这是Opera游览器'); &#125; else if (navigator.userAgent.indexOf('Safari') != -1) &#123; console.log('这是Safari游览器'); &#125;&#125;checkBrowserName(); 检测ie游览器版本123456789101112131415161718192021function checkIeVersion () &#123; var ie = navigator.userAgent.indexOf('Trident') == -1 ? false : true; var version = navigator.appVersion; console.log(version); var versionName = ''; if (ie &amp;&amp; version) &#123; if (version.indexOf('rv:11.0') != -1) &#123; versionName = 'ie11' &#125; else if (version.indexOf('MSIE 10.0') != -1) &#123; versionName = 'ie10' &#125; else if (version.indexOf('MSIE 9.0') != -1) &#123; versionName = 'ie9' &#125; else if (version.indexOf('MSIE 8.0') != -1) &#123; versionName = 'ie8' &#125; else if (version.indexOf('MSIE 7.0') != -1) &#123; versionName = 'ie7' &#125; &#125; return versionName;&#125;console.log(checkIeVersion()); 写在最后这期的BOM知识分享就结束了，希望可以用起来，细细体会这其中的神奇奥秘。","categories":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/tags/js/"},{"name":"js基础","slug":"js基础","permalink":"https://guanqi.xyz/tags/js基础/"},{"name":"BOM","slug":"BOM","permalink":"https://guanqi.xyz/tags/BOM/"}]},{"title":"js常用方法集合","slug":"js-some-example","date":"2019-01-24T10:16:21.000Z","updated":"2019-03-08T03:26:04.967Z","comments":true,"path":"2019-01-24/js-some-example/","link":"","permalink":"https://guanqi.xyz/2019-01-24/js-some-example/","excerpt":"","text":"今天来说一下js中经常用到的去重，排序等方法。 求多维数组的和1234567891011121314151617var total = 0; //初始值function getArrSum(arr) &#123; if ((arr instanceof Array) || (arr &amp;&amp; typeof arr == 'object' &amp;&amp; 'length' in arr)) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; if (!arr[i]) &#123; continue; &#125; if (typeof arr[i] == 'number') &#123; total += arr[i]; &#125;else if ((arr[i] instanceof Array) || (arr[i] &amp;&amp; typeof arr[i] == 'object' &amp;&amp; 'length' in arr[i])) &#123; getArrSum(arr[i]); &#125; &#125; &#125; else &#123; throw new Error('getArrSum():arr must be array!'); &#125;&#125; 实例： 123var arr = [1,[123],[45,[6,7,8]]];getArrSum(arr);console.log(total); //result is 190 返回参数中的最大值12345678910function max() &#123; var m = Number.NEGATIVE_INFINITY; for (let i = 0; i &lt; arguments.length; i++) &#123; const element = arguments[i]; if (element &gt; m) &#123; m = arguments[i]; &#125; &#125; return m;&#125; 实例： 12var large = max(10,20,1111,1212);console.log(large); // result is 1212; 检测参数类型求和123456789101112131415161718// 参数类型function getSum(a) &#123; if ((a instanceof Array) || (a &amp;&amp; typeof a == 'Object' &amp;&amp; 'length' in a)) &#123; var total = 0; for (let i = 0; i &lt; a.length; i++) &#123; let element = a[i]; if (!element) &#123; continue; &#125; if (typeof element == 'number') &#123; total += element; &#125; else &#123; throw new Error(\"sum():all array elements must be an number!\"); &#125; &#125; return total; &#125; else &#123; throw new Error(\"sum():argument must be an array!\"); &#125;&#125; 实例： 123456var res1 = getSum([123,12,15,21,54]);var res2 = getSum(121);var res3 = getSum([12,31,'121']);console.log(res1); // result is 225;console.log(res2); // result is Uncaught Error: sum():argument must be an array!;console.log(res3); // result is Uncaught Error: sum():all array elements must be an number! 返回阶乘1234567// 返回阶乘var stratum = function (num) &#123; if (num &lt;= 1) &#123; return 1; &#125; return num*arguments.callee(num-1);&#125; 实例： 1console.log(stratum(5)); // result is 120 数组排序123456789101112131415161718192021//数组元素为数字的排序（升序）function sortArrayUp(a,b) &#123; return b - a;&#125;//数组元素为数字排序（升序）function sortArrayDown(a,b) &#123; return a - b;&#125;//数组元素为对象排序function sortObject(protoname,type) &#123; // 如果type是up，是升序，否则为降序 return function (a,b) &#123; if (type == 'up') &#123; return b[protoname] - a[protoname]; &#125; else &#123; return a[protoname] - b[protoname]; &#125; &#125;&#125; 实例： 12345678910111213141516171819202122232425262728var arr = [12,13,234,121,1212,334,212,520,125];var resa = arr.sort(sortArrayUp);var resb = arr.sort(sortArrayDown);console.log(resa); //result is [1212, 520, 334, 234, 212, 125, 121, 13, 12];console.log(resb); //result is [12, 13, 121, 125, 212, 234, 334, 520, 1212];var arrb = [ &#123;num: 12,name: 'orange'&#125;, &#123;num: 112,name: 'banana'&#125;, &#123;num: 42,name: 'apple'&#125;, &#123;num: 31,name: 'orange'&#125;]var resc = arrb.sort(sortObject('num','up'));var resd = arrb.sort(sortObject('num','down'));console.log(resc); /* result is&#123;num: 112,name: 'banana'&#125;,&#123;num: 42,name: 'apple'&#125;,&#123;num: 31,name: 'orange'&#125;,&#123;num: 12,name: 'orange'&#125;*/console.log(resd); /* result is&#123;num: 12,name: 'orange'&#125;,&#123;num: 31,name: 'orange'&#125;,&#123;num: 42,name: 'apple'&#125;, &#123;num: 112,name: 'banana'&#125;*/ 数组去重123456789101112131415161718192021222324252627282930313233// 数组去重function arrayRemoveRepeat(arr,type,name) &#123; var arr = arr; //数组 var type = type; //类型，数组元素为对象，传'object',否则传'number' var name = name || ''; // 数组元素为对象，是对象的属性判断值； if ((arr instanceof Array) || (typeof arr == 'Object' &amp;&amp; 'length' in arr)) &#123; var newArr = []; var len = arr.length; for (let i = 0; i &lt; len; i++) &#123; if (!arr[i]) &#123; continue; &#125; if (type == 'object') &#123; if (typeof arr[i] == 'object') &#123; if (newArr.indexOf(arr[i][name]) == -1) &#123; newArr.push(arr[i][name]); &#125; &#125; else &#123; throw new Error(\"arrayRemoveRepeat():all element must be an object!\"); &#125; &#125; else if (type == 'number') &#123; if (typeof arr[i] == 'number') &#123; if (newArr.indexOf(arr[i]) == -1) &#123; newArr.push(arr[i]); &#125; &#125; else &#123; throw new Error(\"arrayRemoveRepeat():all element must be an number!\"); &#125; &#125; &#125; return newArr; &#125; else &#123; throw new Error(\"arrayRemoveRepeat():argument must be an array!\"); &#125;&#125; 实例： 123456789// 对象情况下:var arr31 = [&#123;num: 12&#125;,&#123;num: 12&#125;,&#123;num: 1&#125;,&#123;num: 13&#125;,&#123;num: 13&#125;,&#123;num: 13&#125;];var arr32 = arrayRemoveRepeat(arr31,'object','num');console.log(arr32); // result is [12, 1, 13];// 数字情况下：var arr22 = [12,12,11,212,1243,2321,11,1,123,261];var arr32 = arrayRemoveRepeat(arr22,'number','');console.log(arr32); // result is [12, 11, 212, 1243, 2321, 1, 123, 261]; 检测函数参数是否为制定个数1234567891011function sum(x,y,z) &#123; var sum = 0; if (arguments.length != 3) &#123; throw new Error('必须是三个参数！'); &#125; for (let i = 0; i &lt; arguments.length; i++) &#123; const element = arguments[i]; sum += element; &#125; return sum;&#125; 实例： 1234var res = sum(1,2,3);var res1 = sum(1,3);console.log(res); // result is 6;console.log(res1); // result is Uncaught Error: 必须是三个参数！ 写在最后上面就是我在日常使用中总结到的一些常用方法技巧。","categories":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/tags/js/"},{"name":"js方法","slug":"js方法","permalink":"https://guanqi.xyz/tags/js方法/"}]},{"title":"js中正则表达式使用方法","slug":"js-regexp-use","date":"2019-01-24T06:16:21.000Z","updated":"2019-03-08T03:26:43.176Z","comments":true,"path":"2019-01-24/js-regexp-use/","link":"","permalink":"https://guanqi.xyz/2019-01-24/js-regexp-use/","excerpt":"","text":"今天说一下有关js中正则表达式的一些知识点。正则表达式主要是在表单输入验证，以及一些文本字符处理中特表好用。 正则表达式的概念正则表达式是一个描述字符模式的对象，最早是诞生于Perl语言中，JavaScript继承了Perl语言的正则表达式的一些特性，方法和概念。在JavaScript中，有一个类RegExp表示正则表达式，而且String和RegExp都有对应的模式匹配和文本检索、替换的函数。 创建正则表达式创建正则表达式可以使用两种方法，这是js对象一以贯之的方法，就是new实例化一个对象，或者直接写正则表达式。 new运算符创建通过new运算符来实例化一个RegExp对象。 语法表达：new RegExp(code is here); 例如：创建一个验证数字的正则表达式。 1234//注意：这里使用test()方法来检测是否符合var numReg = new RegExp('a');var num = 'a123';console.log(numReg.test(num)); // true; 直接量创建直接量就是直接赋值，创建一个表达式。这个看着更加简洁好用，非常灵活。 例如：还是上面那个例子。 123var numReg = /a/;var num = 'a123';console.log(numReg.test(num)); // true; 正则表达式的匹配规则字符类之前都是直接写正则表达式，例如/abc/,只是匹配任意一个符合abc的字符，而如果想要匹配多个字符，就可以使用字符类来实现。 字符类是使用方括号[]，中间可以随意写一些匹配规则。 例如：我们要检测文本中是否包含0-9中的任意数字，就可以使用字符类。这里我们使用直接量比较方便。 12345var numReg = /[0-9]/;var num = 'a123';var str = 'hello';console.log(numReg.test(num)); // true;console.log(numReg.test(str)); // false; 补充：其他字符类 序号 字符 说明 1 […] 括号内的任意字符 2 [^…] 不再括号内的任意字符 3 .] 除换行符和Unicode行终止符之外的任意字符 4 \\w 任何ASCII(注释1)单字字符，等于[a-zA-Z0-9_] 5 \\W 任何非ASCII(注释1)单字字符，等于[^a-zA-Z0-9_] 6 \\s 任何Unicode空白符 7 \\S 任何非Unicode空白符的字符 8 \\d 任何ASCII数字，等于[0-9] 9 \\D 任何非ASCII数字，等于[^0-9] 10 [\\b] 退格直接量(特殊) 注释1：ASCII指的是美国信息交换标准代码。 以上就是一些字符类的说明，下面使用几个练习一下。 例如：一个检测是否包含数字、字母和下划线以及非空白符的正则表达式。 123var patten = /\\w\\s/;var str = 'abc 123';console.log(patten.test(str)); // true 避免重复定义上面的字符类，只能匹配单个，如果我们要匹配多个符合的字符，不能一直重复写吧，像这样/\\d\\d\\d/,那这样就不高效了。 为了解决上面的烦恼，正则表达式用一些方法来表示这种情况，下面是一些列表。 序号 字符 说明 1 {n,m} 表示匹配前一项至少n次，不能超过m次 2 {n,} 表示匹配前一项n次，或者更多次 3 {n} 表示匹配前一项正好n次 4 ? 表示匹配前一项0次或者1次，等于{0,1} 5 + 表示匹配前一项1次或者多次，等于{1,} 6 * 表示匹配前一项0次或者多次，等于{0,} 举个例子：匹配2到4位数字。 123var numReg = /\\d&#123;2,4&#125;/;var num = '123';console.log(numReg.test(num)); // true; 用于选择的字符正则表达式中有用于选择的字符|。这个是从左到右进行匹配，一旦左边符合就返回结果。 例如:匹配是带有ab或者cd或者ef的正则表达式。 123var numReg = /ab|cd|ef/;var num = 'ab123';console.log(numReg.test(num)); // true; 用于分组的字符正则表达式中有用于分组的字符()。 知识点：正则中括号的含义 把单独的项目组合成子表达式，例如：/java(script)?/匹配的是字符串java,后面可以有script，也可以没有。 在完整的模式中定义子模式,例如：/[a-z]+(\\d+)/,匹配的是尾部是否是数字。 例如:匹配是带有ab或者cd或者ef的正则表达式。 123var numReg = /ab|cd|ef/;var num = 'ab123';console.log(numReg.test(num)); // true; 用于引用的字符括号()也可以表示引用，允许在同一个正则表达式中的后面部分引用前面的子表达式。 例如：开始和结束的引号相匹配。\\1引用的是第一个带括号的子表达式。 12var quoat = /(['\"])[^'\"]*\\1/;console.log(quoat.test('1\"2\"3')); // true 补充：正则表达式的选择、分组和引用字符 序号 字符 说明 1 竖杠 选择，匹配的是该符号左边或者右边的子表达式 2 (…) 分组，组合，将一个项目组合成一个独立的单元，还可以供后面的引用使用 3 (?:…) 只组合，把项目组合到一个单元，但是不记与该组匹配的字符 4 \\n 和第n个分组第一次匹配的字符相匹配 匹配指定的位置先来看一个列表，里面罗列了需要用到的锚字符。 序号 字符 说明 1 ^ 匹配字符串的开头；如果是匹配多行，那就是匹配一行的开头 2 $ 匹配字符串的结尾；如果是匹配多行，那就是匹配一行的结尾 3 \\b 匹配一个词语的边界，例如在\\w和\\W之间的位置，注意：\\b是退格符 4 \\B 匹配一个非词语的边界 5 (?=p) 正前向声明，要求接下来的字符都有和模式p匹配，但是不包括匹配中的那些字符 6 (?!p) 反前向声明，要求接下来的字符都不和模式p匹配 例如：匹配一个用户名，以字母开头，数字结尾的正则表达式。 123var nameReg = /^[a-zA-Z]\\d$/;var name = 'a1';console.log(111,nameReg.test(name)); // true; 标志正则表达式的标志说明了高级模式里面匹配的规则。和上面的正则表达式的语法不同的是标志出现在/符合之外说明的，位于第二个\\之后。 正则表达式中的标志列表 序号 字符 说明 1 g 模式匹配应该是全局的，应该找出被检索字符串所有的匹配。 2 i 模式匹配应该是不区分大小写的匹配。 3 m 多行模式，^匹配一行的开头和字符串的开头，$匹配一行的结尾和字符串的结尾 例如：匹配全局的a 123var patten = /a/g;var str = 'an apple';console.log(patten.test(str)); // true String模式匹配的方法search()方法这个方法的参数是正则表达式，返回一个与之匹配的子串的位置；如果找不到就返回-1，如果参数不是正则表达式，会转换成正则表达式进行匹配。 注意：该方法不支持全局检索，只要找到便会返回结果。 例如：匹配一个查找a的位置的正则表达式。 123var patten = /a/i;var str = 'apple';console.log(str.search(patten)); // 0 replace()方法这个方法的第一个参数是正则表达式，第二个参数是要替换的字符串，也可以是一个函数。用于把匹配到的字符串替换成别的内容。 例如：把小写字母a替换成大写字母*。 123var patten = /a/g;var str = 'apple';console.log(str.replace(patten,\"*\")); // *pple match()方法这个是比较常用的String正则表达式方法，参数只有一个就是正则表达式。把匹配到的内容以数组的形式返回。 例如：解析一个url地址 123var urlReg = /(\\w+):\\/\\/([\\w.]+)\\/(\\S*)\\/(\\d*)/;var text = 'http://www.abc.com/post/1';console.log(text.match(urlReg)); // [\"http://www.abc.com/post/1\", \"http\", \"www.abc.com\", \"post\", \"1\", index: 0, input: \"http://www.abc.com/post/1\", groups: undefined] split()方法这个也是比较常用的String正则表达式方法，参数只有一个就是正则表达式或者一个字符。把字符串分解为一个子串数组，使用的分隔符就是它的参数。 例如： 12345var patten = /\\s/;var num = '123,456,789';var num1 = '123 456 789';console.log(num.split(',')); // [\"123\", \"456\", \"789\"]console.log(num1.split(patten)); // [\"123\", \"456\", \"789\"] RegExp对象的属性和方法Javascript中的正则表达式是用RegExp对象来表示的，除了构造函数RegExp()，这个对象可以接受两个参数，一个是正则表达式的字符串，另一个是正则表达式的标志。 例如：new RegExp(&quot;\\\\d{2}&quot;,&quot;g&quot;); RegExp对象的属性每个RegExp对象都有五个属性。包括以下： source是一个只读字符串，存放的是正则表达式的文本。 global是一个只读的布尔值，是否具有标志g ignoreCase是一个只读的布尔值，是否具有标志i multiline是一个只读的布尔值，是否具有标志m lastIndex是一个可读写的整数。对于具有标志g的模式，这个属性存储在字符串中下一次可以检索的位置，由方法exec()和test()使用 exec()方法该方法是对于一个指定的字符串进行匹配，把匹配到的内容返回一个的数组。 例如： 123var patten = /a/i;var str = 'apple';console.log(patten.exec(str)); // [\"a\", index: 0, input: \"apple\", groups: undefined] test()方法该方法和exec()方法类似，但是不只限于字符串，其他字符也支持；而且它返回的是一个布尔值，表示是否符合正则表达式的匹配规则。 123var patten = /a/i;var str = 'apple';console.log(patten.test(str)); // true 案例### 检验用户名为中文的 /^[\\u4e00-\\u9fa5]{0,}$/ 检验密码强度/^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$/ 密码的强度必须是包含大小写字母和数字的组合不能使用特殊字符,长度在8-10之间 检测电子邮箱地址/[\\\\w!#$%&amp;&#39;*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;’+/=?^_`{|}~-]+)@(?:\\w?\\.)+\\w?/` 检测手机号的/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\\\d{8}$/ 检测身份证的15位的:/^[1-9]\\\\d{7}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}$/ 18位的:/^[1-9]\\\\d{5}[1-9]\\\\d{3}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}([0-9]|X)$/ 检验金额的精确到2位小数。 /^[0-9]+(.[0-9]{2})?$/ 判断ie版本/^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$/ 校验IP-v4地址/\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b/ 提取url链接/^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&amp;=]*)?/ 写在最后这个JavaScript中的正则表达式RegExp对象就讲到到这里，内容还是挺多的，需要慢慢吸收转化，可以多几个例子练习。","categories":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/tags/js/"},{"name":"js基础","slug":"js基础","permalink":"https://guanqi.xyz/tags/js基础/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://guanqi.xyz/tags/正则表达式/"}]},{"title":"js获取url地址的参数的方法","slug":"js-url-params","date":"2019-01-23T13:36:21.000Z","updated":"2019-03-08T03:26:14.935Z","comments":true,"path":"2019-01-23/js-url-params/","link":"","permalink":"https://guanqi.xyz/2019-01-23/js-url-params/","excerpt":"","text":"今天说一下如何获取url参数值。 思路 通过location的search就可以获取到url中问号后面的值。 字符串过滤到问号 通过split方法分割参数集合 循环赋值 匹配对应的参数值 返回值 封装的方法1234567891011121314151617181920212223242526272829function getUrlParams(name) &#123; // 不传name返回所有值，否则返回对应值 var url = window.location.search; if (url.indexOf('?') == 1) &#123; return false; &#125; url = url.substr(1); url = url.split('&amp;'); var name = name || ''; var nameres; // 获取全部参数及其值 for(var i=0;i&lt;url.length;i++) &#123; var info = url[i].split('='); var obj = &#123;&#125;; obj[info[0]] = decodeURI(info[1]); url[i] = obj; &#125; // 如果传入一个参数名称，就匹配其值 if (name) &#123; for(var i=0;i&lt;url.length;i++) &#123; for (const key in url[i]) &#123; if (key == name) &#123; nameres = url[i][key]; &#125; &#125; &#125; &#125; else &#123; nameres = url; &#125; // 返回结果 return nameres;&#125; 实例例如： 12345const url = 'http://www.abc.com/test.php?id=1&amp;from=index';var res = getUrlParams();var res1 = getUrlParams('id');console.log(res); // [&#123;id: \"1\"&#125;, &#123;from: \"index\"&#125;]console.log(res1); // 1 写在最后这是一个比较简单的方法。","categories":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/tags/js/"},{"name":"js方法","slug":"js方法","permalink":"https://guanqi.xyz/tags/js方法/"},{"name":"url","slug":"url","permalink":"https://guanqi.xyz/tags/url/"}]},{"title":"es6之const命令","slug":"es6-const","date":"2019-01-23T13:31:21.000Z","updated":"2019-01-23T13:18:51.546Z","comments":true,"path":"2019-01-23/es6-const/","link":"","permalink":"https://guanqi.xyz/2019-01-23/es6-const/","excerpt":"","text":"hi,我又回来了，今天学习一下const命令。 声明一个常量const声明一个只读常量，一旦声明，常量的值便不可改变。 例子如下： 12const food = 12;food = 23; // Uncaught TypeError: Assignment to constant variable. 还可以声明一个变量const可以声明一个变量，声明以后，必须初始化，否则变错。 例子如下： 1const food; // Uncaught SyntaxError: Missing initializer in const declaration 其他特性const和let有许多相似点： 只在其声明的块级作用域中有效； 不存在作用域提升，是暂时性死区，必须先声明，后使用； 不能重复声明，否则会报错 例子如下： 1234567891011121314151617//1.只在其声明的块级作用域中有效&#123; const food = 'apple';&#125;console.log(food); // Uncaught ReferenceError: food is not defined//2.暂时性死区&#123; console.log(HI); // Uncaught ReferenceError: HI is not defined const HI = 'hello';&#125;//3.不能重复声明&#123; const food = 'apple'; const food = 'orange'; // Uncaught SyntaxError: Identifier 'food' has already been declared&#125; const的声明变量的本质const声明的变量，并不是说变量的值不能改变，而是对于变量指向那个的内存地址所保存的数据不得改动。 如果声明的变量是基本数据，那值就保存在变量指向的那个内存地址，可以理解为对于常量。 但是如果声明的变量是一个引用数据类型，那只能保证变量保存的指针地址不变，至于变量里面的属性和值，就不能保证了。 注意：如果把这个声明的引用数据类型变量指向另一个对象，就会报错。 例如： 12345678910111213// 常量是一个对象const About = &#123;&#125;;About.us = 'usb';About.ua = 'usc';console.log(About); // &#123;us: \"usb\", ua: \"usc\"&#125;About = &#123;&#125;; // Uncaught TypeError: Assignment to constant variable.//常量是一个数组const BALL = [];BALL.length = 2;BALL[0] = 'haha';BALL = []; // Uncaught TypeError: Assignment to constant variable. 补充：声明变量的方法 ES5的var和function命令。 ES6的let和const命令。 最后总结其实，const也不是很难，只要你细心，就会发现非常的简单。","categories":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/tags/es6/"},{"name":"const","slug":"const","permalink":"https://guanqi.xyz/tags/const/"}]},{"title":"es6之块级作用域","slug":"es6-block","date":"2019-01-23T13:30:21.000Z","updated":"2019-01-23T13:16:19.050Z","comments":true,"path":"2019-01-23/es6-block/","link":"","permalink":"https://guanqi.xyz/2019-01-23/es6-block/","excerpt":"","text":"今天，来探讨一下ES6中的块级作用域。 全局作用域和函数作用域在ES5中，只全局作用域和函数作用域。这会导致函数作用域覆盖了全局作用域；亦或者循环中的变量泄露为全局变量。 例如： 123456789101112131415// 1.函数作用域覆盖了全局作用域,发生了变量提升，函数声明大于var声明的变量，因此函数里面的a提到了前面，在打印a，初始化一个undefined给a,所以打印出了undefined。var a = '1';function fn() &#123; console.log(a); if (3&lt;2) &#123; var a = 3; &#125;&#125;fn(); // undefined// 2.循环中的变量泄露为全局变量for(var i=0;i&lt;5;i++) &#123; console.log(i);&#125;console.log(i); // 5; ES6的块级作用域用let命令新增了块级作用域，外层作用域无法获取到内层作用域，非常安全明了。即使外层和内层都使用相同变量名，也都互不干扰。 1234567891011121314151617181920212223242526272829303132333435// 1.外层作用域无法获取到内层作用域function fn1() &#123; let a = 41; if(1 == 1) &#123; let a = 3; console.log(2,a); // 2 3 &#125; console.log(1,a); // 1 41&#125;fn1();&#123; &#123; let food = 'apple'; &#125; console.log(food); // Uncaught ReferenceError: food is not defined&#125;&#123; &#123; let food = 'apple'; &#125; console.log(food); // Uncaught ReferenceError: food is not defined&#125;// 2. 外层和内层都使用相同变量名，也都互不干扰&#123; &#123; let food = 'apple'; console.log(food); // apple &#125; let food = 'orange'; console.log(food); // orange&#125; 块级作用域和和函数声明在ES5中，函数只能在顶级作用域和函数作用域中声明，不能在块级作用域中声明。但是在ES6中，函数可以在块级作用域中声明。 但是会有一定的问题，因为函数声明会被提到代码的最前面。所以会报错，最好在ES6中用函数表达式来表示一个函数。 例如： 123456789101112131415161718//1.函数声明报错&#123; if (4 &lt; 2) &#123; function fn() &#123; console.log('我在函数里面！'); &#125; &#125;&#125;fn(); // Uncaught TypeError: fn is not a function//2.函数表达式没错&#123; let fa = '111'; let fn = function () &#123; console.log('我在函数里面！'); &#125; console.log(fa,fn); // 111 ƒ () &#123; console.log('我在函数里面！');&#125;&#125; 注意：ES6中允许函数在块级作用域中可以声明的条件是必须在大括号里面，否则就会报错。 12345678// 1.报错的情况if (4&gt;2) &#123; let fn = function () &#123;&#125;;&#125;//2.报错的情况if (4&gt;2) let fn = function () &#123;&#125;; // Uncaught SyntaxError: Lexical declaration cannot appear in a single-statement context 最后总结今天就将这些，下次再会。期待再更新。","categories":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/tags/es6/"},{"name":"块级作用域","slug":"块级作用域","permalink":"https://guanqi.xyz/tags/块级作用域/"}]},{"title":"es6之set数据结构","slug":"es6-set","date":"2019-01-22T10:30:21.000Z","updated":"2019-03-08T03:18:46.945Z","comments":true,"path":"2019-01-22/es6-set/","link":"","permalink":"https://guanqi.xyz/2019-01-22/es6-set/","excerpt":"","text":"学习setset是ES6中的新增的数据结构，是一种构造函数，类似于数组，但是里面的元素都是唯一的，不重复的。 例如： 12345const set = new Set();[1,2,3,4,5,2,1,2,1,2].forEach( x =&gt; set.add(x) );for(let i of set) &#123; console.log(i); // 1 2 3 4 5&#125; set的属性set的属性包括constructor（set原型）和size（用来记录set的大小）。 用法：Set.prototype.constructor,Set.prototype.size。 例如： 123let set = new Set([1,2,3,2,2,2,1,2,34,4,45,523]);console.log(set.constructor); // ƒ Set() &#123; [native code] &#125;console.log(set.size); // 7 set的方法set的操作方法 add(val); 添加某个值 delete(val); // 删除某个值，返回布尔值，表示结果。 has(val); // 判断该值是否存在于Set中。 clear(); // 清楚所有的值 例如： 123456789101112let set = new Set();//1.add();set.add(12).add(32);console.log(set); // Set(2) &#123;12, 32&#125;// 2.delete(val);set.delete(32);console.log(set); // Set(1) &#123;12&#125;//3.has(val);console.log(set.has(88)); // false//4.clear();set.clear();console.log(set); // Set(0) &#123;&#125; set的遍历方法set的键和值是同一个值。 keys() 返回键名的方法 values() 返回键值的方法 entries() 返回键值对的方法 forEach() 用回调函数遍历各个元素的方法 例如： 123456789101112131415let set = new Set([2,2,2,1,5,34,45,33,23,32]);for(let item of set.keys()) &#123; console.log(item); // // 2 1 5 34 45 33 23 32&#125;for(let item of set.values()) &#123; console.log(item); // // 2 1 5 34 45 33 23 32&#125;for(let item of set.entries()) &#123; console.log(item); // [2, 2] [1, 1] [5, 5] [34, 34] [45, 45] [33, 33] [23, 23] [32, 32]&#125;set.forEach((value,key) =&gt; console.log(key+ '=' +value)); // 2=2 1=1 5=5 34=34 45=45 33=33 23=23 32=32 应用...运算符和Array.from以及map和filter都可以遍历set结构。 ...运算符例如： 12let set = new Set('123456654321');console.log([...set]); // [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"] ...和数组加起来可以去重 例如： 123let arr = [1,2,3,4,6,3,3,1,3,4];let removeRepeat = [...new Set(arr)];console.log(removeRepeat); //[1, 2, 3, 4, 6] map方法例如： 12let set = new Set([1,2,3,4]);console.log(new Set([...set].map(x =&gt; x*2))); // &#123;2, 4, 6, 8&#125; filter方法例如： 12let set = new Set([1,2,3,4]);console.log(new Set([...set].filter(x =&gt; x%2 === 0))); // &#123;2, 4&#125; Array.from例如： 12let set = new Set([1,2,3,4]);console.log(new Set(Array.from(set, x =&gt; x*2))); // &#123;2, 4, 6, 8&#125; 小案例使用这个set可以实现数学中的交集，并集效果。 例如： 12345678let a = new Set([1,2,3]);let b = new Set([3,4,5]);let numa = new Set([...a,...b]);console.log(numa); // &#123;1, 2, 3, 4, 5&#125;//并集let numb = new Set([...a].filter(x =&gt; b.has(x)));console.log(numb); // &#123;3&#125; 学习WeakSetWeakSet和Set类似，也是没有重复的值。注意的是，它里面的成员只能是对象，其他数据类型不接受。 例如： 123456let ws = new WeakSet(1); // Uncaught TypeError: number 1 is not iterable (cannot read property Symbol(Symbol.iterator))let wsa = new WeakSet('1'); // Uncaught TypeError: Invalid value used in weak setlet wsb = new WeakSet(&#123;x:1&#125;); // Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))let wsc = new WeakSet([1,3]); // Uncaught TypeError: Invalid value used in weak setlet wsc = new WeakSet([[1,2],[3,4]]);console.log(wsc); // WeakSet &#123;Array(2), Array(2)&#125; 结论：从上面的例子中，可以看出1.WeakSet构造函数的参数不接受字符串，数字，普通对象，数组（数组中的参数必须是对象）；接受数组（数组中的参数是对象的数组）。 WeakSet的方法 WeakSet.prototype.add(val)添加一个值; WeakSet.prototype.delete(val)删除一个值; WeakSet.prototype.has(val)是否有这个值; 例如： 1234567891011let wset = new WeakSet([[1,3,4],[23,4,52,2]]);//1.添加值wset.add([12,33,23]);console.log(wset); // WeakSet &#123;Array(3), Array(4), Array(3)&#125;//2.删除值wset.delete([12,33,23]);console.log(wset); // WeakSet &#123;Array(4), Array(3)&#125;//3.是否有这个值console.log(wset.has([12,33,23])); // false WeakSet的属性由于WeakSet中的值都是弱属性，随时可能消失，被垃圾回收，遍历机制无法保证值是否还存在，所以不能用size和forEach()。 例如： 12345let wset = new WeakSet([[1,3,4],[23,4,52,2]]);console.log(wset.size); // undefinedfor(let i=0;i&lt;wset.length;i++) &#123; console.log(wset[i]);&#125; 写在最后Set和WeakSet就介绍到这里，赶快用起来吧！","categories":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/tags/es6/"},{"name":"set","slug":"set","permalink":"https://guanqi.xyz/tags/set/"}]},{"title":"es6之let命令","slug":"es6-let","date":"2019-01-19T09:30:21.000Z","updated":"2019-01-19T09:43:28.003Z","comments":true,"path":"2019-01-19/es6-let/","link":"","permalink":"https://guanqi.xyz/2019-01-19/es6-let/","excerpt":"","text":"let let命令的用法let是es6中的声明一个变量的命令，只在它声明的代码块中有效，出了这个代码块就会报错。也非常适合for循环，在循环中i的值只在循环语句中生效，在外边取不到的。 var命令声明的是一个全局的变量，i是指向全局的变量，只会输出最后的值。而let只在循环语句块里面生效，每次循环都会重新声明一个i的，所以每次循环都能拿到对应的值。 for循环的变量是父作用域，和在循环体内let定义的变量（子作用域）不在同一个作用域。 例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//1.在自身所在代码块中有效&#123; let a = 1; var b = 2;&#125;console.log(b); // 2console.log(a); // a is not defined//2.在for循环语句块中有效for(var i=0;i&lt;10;i++) &#123; //...&#125;console.log(i); // 10for(let j=0;j&lt;10;j++) &#123; //...&#125;console.log(j); // j is not definedvar arr = [];for(var a=0;a&lt;10;a++) &#123; arr[a] = function () &#123; console.log(a); &#125;&#125;console.log(a[4]); // 10for(let b=0;b&lt;10;b++) &#123; arr[b] = function () &#123; console.log(b); &#125;&#125;console.log(b[4]); // 4// 3.for循环的变量和循环体内的变量for(var i=0;i&lt;10;i++) &#123; let i = 'fed'; console.log(i);&#125;/** 结果是* fed* fed* fed*/ let命令不存在作用域提升var命令是会发生作用域提升的，在声明之前，是undefined,未声明便有默认值了。而let定义的变量必须在声明后使用。 12345console.log(fa); // undefinedvar fa = 1;console.log(fb); // fb is not definedlet fb = 2; let存在暂时性死区“暂时性死区”（temporal dead zone，简称 TDZ）是指在ES6的规定中，如果区块中存在let和const命令的，这两个命令声明的变量就已经形成了封闭作用域。在此之前声明的变量，都会报错。 例如：下面声明了一个全局变量，但是在块级作用域中let又声明了一个变量。 12345678var food = 'apple';if(typeof 'str' == 'string') &#123; food = 'banana'; // Uncaught ReferenceError: food is not defined let food; console.log(food); // undefined food = 'orange'; console.log(food); // orange&#125; 注意：暂时性四区会有一些不好的地方。 typeof检测不安全 12typeof x; // Uncaught ReferenceError: x is not definedlet x; 不允许重复声明简而言之，就是不允许在同一作用域内，声明两个一样的变量。 例如： 123456789&#123; let a = 1; var a = 2; // Uncaught SyntaxError: Identifier 'a' has already been declared&#125;// 或者&#123; let b = 1; let b = 2; // Uncaught SyntaxError: Identifier 'b' has already been declared&#125; 注意：不能在函数参数内重复声明参数，否则报错。 12345function wait(x,y) &#123; let x = 1; // Uncaught SyntaxError: Identifier 'x' has already been declared let y = 2; // Uncaught SyntaxError: Identifier 'y' has already been declared&#125;wait(3,5); 顶层对象在ES6之前，顶级对象的属性和全局变量是一致的，所以导致出现很多问题。 只有运行开才能捕捉到错误，没法一开始就检测出错误。 顶层对象是随时随地可以读取和写入的，所以不利于模块化编程。 window其实指的是游览器窗口，顶层对象有一个实体含义。 所以es6改进了一点，就是let，const声明的全局变量不属于顶层对象的属性。 例如： 1234var a = 1;let b = 2;console.log(window.a); // 1console.log(window.b); // undefined 学以致用let命令古语有云：学了就用处处行，不学不用等于零。所以我写了一个关于let的小例子。 这是一个选项卡的案例，在之前，我们还要定义btns[i].index = i,而现在用let命令就方便多了。 12345678910111213141516171819202122232425262728293031.tab &#123; width: 300px; height: 30px; border: 1px solid #fff;&#125;.tab &gt; span &#123; float: left; display: block; width: 98px; height: 28px; line-height: 28px; text-align: center; border: 1px solid #aaa; cursor: pointer;&#125;span.active &#123; color: #fff; background-color: #f00; border: 1px solid #f00;&#125;.content, .content &gt; p &#123; width: 300px; height: 300px;&#125;.content &gt; p &#123; display: none; border: 1px solid #aaa;&#125;p.active &#123; display: block;&#125; 12345678910&lt;div class=\"tab\"&gt; &lt;span class=\"active\"&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=\"content\"&gt; &lt;p class=\"active\"&gt;1的内容&lt;/p&gt; &lt;p&gt;2的内容&lt;/p&gt; &lt;p&gt;3的内容&lt;/p&gt;&lt;/div&gt; 123456789101112let btns = document.querySelectorAll('.tab span');let contents = document.querySelectorAll('.content p');for (let i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function() &#123; for (let j = 0; j &lt; btns.length; j++) &#123; btns[j].className = ''; contents[j].className = ''; &#125; this.className = 'active'; contents[i].className = 'active'; &#125;&#125; 写在最后上面就是一些介绍如何正确的使用let命令，在实践中用起来吧。","categories":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/tags/es6/"},{"name":"let","slug":"let","permalink":"https://guanqi.xyz/tags/let/"}]},{"title":"ajax技术详解","slug":"ajax-detail","date":"2019-01-18T13:16:21.000Z","updated":"2019-03-08T02:35:49.471Z","comments":true,"path":"2019-01-18/ajax-detail/","link":"","permalink":"https://guanqi.xyz/2019-01-18/ajax-detail/","excerpt":"","text":"今天来讲一下ajax的有关知识点。 ajax概念ajax全称叫Asynchronous JavaScript and XML,意思是异步的 JavaScript 和 XML。 ajax是现有标准的一种新方法，不是编程语言，可以在不刷新网页的情况下，和服务器交换数据并且更新部分页面内容，不需要任何插件，只需要游览器允许运行JavaScript就可以。 而传统的网页（不使用ajax的）如果需要更新页面内容，就需要重新请求服务器，返回网页内容，重新渲染刷新页面。 ajax的原理原理：ajax的运行过程包括以下几个方面 Browser游览器通过事件触发方法，本地通过XMLHttpRequest对象，创建并且发送请求通过互联网到服务器； Server服务器收到请求的内容，响应请求，发送所需数据到游览器； Browser游览器通过XMLHttpRequest对象的onreadystatechange的方法收到请求的数据后，解析和渲染数据到页面中。 注意：ajax依赖的标准有以下几个 XMLHttpRequest对象,异步的与服务器交换数据 JavaScript/DOM,信息显示/交互 XML,作为转换数据的格式 XMLHttpRequest的使用创建XMLHttpRequest对象，通过new实例化一个XMLHttpRequest对象。 1var xhr = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP'); // 兼容ie和Firefox，google chrome,opera,safari 发送请求使用XMLHttpRequest对象的open和send方法 open方法使用open(method,url,async),接受三个参数。 第一个是method请求的类型，如：get和post; 第二个是url请求地址，即文件在服务器的位置； 第三个是是否处理异步处理请求,值为true和false； 例如： 1xhr.open('get','https://www.abc.com/service.php?tamp='+Date.parse(new Date()),true); send方法使用send(string)接受的参数为请求类型为post传递的值，为get类型时候不传值。 例如： 1send('tamp='+Date.parse(new Date()); onreadystatechange事件当readyState属性发生变化时，就会触发onreadystatechange事件，该事件通过回调函数获取到响应的数据信息。 readyState值: 值为0表示：请求未初始化； 值为1表示：服务器连接已建立； 值为2表示：请求已接收； 值为3表示：请求处理中； 值为4表示:请求已完成，且响应已就绪； status值： 200: 请求成功 404: 未找到页面 简单的get请求。12345678910111213var xhr;if (!xhr &amp;&amp; typeof xhr !== 'object') &#123; var xhr = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP');&#125;xhr.open('get','https://www.abc.com/service.php?tamp='+Date.parse(new Date()),true);xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; console.log(xhr.responseText); &#125; &#125;&#125;xhr.send(); 模拟数据模拟的JSON数据123456789101112131415161718192021// 保存为data.json文件&#123; \"msg\": \"get_succ\", \"code\": 201, \"data\": &#123; \"list\": [ &#123; \"id\":1, \"name\": \"alun\" &#125;, &#123; \"id\":2, \"name\": \"mark\" &#125;, &#123; \"id\":3, \"name\": \"jean\" &#125; ] &#125;&#125; 模拟的Nodejs的api 请确保你的系统安装有node.js环境。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 保存为node.js文件// 引入http模块const http = require('http');const port = 3000;const success = &#123; msg: \"get_succ\", code: 201, data: &#123; list: [ &#123;\"id\":1,\"name\": \"alun\"&#125;, &#123;\"id\":2,\"name\": \"mark\"&#125;, &#123;\"id\":3,\"name\": \"jean\"&#125; ] &#125;&#125;const error = &#123; msg: \"get_fail\", code: 101, data: &#123; info: 'this request failed,again try!' &#125;&#125;const authy = &#123; msg: \"no visited!\", code: 403, data: &#123; info: 'not visited!' &#125;&#125;// 建立http服务const serve = http.createServer((req,res) =&gt; &#123; var lawDomainList = \"http://localhost:9925\"; res.setHeader('Content-Type', 'text/plain;charset=utf8'); res.setHeader(\"Access-Control-Allow-Origin\",lawDomainList); if (req.url == '/api') &#123; res.end(JSON.stringify(success)); &#125; else &#123; res.end(JSON.stringify(error)); &#125; res.end(authy);&#125;)// 监听端口serve.listen(port,function()&#123; console.log('serve is running on port 3000!');&#125;) 封装的ajax函数1234567891011121314151617181920212223242526272829303132333435363738394041// 保存为ajax.js文件$g = &#123; get: function(url) &#123; return new Promise(function(resolve,reject) &#123; if (!url &amp;&amp; !(typeof url == 'string')) &#123; throw new Error('SysantaxError: this get request must had url!'); &#125; var xhr = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP'); xhr.open('GET',url,true); xhr.onreadystatechange = function() &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(this.responseText,this); &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send(); &#125;) &#125;, post: function(url,data) &#123; return new Promise(function(resolve,reject) &#123; if (!url) &#123; throw new Error('SysantaxError: this post request must had url!'); &#125; if (!data) &#123; throw new Error('SysantaxError: this post request must had data!'); &#125; var xhr = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP'); xhr.open('POST',url,true); xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); xhr.onreadystatechange = function() &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(this.responseText,this); &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send(JSON.stringify(data)); &#125;) &#125;&#125; 示例：获取数据渲染页面 通过点击按钮获取数据，渲染列表。 123&lt;button class=\"btn\"&gt;请求数据&lt;/button&gt;&lt;ul class=\"res\"&gt;结果：暂无结果&lt;/ul&gt;&lt;script src=\"ajax.js\"&gt;&lt;/script&gt; 123456789101112131415161718192021let btn = document.querySelector('.btn');let resbox = document.querySelector('.res');btn.onclick = function() &#123; var url = 'http://localhost:3000/api'; // node api var urlJson = 'data.json'; // mock api $g.get(url).then(function(res) &#123; if (typeof res == 'string') &#123; let responTxt = JSON.parse(res); if (responTxt.msg == 'get_succ' &amp;&amp; responTxt.code == 201) &#123; let list = responTxt.data.list; let str = ''; for (let i=0;i&lt;list.length;i++) &#123; str += '&lt;li&gt;'+ list[i].id + ':' + list[i].name + '&lt;/li&gt;'; &#125; resbox.innerHTML = str; &#125; &#125; &#125;).catch(function(err)&#123; throw new Error(err); &#125;);&#125; 写在最后这只是我总结的一小部分知识点，其实这个技术还是有很多地方没有说到，以后再补充吧！","categories":[{"name":"ajax","slug":"ajax","permalink":"https://guanqi.xyz/categories/ajax/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://guanqi.xyz/tags/ajax/"},{"name":"js","slug":"js","permalink":"https://guanqi.xyz/tags/js/"}]},{"title":"前端小项目汇总","slug":"front-project-list","date":"2019-01-16T13:30:21.000Z","updated":"2019-03-08T03:00:48.599Z","comments":true,"path":"2019-01-16/front-project-list/","link":"","permalink":"https://guanqi.xyz/2019-01-16/front-project-list/","excerpt":"","text":"之前我做了许多的小项目，包括当当网pc、哔哩哔哩h5，豆瓣网h5,更多内容请访问 https://gitguanqi.github.io/fedemo/#projects 查看。 当当网pc 当当网pc 当当网是初学前端时候做的一个案例，这个案例包括登录，注册，首页，二级页，详情页，购物车页面这几个部分。 你可以先注册，然后登录，到首页看看，二级页看看，再到详情页添加商品到购物车（有待完善），最后在购物车结算。 建议在电脑上游览，点击这里预览一下效果吧！ 哔哩哔哩h5 哔哩哔哩h5 当当网是初学前端时候做的一个案例，这个案例包括登录，注册，首页，二级页，详情页，搜索页页面这几个部分。 你可以看频道内容，也可以看排行榜，还可以登录，注册（完善中），也可以看详情页视频。 建议在手机上游览，点击这里预览一下效果吧！ 豆瓣网h5 豆瓣网h5 豆瓣网是初学前端时候做的一个案例，这个案例包括首页，二级页，详情页，搜索页页面这几个部分。 建议在手机上游览，点击这里预览一下效果吧!","categories":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/categories/前端案例/"}],"tags":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/tags/前端案例/"},{"name":"项目汇总","slug":"项目汇总","permalink":"https://guanqi.xyz/tags/项目汇总/"}]},{"title":"js中对象详解","slug":"js-object-use","date":"2019-01-16T13:16:21.000Z","updated":"2019-03-08T03:26:59.080Z","comments":true,"path":"2019-01-16/js-object-use/","link":"","permalink":"https://guanqi.xyz/2019-01-16/js-object-use/","excerpt":"","text":"今天说一下有关对象操作方法的文章。 什么是对象？在js中数据类型分为两类，一个是基本数据类型，另一个是引用数据类型。基本数据类型包括文本字符串string、布尔boolean、数字number、未定义nudefined、空值null,而引用数据类型就是对象，包括普通的Object、数组Array、函数function、日期Date、正则表达式RegExp、字符串对象String、数字对象Number、布尔对象Boolean。今天要说的就是Object,普通的对象。 你可以把它当成一种无序的属性的集合，每个属性都有自己的名字和值，这个值可以是数组，也可以是对象，其他的也可以。 创建对象创建对象有很多种方法，今天介绍常见的几种方法。 直接量创建例如：12345var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;; 使用new运算符创建例如:1var obj = new Object(); 对象的属性对象有很多的的属性和属性的值，属性用.来表示。在.左边的是要访问其属性的对象的引用名，它不能是字符串或者是表达式；在.右边的是属性名。 定义一个对象直接量定义简单方便，直接在一个花括号里面写属性和值，属性之间用逗号隔开。 例如：1234567var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;var name = obj.name;console.log(name); // 'guan' 增加一个对象的属性和值直接在对象里面添加属性即可，或者使用.定义一个新的属性值。 例如：直接拿上面的示例。 1234567var obj = &#123; name: 'guan', age: 21, sex: 'man', address: '浙江杭州'&#125;;obj.telephone = '0571-12340001'; 修改一个对象的属性和值使用.可以改变一个新的属性值。 例如：直接拿上面的示例。 123456var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;obj.name = 'mark'; 循环对象的属性和值在js中,使用for/in方法可以遍历对象的属性和属性值。 例如： 123456789var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;for (var key in obj) &#123; console.log(key + '=' + obj[key]); //name=guan age=21 sex=man&#125; 检测对象的属性是否存在用in或者undefined判断，但是in运算符不常用，如果差不多会返回undefined。 12345678910111213141516var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;// 1. 用inif ('name' in obj) &#123; obj.name = 'lee'; //lee&#125;console.log(obj.name); //lee//2.用判断if (obj.name !== undefined) &#123; obj.name = 'lee';&#125;console.log(obj.name); //lee 删除对象的属性和属性值可以用delete运算符删除对象的属性，实际上是彻底从对象中删除这个属性，删除以后for/in方法和in运算符都不会找到该属性，如果打印该属性，会的到一个undefined。 例如： 12345678var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;delete obj.name;console.log(obj.name); //undefined 作为关联数组的对象在js中，数组是一种特殊的对象，所以也可以用对象来关联数组。 以下表示方法是相等的: 12object.propertyobject['property'] 例如： 123456789var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;var name = obj['name'];console.log(obj.name == name); //true Object的属性和方法在js中，所有的对象都继承自Object类，所以它们都有通用的方法和属性。 constructor属性在js中，每一个对象都有一个constructor属性,所以可以根据这个来检测某个数据是否属于对象。 例如：12345678910var arr = [1,2,3];console.log(arr.constructor == Array); //true//还可以这样判断function isArray(arr) &#123; if (typeof arr == 'object' &amp;&amp; arr.constructor == Array) &#123; console.log('arr is array'); &#125;&#125;isArray(arr); //arr is array instanceof运算符instanceof运算符可以检查constructor的值 因此上面可以写成。 例如：12345678910var arr = [1,2,3];console.log(arr instanceof == Array); //true//还可以这样判断function isArray(arr) &#123; if (typeof arr == 'object' &amp;&amp; arr instanceof Array) &#123; console.log('arr is array'); &#125;&#125;isArray(arr); //arr is array toString()方法这个方法没有参数，可以把对象转换为一个字符串。 例如： 123var obj = &#123;x:1,y:1&#125;;var str = obj.toString();console.log(str); // [object Object] toLocaleString()方法这个方法返回对象的一个本地化的字符串。 例如： 123var now = new Date();var str = now.toLocaleString();console.log(str); // 2019/1/16 下午9:45:55 hasOwnProperty()方法这个方法是检测对象的某个属性是否是自身的属性，而不是继承的属性。 例如：12345678var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;console.log(obj.hasOwnProperty('name')); //trueconsole.log(obj.hasOwnProperty('address')); //false valueOf()方法这个方法把对象转化为某个基本数据类型，也就是一个数字，而不是字符串的时候才会调用的方法。 最后总结对象的使用方法就是这些，最常用也是最基本的属性和方法。","categories":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/tags/js/"},{"name":"js基础","slug":"js基础","permalink":"https://guanqi.xyz/tags/js基础/"},{"name":"object","slug":"object","permalink":"https://guanqi.xyz/tags/object/"}]},{"title":"前端案例汇总","slug":"front-case-list","date":"2019-01-16T02:30:21.000Z","updated":"2019-03-08T03:01:02.484Z","comments":true,"path":"2019-01-16/front-case-list/","link":"","permalink":"https://guanqi.xyz/2019-01-16/front-case-list/","excerpt":"","text":"本篇主要是汇总了一些日常开发中做的一些的案例，更多内容请访问 https://gitguanqi.github.io/fedemo/#cases 查看。 小米首页 小米首页 这个demo是关于小米首页的，建议在pc上面查看，大家可以点击这个链接查看。 天猫首页 天猫首页 这个demo是关于天猫首页的，建议在pc上面查看，大家可以点击这个链接查看。 帅康首页 帅康首页 这个demo是关于帅康首页的，建议在pc上面查看，大家可以点击这个链接查看。 58首页 58首页 这个demo是关于58首页的，建议在手机上面查看，大家可以点击这个链接查看。 换肤 换肤 这个demo是关于换肤的，建议在pc上面查看，大家可以点击这个链接查看。 商品放大镜 商品放大镜 这个demo是关于商品放大镜的，建议在pc上面查看，大家可以点击这个链接查看。 时钟canvas 时钟 这个demo是关于时钟的，建议在pc上面查看，大家可以点击这个链接查看。 刮刮卡 刮刮卡 这个demo是关于刮刮卡的，建议在pc上面查看，大家可以点击这个链接查看。 妈妈的礼物 妈妈的礼物 这个demo是关于妈妈的礼物的，建议在pc上面查看，大家可以点击这个链接查看。 骰子 骰子 这个demo是关于骰子的，建议在pc上面查看，大家可以点击这个链接查看。 统计表 统计表 这个demo是关于统计表的，建议在pc上面查看，大家可以点击这个链接查看。 选项卡(tab切换) 选项卡 这个demo是关于选项卡的，建议在pc上面查看，大家可以点击这个链接查看。 banner(轮播图) banner 这个demo是关于banner的，建议在pc上面查看，大家可以点击这个链接查看。","categories":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/categories/前端案例/"}],"tags":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/tags/前端案例/"},{"name":"案例汇总","slug":"案例汇总","permalink":"https://guanqi.xyz/tags/案例汇总/"}]},{"title":"手机上查看pc上的网页","slug":"web-page-on-phone","date":"2019-01-13T09:51:21.000Z","updated":"2019-03-08T02:13:47.038Z","comments":true,"path":"2019-01-13/web-page-on-phone/","link":"","permalink":"https://guanqi.xyz/2019-01-13/web-page-on-phone/","excerpt":"","text":"导语：前两天我在电脑上做了一个h5网页，但是只能在谷歌游览器的模拟设备上面看效果，但是没有办法在真机上测试效果。这两天，我发现了一个非常快捷的方法，可以让你轻轻松松在手机上测试电脑上你做的h5网页效果。 目录 准备工具 连接步骤 写在最后 准备工具 一台电脑 一部手机 一个局域网(wifi) 连接步骤第一步：连接网络手机和电脑同时连接上同一个局域网或者wifi，具体过程我就不演示了，身在互联网应该都是基本常识。 注意：一定要同一个wifi网络，否则无法测试。 第二步：电脑操作 1.打开cmd，输入ipconfig，会出来一下内容。 ipconfig 2.打开游览器，在地址栏输入箭头所指的地址，我的是这个http://192.168.1.104，然后你会看到电脑上显示你刚刚做好的网页。 第三步：手机操作把这个地址可以在你的手机游览器里面输入，你就会看到和电脑同样内容的网页。 写在最后最后你就会成功的看到你的手机游览器上面显示着你做好的页面，是不是很神奇呢。这个解决了困扰大部分开发人员的问题，就是做好h5的网页，不能够在真机上面看到真实的效果，利用这个方法就可以非常完美的检验你的劳动成果了，是不是非常好用。","categories":[{"name":"网页技巧","slug":"网页技巧","permalink":"https://guanqi.xyz/categories/网页技巧/"}],"tags":[{"name":"网页技巧","slug":"网页技巧","permalink":"https://guanqi.xyz/tags/网页技巧/"},{"name":"局域网调试","slug":"局域网调试","permalink":"https://guanqi.xyz/tags/局域网调试/"}]},{"title":"js之数组的操作方法","slug":"js-array-use","date":"2019-01-06T13:16:21.000Z","updated":"2019-03-08T03:28:49.496Z","comments":true,"path":"2019-01-06/js-array-use/","link":"","permalink":"https://guanqi.xyz/2019-01-06/js-array-use/","excerpt":"","text":"今天给大家带来一篇有关数组操作方法的文章。 新建数组 方法一：通过new运算符创建一个数组构造函数。 1var arr = new Array(); 方法二：通过方括号直接创建直接量数组。 1var arr = [1,2,3]; 添加数组中的元素 方法一：通过下标添加元素。 123var arr = new Array();arr[0] = 'kwan';arr[1] = 18; 方法二：通过array的push方法来添加。 说明一点：push是往数组末尾添加新元素。 12345var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;arr.push(4); // result is [5,1,2,3,4]; 方法三：通过array的unshift方法来添加。 说明一点：unshift是网数组最前面添加一个新元素。 12345var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;arr.unshift(4); // result is [4,1,2,3]; 修改数组中的元素通过下标修改元素内容。 1234567var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;//下标修改arr[0] = 4;console.log(arr); // result is [4,2,3]; 删除数组元素内容 方法一：通过array的pop方法来添加。 说明一点：pop是往数组删除末尾元素。 12345var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;arr.pop(); // result is [1,2]; 方法二：通过array的shift方法来添加。 说明一点：shift是网数组删除最前面一个元素。 12345var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;arr.shift(); // result is [2,3]; 合并数组用concat方法来合并另外一个数组。 1234var arr = [1,2,3];var arr1 = [4,5,6];var arr2 = arr.concat(arr1);console.log(arr2); // [1,2,3,4,5,6]; 删除指定数组用splice方法来合并另外一个数组。 注意：splice方法接受两个参数，一个从哪里开始，一个是到哪里结束。 123var arr = [1,2,3];arr.splice(0,1);console.log(arr); // [2,3]; 截取指定数组用slice方法来合并另外一个数组。 注意：slice方法接受两个参数，一个从哪里开始，一个是到哪里结束（但是不包括这个结束的元素本身）。如果是负数，就从倒数第几个。 12var arr = [1,2,3];console.log(arr.slice(0,1);); // [1]; 写在最后今天的数组操作方法就介绍这么多，以后会持续更新的。","categories":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://guanqi.xyz/tags/js/"},{"name":"js方法","slug":"js方法","permalink":"https://guanqi.xyz/tags/js方法/"},{"name":"数组操作","slug":"数组操作","permalink":"https://guanqi.xyz/tags/数组操作/"}]},{"title":"markdown使用笔记","slug":"markdown-use","date":"2018-11-24T06:03:21.000Z","updated":"2019-03-08T02:30:53.421Z","comments":true,"path":"2018-11-24/markdown-use/","link":"","permalink":"https://guanqi.xyz/2018-11-24/markdown-use/","excerpt":"","text":"已经很久没有写过文章了，感觉这个冬天过的非常寒冷，自己平时工作也比较忙，所以没有更新文章。今天正好有时间，就想写点东西，为生活的自己，为远方的家人，增添一些精彩。 介绍今天主要讲的就是markdown这门标记语言，说要标记语言，你们可能会想到html，对的，它就是一门超文本标记语言，用来展示网页内容结构的。 那markdown不太一样，它是用于文档的快速排版，类似于word。 它有以下特点： 轻量 简单 通用 用途 写博客 写说明 转化 写博客正因为它有那些特点，语法简单容易学，而且功能还比较强大，所以非常多的人用它来写博客。最流行的博客平台有很多都支持markdown，比如说wordpress，zblog等博客平台，还有github等代码托管平台。 写说明在github上随处可见各种仓库都有README.md结尾的说明文档，帮助开发者更好的了解这个仓库存放的东西是什么，都有哪些功能作用，可以用来做什么。 转化转化这个用途，就不太常见了，它主要是把markdown文件转化为ppt,word等文件文档格式。用于学术研究，数据计算等领域。 语法 标题 文本 图片 链接 列表 表格 代码 标题在markdown的语法规则中，标题是用 # 号来标记的，一共有六级，分别是1-6类似于html的标题标签。# 号从大到小，内容从大到小，# 号越多，级别越小，内容越详细。 语法如下:123456# 标题1## 标题2### 标题3#### 标题4##### 标题5###### 标题6 下面是效果展示： 标题1标题2标题3标题4标题5标题6文本文本也是markdown的特色之一。包括粗体，斜体，删除，引用，分割线。 123451.粗体用两个*号包围内容。 2.斜体用一对*号包围内容。 3.删除用一对两个波浪线表示 4.引用是用大于号来表示，大于号越多，程度越深。 5.分割线是用来区分各段落的不同内容的。 下面是效果展示。 我是斜体 我是粗体 我是删除内容 我是引用的内容 我是引用的内容 我是引用的内容 我是分割线 图片说明图片使用最前面一个英文叹号，中间是方括号括起来，写说明，后面是一个花括号，写图片地址。 语法：![我是图片](xxx.jpg) 这样就是表示一个图片。 例如： 图片占位图 链接链接的使用方法和图片有些类似，就是去掉了叹号，后面的都不变，前面还是方括号，用来链接地址文字说明，后面是花括号，用于链接的网络地址。 语法： [链接说明](http://www.example.com) 例如：百度 列表列表是用来展示要点，一列一列显示内容，用于内容比较多的时候使用。 语法： 无序列表：+和-。+就是一级列表，-就是二级列表。 有序列表：用数字加点，要空格。 例如： 这是无序列表。 水果 香蕉 苹果 葡萄 蔬菜 谷物 天气 这是有序列表。 水果 蔬菜 谷物 天气 表格表格是用于展示某一个统计内容的，范围比较广。 语法:123456表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容两点是左右，点在左边就文字居左。 例如： 12345序号|姓名|成绩|排名--|:--:|--:|--1|张三|98|优秀2|李四|46|不及格3|王五|63|合格 效果如下： 序号 姓名 成绩 排名 1 张三 98 优秀 2 李四 46 不及格 3 王五 63 合格 代码可以用代码或者代码块来写代码，是广大程序员必爱之物。 语法： 两个斜点表示一个代码条，并且高亮显示； 三个斜点一排，排成两排，中间写点内容，就是代码块，用来展示很多段代码。你可以在第一排旁边写上你要写代码的内容类型，比如：html,css,javascript或js,php等等都可以广泛的支持各种标记、编程语言。 效果如下： 代码条 例如：css 代码块 例如：这是一段html标记语言代码块。12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Markdown学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Markdown&lt;/h1&gt; &lt;p&gt;欢迎学习markdown课程。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 例如：这是一段css标记语言代码块。123456h1 &#123; color: #f00;&#125;p &#123; line-height: 20px;&#125; 例如：这是一段js标记语言代码块。1document.write('你好，欢迎学习markdown教程'); 写在最后Markdown是一门非常不错的，值得每个人学习的文本编辑器都支持的标记语法的语言，希望每个人都能学会，这里我只是把我日常写作中常用的做了一个总结汇总，都某时记不得的时候，再来回顾。","categories":[{"name":"markdown","slug":"markdown","permalink":"https://guanqi.xyz/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://guanqi.xyz/tags/markdown/"},{"name":"富文本编辑","slug":"富文本编辑","permalink":"https://guanqi.xyz/tags/富文本编辑/"}]},{"title":"github配置教程","slug":"git-config","date":"2018-11-18T14:16:21.000Z","updated":"2019-03-08T03:14:24.357Z","comments":true,"path":"2018-11-18/git-config/","link":"","permalink":"https://guanqi.xyz/2018-11-18/git-config/","excerpt":"","text":"一.配置ssh1.检查本机是否有ssh key设置如果没有则提示： No such file or directory如果有则进入~/.ssh路径下（ls查看当前路径文件，rm删除所有文件） 2.使用Git Bash生成新的ssh key$ cd ~ #保证当前路径在”~”下123456789101112$ ssh-keygen -t rsa -C &quot;xxxxxx@yy.com&quot; #建议填写自己真实有效的邮箱地址Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/xxxx_000/.ssh/id_rsa): #不填直接回车Enter passphrase (empty for no passphrase): #输入密码（可以为空）Enter same passphrase again: #再次确认密码（可以为空）Your identification has been saved in /c/Users/xxxx_000/.ssh/id_rsa. #生成的密钥Your public key has been saved in /c/Users/xxxx_000/.ssh/id_rsa.pub. #生成的公钥The key fingerprint is:e3:51:33:xx:xx:xx:xx:xxx:61:28:83:e2:81 xxxxxx@yy.com//本机已完成ssh key设置，其存放路径为：c:/Users/xxxx_000/.ssh/下。//可生成ssh key自定义名称的密钥，默认id_rsa。$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; -f ~/.ssh/githug_blog_keys #生成ssh key的名称为githug_blog_keys，慎用容易出现其它异常。 3.添加ssh key到GItHub3.1 登录GitHub系统； 点击右上角账号头像的“▼”→Settings→SSH kyes→Add SSH key。 key 3.2 复制id_rsa.pub的公钥内容1) 进入c:/Users/xxxx_000/.ssh/目录下，打开id_rsa.pub文件，全选复制公钥内容。2) Title自定义，将公钥粘贴到GitHub中Add an SSH key的key输入框，最后“AddKey”。 4.配置账户12$ git config --global user.name “your_username” #设置用户名$ git config --global user.email “your_registered_github_Email” #设置邮箱地址(建议用注册giuhub的邮箱) 5.测试ssh keys是否设置成功1234567$ ssh -T git@github.comThe authenticity of host &apos;github.com(192.30.252.129)&apos; can&apos;t be established.RSA key fingerprint is16:27:xx:xx:xx:xx:xx:4d:eb:df:a6:48.Are you sure you want to continueconnecting (yes/no)? yes #确认你是否继续联系，输入yesWarning: Permanently added&apos;github.com,192.30.252.129&apos; (RSA) to the list of known hosts.Enter passphrase for key&apos;/c/Users/xxxx_000/.ssh/id_rsa&apos;: #生成sshkye是密码为空则无此项，若设置有密码则有此项且，输入生成ssh key时设置的密码即可。Hi xxx! You&apos;ve successfullyauthenticated, but GitHub does not provide shell access. #出现词句话，说明设置成功。 二、Github新建项目1.Github新建项目点击按钮 新建 2.注意项目名（必须是：github的用户名.github.io） 新建 3.将项目clone到本地$ git clone https://github.com/&lt;你的用户名&gt;/&lt;仓库名字&gt;.git 然后输入命令，回车，等待clone完成。 4.将index.html推送到远程github仓库中123git add .git commit -m &quot;这里是注释信息，自己写&quot;git push origin master 三.写在最后git的配置就到这里。","categories":[{"name":"git","slug":"git","permalink":"https://guanqi.xyz/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://guanqi.xyz/tags/git/"},{"name":"github配置","slug":"github配置","permalink":"https://guanqi.xyz/tags/github配置/"}]},{"title":"雅虎军规总结","slug":"web-yahoo-rules","date":"2018-11-18T14:16:21.000Z","updated":"2019-03-08T03:07:19.602Z","comments":true,"path":"2018-11-18/web-yahoo-rules/","link":"","permalink":"https://guanqi.xyz/2018-11-18/web-yahoo-rules/","excerpt":"","text":"前言：雅虎军规是雅虎的开发人员在总结了网站的不合理部分后，提出的优化网站性能提高的一套方法规则，非常适合初学者绕过这些坎。这篇博文，是我在网络上搜集的一些关于雅虎军规的内容，图片归原作者所有，总结一起，供大家参考使用，希望对你们以后的开发过程中有所帮助。 http 1.尽可能的减少http请求数HTTP：从客户端到服务器端的请求消息。包括消息首行中，对资源的请求方法资源的标识符以及使用的协议。 请求过程：当你打开网页的时候，你所看到的文字，图片，多媒体，这一切内容，都是你从服务器获取的，每一个内容的获取，就是一个http请求。 http 2.使用CDN（内容分发网络）CDN：内容分发网络，意思就是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 CDN 通俗来说：就是在离你最近的地方，放置一台性能好、链接顺畅的副本服务器，让你能够以最近的距离，最快的速度获取内容。 CDN 3.添加Expire/Cache-Control头Expire头：内容是一个时间值，值就是资源在本地的过期时间，存在本地；在本地缓存阶段，找到一个对应的资源值，当前时间还没有超过资源的过期时间，就直接使用这个资源，不会发送http请求。 Cache-Control头C：是http协议中常用的头部之一，负责页面的缓存机制，如果该头部指示缓存，缓存的内容也会存在本地，操作流程和expire相似，但也有不同的地方，Cache-Control有更多的选项，而且有更多的处理方式。 4.启用Gzip压缩看图： Gzip压缩 举个例子： Gzip压缩 5.将css放在页面最上面CSS：CSS，就是层叠样式表。 CSS01 为了提高游览器加载速度，建议放在html的head标签内。 CSS02 CSS03 6.将script放在页面最下面页面DOM加载顺序： js01 为了顺利加载各种资源，把js放在页面最下面，可以正常运行脚本，也为获取DOM元素更流畅。 7.避免在CSS中使用Expressions定义： CSS—Expressions 例子： CSS—Expressions 8.把js和css文件放到外部文件中情况1：写在页面内，如果只是的单独一个页面使用js和css文件，可以写在页面里面；还有就是不经常访问的页面；并且脚本和样式很少。这样写可以： 减少页面请求 提升页面渲染速度 情况2：单独提取，如果是大量页面复用，那就需要引入js和css文件。这样写可以： 提高js和css的复用性 缩小页面体积 提高了js的css的可维护性 9.减少DNS查询DNS：（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。 DNS 缓存时间对比: 当缓存时间长时：减少DNS的重复查找，节省时间。 当缓存时间短时：及时的检测网站服务器的变化，保证正确性。 DNS 域名：（Domain Name），简称域名、网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。 可以使用单域和多域 DNS 10.压缩JavaScript和Css方法： 去除不必要的空白符，格式符，注释符。 简写方法名，参数名压缩js脚本。 例如：jquery 压缩JavaScript和Css 建议：：在网站上线项目前，将JavaScript和Css都进行压缩，使线上版本是最轻量级的，大幅提升网站性能。 11.避免重定向定义： 原始请求被重新转向了其他请求。 避免重定向 状态码： 301（Moved Permanently）：被移动到了另外的位置。 302 Found：被找到了，不在原始位置，临时重定向。 避免重定向 为什么避免重定向：多了一次请求。 避免重定向 12.移除重复的脚步例子: 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;移除重复的脚步&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=\"test\" type=\"text\" value=\"\"&gt; &lt;script&gt; var number = 0; &lt;/script&gt; &lt;script src=\"./test.js\"&gt;&lt;/script&gt; &lt;!-- 引用1次 正常 1 --&gt; &lt;script src=\"./test.js\"&gt;&lt;/script&gt; &lt;!-- 引用2次 不正常 2 --&gt;&lt;/body&gt;&lt;/html&gt; 123//js domnumber++;document.getElementById('test').value = number; 13.配置实体标签（ETag）定义：使用特殊的字符串来标识某个请求资源版本。 配置实体标签（ETag） 配置实体标签（ETag） 如果本地版本游览器一样，就使用本地的缓存文件，并且会返回304。 14.使用Ajax缓存定义：即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 使用Ajax缓存 方法：get和post POST：每次都执行，不被缓存。 get:同一地址不重复执行，可以被缓存。 get和post 写在最后这是我第一次总结前人的经验。","categories":[{"name":"前端规范","slug":"前端规范","permalink":"https://guanqi.xyz/categories/前端规范/"}],"tags":[{"name":"前端规范","slug":"前端规范","permalink":"https://guanqi.xyz/tags/前端规范/"},{"name":"雅虎军规","slug":"雅虎军规","permalink":"https://guanqi.xyz/tags/雅虎军规/"},{"name":"性能优化","slug":"性能优化","permalink":"https://guanqi.xyz/tags/性能优化/"}]},{"title":"前端杂谈之缘起","slug":"front-talk-origin","date":"2018-11-18T13:16:21.000Z","updated":"2019-03-08T03:04:45.980Z","comments":true,"path":"2018-11-18/front-talk-origin/","link":"","permalink":"https://guanqi.xyz/2018-11-18/front-talk-origin/","excerpt":"","text":"一.故事简介1.起源今天，我想讲一讲有关前端的一些趣事。首先介绍一下我吧，我叫观奇笔记，内容更新其实不算多，主要是是我工作比较忙，没有时间去更新。 2.行业态势前端技术，作为一门新兴的技术，已经火了好几年了，现在已经进入了一个瓶颈期，就是需求量还是会不断地增加，但是要求肯定会提高的，不会是以前的蛮荒时代，见一个前端就招进去了，而是会不断的筛选，淘汰技术差的，留下技术好的，一个大浪淘沙的时代。 二.播种期好了，开始言归正传。我来讲一讲我的前端生涯之路，也算是对之前的一些总结吧。 1.高中时代我现在脑海中清晰的记得，我上高三的时候，我们的微机课老师在教室的黑板上写了一段代码。我还能回忆起来，大概就是以下这段。 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;表格&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 2.讲课感受我就被这个神奇的代码所吸引住了，当时老师还边说，边讲，边在黑板上用白色粉笔头画着，其实就是用粉笔头写代码。我当时就感觉这玩意真好，我要了解它，学会它。自此，想要学习html代码的种子便在我心中种下了，直到以后它生根，发芽，开花，直到结果。 三.萌芽期1.无缘计算机上了大学以后，本来说是想报考计算机专业，但是没想到人招满了，我便被安排到了第二个志愿–电子商务，我感觉电子商务还可以，就是做购物网站的，还可以继续我的代码编写，我就欣然接受了这个专业，但是学开就后悔了，里面教的html少，也就是学习Dreamweaver（现在想想真是感觉太搞笑了，哈哈！），asp，商务一类的课程非常多，比如市场营销，商务谈判，管理学，经营企业，不管怎么不好，还是学点，以后会用到的。 2.冲破牢笼我后来就是自己买书，一点一点的学习web前端，其实那时候还不能叫前端，只能算作一个网页开发师。写一些简单的网页结构，一些简单的样式。自己没有电脑，就去学校的机房学习，打开电脑，打开记事本，就可以学习了，按照书上的，网上的教程学习，一点点的学习。每练习一个例子，就用记事本保存起来，存成Unicode格式或者utf-8格式的，可以在游览器显示的那种，后缀就是.html或者.htm就可以了，最后，在游览器里面查看效果，看到自己写的代码能够被游览器引擎解析然后展现在游览器的窗口里面，顿时感觉心中非常开心。 四.写在最后好了，今天就讲到这里，以后陆续会和大家分享我的前端成长之路的。","categories":[{"name":"前端杂谈","slug":"前端杂谈","permalink":"https://guanqi.xyz/categories/前端杂谈/"}],"tags":[{"name":"前端杂谈","slug":"前端杂谈","permalink":"https://guanqi.xyz/tags/前端杂谈/"},{"name":"缘起","slug":"缘起","permalink":"https://guanqi.xyz/tags/缘起/"}]},{"title":"git工具命令使用教程","slug":"git-command","date":"2018-09-25T09:30:21.000Z","updated":"2019-03-08T03:13:16.113Z","comments":true,"path":"2018-09-25/git-command/","link":"","permalink":"https://guanqi.xyz/2018-09-25/git-command/","excerpt":"","text":"这是一个学习git-bash以及命令的教程！ 常用命令git add 含义：这是将文件从本地文件夹提交到git storage (暂存区)。 例如：git add test.txt git commit -m ““含义：这是将暂存区的文件提交到当前分支(master)。 例如： git commit -m &quot;add files&quot; git pull origin 含义： 这是将远程仓库的git文件拉到本地。 例如：git pull origin master git push origin 含义： 这是将本地分支的git文件推送到远程仓库。 例如：git push origin master 分支（master）创建分支git branch &lt;分支名字&gt; 例如：git branch dev 切换到指定分支git checkout dev 创建并且切换到指定分支git branch -b &lt;分支名字&gt; 例如：git branch -b dev 删除分支git branch -d &lt;分支名字&gt; 例如：git branch -d dev 强制删除分支git branch -D &lt;分支名字&gt; 例如：git branch -D dev 删除远程分支git push origin -D &lt;分支名字&gt; 例如：git push origin -D dev 合并分支git merge &lt;分支名称&gt; 例如：git merge dev 标签创建标签git tag &lt;标签名字&gt; 例如: git tag v0.1 查看所有标签git tag 查看标签信息git show v0.1 创建带有说明的标签git tag -a v0.1 -m &quot;add tags&quot; 删除标签git tag -d &lt;标签名字&gt; 推送标签到远程仓库 推送本地全部标签：git push origin --tags 推送特定标签：git push origin v0.1 删除远程仓库标签git push origin :refs/tags/v0.1 其他忽略其他文件 有时候我们并不希望一些东西在我们的提交内容里面，比如node_moundle 在文件夹下面创建.gitignore就可以忽略不希望提交的内容。 12# windowsDesktop.ini 最后这一期的git讲解就到这里。","categories":[{"name":"git","slug":"git","permalink":"https://guanqi.xyz/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://guanqi.xyz/tags/git/"},{"name":"git命令","slug":"git命令","permalink":"https://guanqi.xyz/tags/git命令/"}]},{"title":"Vue基础教程(三)","slug":"vue-use-three","date":"2018-05-10T00:42:21.000Z","updated":"2019-03-08T02:05:01.052Z","comments":true,"path":"2018-05-10/vue-use-three/","link":"","permalink":"https://guanqi.xyz/2018-05-10/vue-use-three/","excerpt":"","text":"hello,大家好！时隔一天，我又回来了。因为一些事情停了。经过前两节，大家应该对vuejs有了一些了解。今天继续讲解vuejs。 目录 插值 指令 缩写 插值文本插值 这是数据绑定最常见的形式，使用的Mustache”语法 (双大括号) 。 例如：&lt;span&gt;这个将不会改变: &lt;/span&gt; 原生html内容这个你需要使用v-html来实现。 例如： 1.&lt;p&gt;这是html内容：&lt;/p&gt; 2.&lt;p v-html=&quot;str&quot;&gt;&lt;/p&gt; 注意：你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。 指令 指令 (Directives) 是带有 v- 前缀的特殊特性，响应式的作用于DOM。 v-if含义：这个是根据传入的值来决定是否移除绑定的元素，它的值是true或者false 例如：&lt;p v-if=&quot;true&quot;&gt;我是vue&lt;/p&gt; 修饰符修饰符：以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。 &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;表单内容&lt;/form&gt; 缩写v- 作为一种识别特性，常常会缩写，以便提高代码效率。 v-onv-on是绑定元素要触发的各种事件的，可以缩写成@&lt;事件名&gt;=&quot;&lt;触发的函数名&gt;&quot; 例如： 1234//1.原样：&lt;button v-on:click=&quot;checkForm&quot;&gt;&lt;/button&gt;//2.缩写：&lt;button @click=&quot;checkForm&quot;&gt;&lt;/button&gt; v-bindv-bind是绑定元素属性的一种指令，可以缩写成:&lt;属性名&gt;=&quot;&lt;属性值&gt;&quot; 例如： 1234&lt;!-- 1.原样： --&gt;&lt;a v-bind:href=\"url\"&gt;链接&lt;/a&gt;&lt;!-- 2.缩写： --&gt;&lt;a :href=\"url\"&gt;链接&lt;/a&gt; 写在最后今天虽然只讲了一点，但贵在积累，积少成多，每天学习一点，相信总有一天能够技压群雄，加油！幸福生活是奋斗出来的。","categories":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/categories/vuejs/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/tags/vuejs/"},{"name":"vue基础","slug":"vue基础","permalink":"https://guanqi.xyz/tags/vue基础/"}]},{"title":"Vue基础教程(二)","slug":"vue-use-two","date":"2018-05-08T02:42:21.000Z","updated":"2019-03-08T02:05:31.809Z","comments":true,"path":"2018-05-08/vue-use-two/","link":"","permalink":"https://guanqi.xyz/2018-05-08/vue-use-two/","excerpt":"","text":"今天一起来和大家探讨vue基础知识点，主要是一些基本用法，只有打好扎实的基础，才能在以后vue.js开发过程中少走弯路。 目录 创建vue实例 数据绑定 方法 一.创建vue实例 首先引入vue.js文件 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 然后实例化一个vue 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最后定义vue的管理边界 注意： 如果你不定义管理边界，就可能无法应用vue中的属性和方法。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 在这里写vue.js --&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二.数据绑定数据： 这里的数据就是你要渲染到页面中的值,这个数据发生变化，视图中的数据也会发生变化。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 在这里写vue.js --&gt; &lt;input type=\"text\" v-model=\"str\"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; str: '' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 三.方法方法： 就是js中的函数和事件监听。 例如：弹出一个信息。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 在这里写vue.js --&gt; &lt;input type=\"text\" v-model=\"str\"&gt; &lt;p&gt;&#123;&#123; str &#125;&#125;&lt;/p&gt; &lt;button @click=\"alertInfo\"&gt;弹出信息&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; str: '' &#125;, methods: &#123; alertInfo () &#123; alert('这就是vue'); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 四.写在最后今天虽然只讲了一点，但贵在积累，积少成多，每天学习一点，相信总有一天能够技压群雄，加油！幸福生活是奋斗出来的。","categories":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/categories/vuejs/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/tags/vuejs/"},{"name":"vue基础","slug":"vue基础","permalink":"https://guanqi.xyz/tags/vue基础/"}]},{"title":"Vue基础教程(一)","slug":"vue-use-one","date":"2018-05-06T13:54:21.000Z","updated":"2019-03-08T02:04:41.399Z","comments":true,"path":"2018-05-06/vue-use-one/","link":"","permalink":"https://guanqi.xyz/2018-05-06/vue-use-one/","excerpt":"","text":"哈喽，大家好！今天给大家继续讲解vue的知识点。 目录 引入vue.js文件 声明式渲染 一.引入vue.js 下载vue.js文件：点击下载 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; CDN线上，引入地址：https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.common.js &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.common.js&quot;&gt;&lt;/script&gt; 新建html文件，在head标签内引入 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;引入vue&lt;/title&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- //内容 --&gt; &lt;/div&gt; &#123;&#123; 1+2 &#125;&#125; &lt;script&gt; new Vue(&#123; el: '#app' &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 二.声明式渲染两个花括号中间可以写表达式，判断，数据类型，就是不能写循环。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;引入vue&lt;/title&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;&#123; msg &#125;&#125; &lt;script&gt; new Vue(&#123; el: '#app', data: &#123; msg: '111' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 写在最后今天虽然只讲了一点，但贵在积累，积少成多。","categories":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/categories/vuejs/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/tags/vuejs/"},{"name":"vue基础","slug":"vue基础","permalink":"https://guanqi.xyz/tags/vue基础/"}]},{"title":"数据结构","slug":"computer-base-dataset-learn","date":"2018-05-05T06:30:21.000Z","updated":"2019-03-08T02:39:35.231Z","comments":true,"path":"2018-05-05/computer-base-dataset-learn/","link":"","permalink":"https://guanqi.xyz/2018-05-05/computer-base-dataset-learn/","excerpt":"","text":"数据结构 数据元素：数据的基本单位，每一个需要处理的对象都可以抽象成数据元素，简称元素。 数据结构：包含数据和结构。 数据：是需要处理的数据元素的集合，一般来说这些数据元素，具有某个共同的特征。例如：方向（东南西北） 结构：就是关系，即集合中各个数据元素之间存在的某种关系（或联系）。1.线性结构，2.树形结构，3.图状结构，4.集合。 数据元素之间的关系用前件和后件来描述。例如：连长是排长的后件，排长是连长的前件。 前后件关系是数据元素之间最基本的关系。 数据结构是指相互有关联的数据元素的集合。 数据是有结构的数据，结构是有数据之间关系决定的。 数据元素有逻辑和关系。数据结构逻辑结构和存储结构数据的逻辑结构 数据的逻辑结构指的是数据元素之间的逻辑关系（前后件关系）的数据结构。B=(D,R); B = 数据结构 D = 数据元素的集合 R = D上关系的集合。 B = (D,R)D = {早餐，午餐，晚餐}R = {(早餐，午餐),(午餐，晚餐)} 数据的存储结构 数据的存储结构：又称数据的物理结构，是数据的逻辑结构在计算机存储空间中的存放方式。 顺序存储结构：逻辑上相邻的数据元素，存储在物理上相邻的存储单元里。 200 k1 201 k2 202 k3 203 k4 204 k5 链式存储结构：每个节点中至少包含一个指针域，用指针来体现数据元素之间逻辑上的联 系。 Head Key Info 200 –&gt; 200 k1 204 201 202 k3 203 203 k4 207 204 k2 202 205 206 207 k5 ^ 链式存储的线性表 最后这是计算机基础知识，最普通的一个概念。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://guanqi.xyz/categories/计算机基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://guanqi.xyz/tags/数据结构/"}]},{"title":"初识webpack","slug":"tool-webpack-use","date":"2018-04-01T08:07:39.000Z","updated":"2019-03-08T03:06:34.918Z","comments":true,"path":"2018-04-01/tool-webpack-use/","link":"","permalink":"https://guanqi.xyz/2018-04-01/tool-webpack-use/","excerpt":"","text":"今天，咱们正式介绍一下前端构建打包神器，webpack。这是一款非常流行的打包工具，和各种框架都非常搭配。 一.简介大家好！今天我开始分享有关web前端的故事。俗话说：“男怕入错行，女怕嫁错郎”。如果能够进入发展前景比较好的行业是一个不错的选择，对自己以后的成长与发展都会起到很大的作用。虽然说目前还看不出什么，但是相信随着时间的流逝，这个行业会越来越好。而我选择的这个行业，就是互联网行业，属于服务业。而我目前从事的是前端，这个从2015年兴盛起来的职业，目前已经度过了寒冬，正迎来蓬勃的生机。 二.四个核心概念接下来就解释一下这四个核心的概念。 入口(entry) 输出(output) loader 插件(plugins) 1.入口(entry)入口：所谓入口，就是指示webpack应该使用哪个模块来作为内部依赖的开始，它会根据入口来生成一个bundles文件。 例如：123module.exports = &#123; entry: './path/to/my/entry/file.js'&#125;; 上面就是指定入口文件，就是file.js。 2.输出(output)出口：就是打包输出到哪个文件夹下面去。 例如：1234567const path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;&#125;; 上面就是指定出口文件dist，文件名称叫dist文件夹下面的这个文件my-first-webpack.bundle.js。 3.loaderloader:就是让webpack去处理那些非JavaScript文件，并且导入任何类型的模块，比如css。并且，进行处理。它可以将所有类型的文件，转化为可以直接引用的模块。 例如：123456789101112131415//定义规则const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; //解析规则 ] &#125;&#125;;// 到处配置module.exports = config; 这个就是，模块打包规则。test,use,就是告诉webpack遇到引用txt文件的，使用raw-loader转化一下。 4.插件(plugins)这是最后一个核心概念。有时候，前面的不一定处理过来，所以靠扩展插件来提高打包效率是一个非常有效的方法。它可以执行更多复杂的任务，例如：打包优化，压缩，重新定义环境变量等等。 插件的使用方法见下面的代码。1234567891011121314151617const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config; 四.总结我们今天先说到这里，下次继续聊webpack。","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://guanqi.xyz/categories/构建工具/"}],"tags":[{"name":"构建工具","slug":"构建工具","permalink":"https://guanqi.xyz/tags/构建工具/"},{"name":"webpack","slug":"webpack","permalink":"https://guanqi.xyz/tags/webpack/"}]},{"title":"前端杂谈之认识vue","slug":"front-talk-vue","date":"2018-02-18T12:57:39.000Z","updated":"2019-03-08T03:09:06.106Z","comments":true,"path":"2018-02-18/front-talk-vue/","link":"","permalink":"https://guanqi.xyz/2018-02-18/front-talk-vue/","excerpt":"","text":"一.vue行业大家好！今天我开始分享有关web前端的故事。俗话说：“男怕入错行，女怕嫁错郎”。如果能够进入发展前景比较好的行业是一个不错的选择，对自己以后的成长与发展都会起到很大的作用。虽然说目前还看不出什么，但是相信随着时间的流逝，这个行业会越来越好。而我选择的这个行业，就是互联网行业，属于服务业。而我目前从事的是前端，这个从2015年兴盛起来的职业，目前已经度过了寒冬，正迎来蓬勃的生机。 二.vue是什么好了，废话不多说，现在就开始进入正题。有很多人看到这里，会禁不住的问，那vue是什么呢？vue是一套基于js写的框架，可以方便轻松的开发spa单页面应用程序。它是由前Google工程师尤雨溪开发的，它解决了开发者开发过程中的四个痛点。 三.四大痛点1.学习门槛低第一个就是，使得学习vue的门槛变得非常低，只要你会基础的html和css知识，懂得原生的js，那么恭喜您，已经拿到了学习vue的入场券。这对于web前端的小伙伴们来说是一个非常诱人的东西，你不需要掌握什么高深的技术知识，就可以轻松学习vue知识点。 2.学习成本低当然了，除了学习门槛比较低之外，学习成本也是比较低的，不你需要花费多大的时间，以及金钱。它是一个免费开源的js框架，为开发者提供高效率的开发框架。你需要点击进入它的官网，便可以看见它的开发文档。这套文档感觉非常通俗易懂，只要你仔细阅读，还是可以读懂的。它还提供了脚手架组件化开发工具，只有你下载下来一步步输入几行命令，就可以拥有很不错的开发环境。 3.覆盖设备广第三个就是，它跨设备，基本上各种设备都支持，不论是PC端，还是移动端，亦或者是手机app都可以。这种特点给了使用它的人极大的方便。 4.跨平台第四个就是跨平台，在这里我就一句话概括，既可以开发andriod，也可以开发ios应用。 四.总结以上就是web开发的四个痛点，vue都完美解决。我刚开始接触vue的时候，只是知道它是一种区别于MVC模式的MVVM模式。MVVM的本质就是通过数据绑定view和model，数据一旦发生变化，view和model也会发生变化。这种模式使得学习vue非常简单好用！ 我正在行驶在这一条vue大道上，我知道我的方向不变，始终会到达终点的。我始终相信，功夫不负有心人，只要努力坚持，一定会成功！","categories":[{"name":"前端杂谈","slug":"前端杂谈","permalink":"https://guanqi.xyz/categories/前端杂谈/"}],"tags":[{"name":"前端杂谈","slug":"前端杂谈","permalink":"https://guanqi.xyz/tags/前端杂谈/"},{"name":"认识vue","slug":"认识vue","permalink":"https://guanqi.xyz/tags/认识vue/"}]},{"title":"node.js常用命令","slug":"node-command","date":"2017-12-21T07:27:21.000Z","updated":"2019-03-08T02:24:25.201Z","comments":true,"path":"2017-12-21/node-command/","link":"","permalink":"https://guanqi.xyz/2017-12-21/node-command/","excerpt":"","text":"包管理器 现今的包管理器有很多，包括npm,yard,bower,今天介绍两个包管理器，分别是npm和bower,本篇采用git工具安装。 npm bower npm包基本命令 node package manager ,Node 的包管理器 安装node验证是否安装node12$node -v$npm -v 安装包安装到当前目录 1$ npm install &lt;包名&gt; 出现error network 重新安装 安装指定版本在cmd中: 12$ npm install &lt;包名&gt;@版本号$ npm install jquery@1.12.4 搜索包1$npm search &lt;包名&gt; 查看包的版本信息1$ npm list &lt;包名&gt; 查看安装的包列表1$npm ls 更新包1$ npm update &lt;包名&gt; 卸载包1$ npm uninstall jquery bower安装命令安装包$ bower install &lt;包名&gt; --save,在当前目录安装包，并将版本信息添加到bower.json中 $ bower install &lt;包名&gt;@版本号，安装指定的版本号 查看包的信息$ bower info &lt;包名&gt; 查看包的详细信息 搜索包$ bower search &lt;包名&gt; 包列表$ bower list 卸载包$ bower uninstall &lt;包名&gt; init 初始化npm init 会生成一个packagejson的文件，项目的配置信息 1$ npm init 12345678910111213141516171819&#123; &quot;name&quot;: &quot;day06&quot;, //项目名 &quot;version&quot;: &quot;1.0.0&quot;, //版本号 &quot;description&quot;: &quot;this is a npm project&quot;, //项目的描述 &quot;main&quot;: &quot;index.js&quot;, //程序的入口文件 &quot;dependencies&quot;: &#123; //项目依赖的包!!!重要的 &quot;jquery&quot;: &quot;^1.12.4&quot; &quot;zepto&quot;: &quot;^1.2.0&quot; &#125;, &quot;devDependencies&quot;: &#123;&#125;, //开发阶段依赖的包!!!重要的 &quot;scripts&quot;: &#123; //命令 &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [ //关键词 &quot;npm&quot; ], &quot;author&quot;: &quot;guanqi&quot;, //作者 &quot;license&quot;: &quot;ISC&quot; //协议&#125; 安装并添加依赖$ npm install &lt;包名&gt; --save 会将当前目录下的安装包，并将包的信息，添加到package.json中的dependencies选项中 $ npm install &lt;包名&gt; --save-dev安装开发阶段用的工具包，并不是项目必须有的。这个命令会将包安装到当前目录下的安装包，并将包的版本信息，添加到package.json中的devDependencies选项中 全局安装$ npm install &lt;包&gt; -g , -g代表全局安装，不会在package.json中看到 写在最后心动不如行动，快练习一下巩固知识。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/tags/nodejs/"},{"name":"node命令","slug":"node命令","permalink":"https://guanqi.xyz/tags/node命令/"}]},{"title":"Node.js简介","slug":"node-introduction","date":"2017-12-10T10:04:21.000Z","updated":"2019-03-08T02:25:39.937Z","comments":true,"path":"2017-12-10/node-introduction/","link":"","permalink":"https://guanqi.xyz/2017-12-10/node-introduction/","excerpt":"","text":"简介官网中文官网 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js是构建在 chorme的V8引擎上的一个js运行时 Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. 事件驱动(回调函数) 非阻塞异步I/O 单线程单进程 Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 作者Ryan Dahl 适用场景 高并发(双11) 站内信 实时聊天 缺点：不适合大量的计算 Global在游览器中全局对象（顶层对象）是window在node中全局对象叫Global Buffer process console setTimeout setInterval clearTimeout clearInterval REPL环境进入的方法，在cmd中输入node,然后enter，就可以进入node的REPL环境。 Read 读，读取用户输入，解析输入的JS数据结构并存储在内存中 Eval 执行，执行输入的数据结构 Print 打印，输出结果 Loop 循环 ，循环操作以上步骤，直到CTRL+C以后 退出REPL环境，用Ctrl+C两次 运行Node.js的代码$ node &lt;文件名&gt; 总结node.js是一个很不错的后端服务器编程语言。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/tags/nodejs/"},{"name":"node简介","slug":"node简介","permalink":"https://guanqi.xyz/tags/node简介/"}]},{"title":"todocmvc练习(vue版)","slug":"vue-todomvc","date":"2017-10-23T06:42:21.000Z","updated":"2019-03-08T02:07:48.521Z","comments":true,"path":"2017-10-23/vue-todomvc/","link":"","permalink":"https://guanqi.xyz/2017-10-23/vue-todomvc/","excerpt":"","text":"安装依赖安装依赖的css，js。 1$ npm install 引入vue1&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; 定义初始化数据在app.js中，实例化Vue，然后定义初始化数据 12345678910let vm = new Vue(&#123; el: '#app', data: &#123; datas: [ &#123;id: 121,title: 'html5',isCompleted: false&#125;, &#123;id: 122,title: 'css3',isCompleted: false&#125;, &#123;id: 123,title: 'js6',isCompleted: false&#125;, ] &#125;&#125;) 绑定假数据到li上如果当前的isCompleted是true,就是显示选中状态 12345678&lt;li :class=\"&#123;completed: isCom&#125;\" v-for=\"(item,index) in datas\"&gt; &lt;div class=\"view\"&gt; &lt;input class=\"toggle\" type=\"checkbox\"&gt; &lt;label&gt;&#123;&#123; item.title &#125;&#125;&lt;/label&gt; &lt;button class=\"destroy\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class=\"edit\" value=\"Create a TodoMVC template\"&gt;&lt;/li&gt; 双向数据绑定1&lt;input class=\"new-todo\" placeholder=\"What needs to be done?\" v-model=\"val\"&gt; 1val: '', //显式声明 输入框数据 回车输入数据1&lt;input class=\"new-todo\" placeholder=\"What needs to be done?\" @keyup.enter=\"addItem\" v-model=\"val\"&gt; 12345678910111213methods: &#123; addItem()&#123; if(this.val)&#123; //val存在或者非空的时候才会去添加 this.datas.push(&#123; //console.log(new Date().getTime()); id: new Date().getTime(), //为了保持id的唯一 title: this.val, isCompleted: false, &#125;); this.val = ''; //填完数据以后清空输入框的内容 &#125; &#125;&#125; 显示总计通过一个方法来计算数组数据的长度 1234567891011121314151617181920212223methods: &#123; addItem()&#123; if(this.val)&#123; //val存在或者非空的时候才会去添加 this.datas.push(&#123; //console.log(new Date().getTime()); id: new Date().getTime(), //为了保持id的唯一 title: this.val, isCompleted: false, &#125;); this.val = ''; //填完数据以后清空输入框的内容 &#125; &#125;, clearCompleted()&#123; let arr = []; //遍历datas,如果当前选项是未选中,就把它留下 this.datas.forEach(function(elem)&#123; if(!elem.isCompleted)&#123; arr.push(elem); &#125; &#125;,this) this.datas = arr; &#125;&#125; 首先绑定计算属性 1&lt;span class=\"todo-count\"&gt;&lt;strong&gt;&#123;&#123; legTotal &#125;&#125;&lt;/strong&gt; item left&lt;/span&gt; 选中后显示隐藏completed通过v-show来控制显示隐藏 1&lt;button class=\"clear-completed\" v-show=\"isShowClear\"&gt;Clear completed&lt;/button&gt; 1234567891011//在计算属性中compluted：&#123; isShowClear()&#123; for(let i=0;i&lt;this.datas.length;i++)&#123; if(this.datas[i].isCompleted)&#123; return true &#125; &#125; return false &#125;&#125; 点击clear completed删除选中项绑定点击事件 1&lt;button class=\"clear-completed\" v-show=\"isShowClear\" @click=\"clearCompleted\"&gt;Clear completed&lt;/button&gt; 在方法中写这个点击事件 12345678910clearCompleted()&#123; let arr = []; //遍历datas,如果当前选项是未选中,就把它留下 this.datas.forEach(function(elem)&#123; if(!elem.isCompleted)&#123; arr.push(elem); &#125; &#125;,this) this.datas = arr;&#125; 点击X号删除当前项添加点击事件 1&lt;button class=\"destroy\" @click=\"removeCurrent(index)\"&gt;&lt;/button&gt; 123removeCurrent(index)&#123; this.datas.splice(index,1); &#125; 全选全不选点击全选如果是true,让数据全部变成非选中状态; 1&lt;input id=\"toggle-all\" class=\"toggle-all\" type=\"checkbox\" @click=\"checkedAll\"&gt; 12345678910111213//在方法中checkedAll()&#123; if(this.isCheckedAll)&#123; //全部选中 this.datas.forEach(elem=&gt;&#123; elem.isCompleted = false; &#125;) &#125;else&#123; this.datas.forEach(elem=&gt;&#123; elem.isCompleted = true; &#125;) &#125; this.isCheckedAll = !this.isCheckedAll;&#125; 总结这是一个练习，是用vue写的，各方面都练习到了。","categories":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/categories/vuejs/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/tags/vuejs/"},{"name":"todomvc","slug":"todomvc","permalink":"https://guanqi.xyz/tags/todomvc/"}]},{"title":"gulp下babel编译教程","slug":"tool-gulp-babel-use","date":"2017-09-21T09:30:21.000Z","updated":"2019-03-08T03:06:45.595Z","comments":true,"path":"2017-09-21/tool-gulp-babel-use/","link":"","permalink":"https://guanqi.xyz/2017-09-21/tool-gulp-babel-use/","excerpt":"","text":"babel安装安装前你需要安装node.js和npm以及gulp三个包。 然后执行以下命令 1$ npm init 然后在安装 babel和babel-core两个包 1$ npm install --save-dev gulp-babel babel-preset-env 1npm install babel-cor --save-dev 建立文件夹新建一个名为gulpfile.js的文件夹,然后引入包 12345678910111213const gulp = require(&apos;gulp&apos;);const babel = require(&apos;gulp-babel&apos;); gulp.task(&apos;default&apos;, () =&gt; gulp.src(&apos;es6/*.js&apos;) .pipe(babel(&#123; presets: [&apos;env&apos;] &#125;)) .pipe(gulp.dest(&apos;dist&apos;)));gulp.task(&apos;babel&apos;,() =&gt; &#123; gulp.watch(&apos;es6/*.js&apos;,[&apos;default&apos;])&#125;); 新建一个名为src 的文件夹,然后写点js. 1234567&#123; let a = 3; let arr = [1,2,3]; &#125;console.log(a);console.log(arr); 运行任务$ gulp $ gulp babel 这样就大功告成了！","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://guanqi.xyz/categories/构建工具/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/tags/es6/"},{"name":"构建工具","slug":"构建工具","permalink":"https://guanqi.xyz/tags/构建工具/"},{"name":"gulp","slug":"gulp","permalink":"https://guanqi.xyz/tags/gulp/"},{"name":"babel","slug":"babel","permalink":"https://guanqi.xyz/tags/babel/"}]},{"title":"使用hexo+coding搭建个人博客","slug":"hexo-coding-config","date":"2017-09-21T07:16:21.000Z","updated":"2019-03-08T02:33:43.176Z","comments":true,"path":"2017-09-21/hexo-coding-config/","link":"","permalink":"https://guanqi.xyz/2017-09-21/hexo-coding-config/","excerpt":"","text":"1.检测node和npm先检测一下有没有node.js和npm 12345678$ node -v//如果有，说明node.js安装成功！$ node -vv8.4.0//如果有，说明npm安装成功！$npm -v$ npm -v5.3.0 2.安装hexo在git-bash中运行以下命令安装hexo 安装hexo全局1$ npm install -g hexo-cli 建立文件夹123hexo init blogcd blognpm install 然后运行$ npm install 就能够建立起一个本地的服务器，端口是4000，打开浏览器 http://localhost:4000 就能访问属于你自己的博客了。 3.切换主题主题代码拷贝主题的拷贝也是直接使用 git 即可，首先进入到你博客的根目录，再打开 git-bash 运行 git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在博客根目录下找到 _config.yml 文件，找到里面的 theme，改为 theme: next 这时再运行一次 hexo s ，看看主题有没有生效吧。 4.发布到coding前提是你先注册一个coding账号 hexo 提供了一个部署命令 hexo deploy，首先需要安装一下 hexo-deployer-git插件 npm install hexo-deployer-git --save 然后配置一下_config.yml 文件： 1234deploy: type: git repoistory: https://git.coding.net/codinggq/problog.git branch: master 预览效果 在 coding 上建立一个私人仓库，找到代码的 coding 地址，填好上面的配置，然后直接执行 hexo deploy 不出意外的话会让你填写 coding 的用户名和密码完成上传操作。如果你有配置 ssh 方式的话就更加方便了。 这个时候再到 coding 对应的项目里面打开 pages 服务，根据 coding 建议，因为不是 jekyll 项目，所以需要再新建一个.nojekyll 文件（空文件就行，其实不建立也行），等上一会就能够访问自己的博客了。 最后运行以下命令上传到coding 12$ hexo g$ hexo d 如果不行用git,输入以下命令 12345678mkdir problogcd probloggit initecho &quot;# problog&quot; &gt;&gt; README.mdgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://git.coding.net/codinggq/problog.gitgit push -u origin master 5.写在最后今天的hexo+coding配置免费博客就到这里，赶快体验一下吧！","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"https://guanqi.xyz/categories/搭建博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://guanqi.xyz/tags/hexo/"},{"name":"coding","slug":"coding","permalink":"https://guanqi.xyz/tags/coding/"},{"name":"blog","slug":"blog","permalink":"https://guanqi.xyz/tags/blog/"}]},{"title":"SASS使用教程","slug":"tool-sass-use","date":"2017-09-19T00:42:21.000Z","updated":"2019-03-08T03:08:05.177Z","comments":true,"path":"2017-09-19/tool-sass-use/","link":"","permalink":"https://guanqi.xyz/2017-09-19/tool-sass-use/","excerpt":"","text":"本篇我想大家介绍SASS的一些知识，希望对大家有所帮助。 1.SASS介绍。 SASS是世界上最成熟、最稳定、最强大的专业级CSS扩展语言！ SASS有以下四个特点: 兼容CSSSass完全兼容所有版本的CSS。我们对此严格把控，所以你可以无缝地使用任何可用的CSS库。 特性丰富Sass拥有比其他任何CSS扩展语言更多的功能和特性。Sass核心团队不懈努力，一直使其保持领先地位 成熟Sass已经经过其核心团队超过8年的精心打造。 行业认可一次又一次地，行业把Sass作为首选CSS扩展语言。 社区庞大数家科技企业和成百上千名开发者为Sass提供支持。 框架有无数的框架使用Sass构建。比如Compass，Bourbon，和Susy。 2.SASS安装配置。安装前，你需要安装npm和gulp这两个工具。 安装ruby由于sass基于ruby语言开发而成，所以安装sass前还需要安装ruby。 安装成功后，在cmd中输入以下命令： 123ruby -v//如果成功则会出现ruby 2.4.1p111 (2017-03-22 revision 58053) [x64-mingw32] 接下来，更换成国内的gem源1234567891011//1.删除原gem源gem sources --remove https://rubygems.org///2.添加国内淘宝源gem sources -a https://ruby.taobao.org///3.打印是否替换成功gem sources -l//4.更换成功后打印如下*** CURRENT SOURCES ***https://ruby.taobao.org/ 最后，安装sass。123$npm init//一路直下$ npm install sass --save-dev 安装完成后查看版本 123$ sass -v//出现这说明安装成功Sass 3.5.1 (Bleeding Edge) 至此，已经安装好了sass。 3.SASS语法介绍。基础知识。 导入@import ‘reset’所有的sass导入文件都可以忽略后缀名.scss。一般来说基础的文件命名方法以_开头，如_mixin.scss。这种文件在导入的时候可以不写下划线，可写成@import “mixin”。 注释 /**/多行注释//单行注释 变量 声明变量用$符号 例如：$width:300px 默认变量加上default 例如：$width:300px!default 嵌套 选择器嵌套 例如： 12345678910div&#123; font-size: 20px; a&#123; span&#123; font-weight: 500; color: #ff0; font-size: 5em; &#125; &#125;&#125; 属性嵌套 12345678910111213div &#123; border: &#123; style: solid; left: &#123; width: 4px; color: #888; &#125; right: &#123; width: 2px; color: #ccc; &#125; &#125;&#125; 跳出嵌套 12345678910div&#123; font-size: 20px; a&#123; @at-root span&#123; font-weight: 500; color: #ff0; font-size: 5em; &#125; &#125;&#125; 伪类嵌套 12345678910111213div&#123; &amp;hover:&#123; color: #f00; &#125; font-size: 20px; a&#123; @at-root span&#123; font-weight: 500; color: #ff0; font-size: 5em; &#125; &#125;&#125; 还有一些，以后介绍。 4.SASS总结。通过学习SASS，我感受到了SASS强大的CSS编译功能，确实方便我们每个人进行CSS编译开发。","categories":[{"name":"编译工具","slug":"编译工具","permalink":"https://guanqi.xyz/categories/编译工具/"}],"tags":[{"name":"css编译","slug":"css编译","permalink":"https://guanqi.xyz/tags/css编译/"},{"name":"sass","slug":"sass","permalink":"https://guanqi.xyz/tags/sass/"}]},{"title":"栈及其基本运算","slug":"computer-base-stock-learn","date":"2017-09-19T00:42:21.000Z","updated":"2019-03-08T02:39:21.634Z","comments":true,"path":"2017-09-19/computer-base-stock-learn/","link":"","permalink":"https://guanqi.xyz/2017-09-19/computer-base-stock-learn/","excerpt":"","text":"栈及其基本运算一.定义栈是一种特殊的线性表，所有的插入和删除都在表的同一端进行；在栈中，一端是封闭端，不允许进行插入和删除元素，另一端是开口端，允许插入和删除元素。 例如：子弹匣 通常用指针top来表示栈顶的位置，用指针bottom来指向栈底。 假设s=(a1,a2,a3,…an),a1=栈底元素，an=栈顶元素。先进后出，栈顶后入栈，先出栈，最晚被插入，最早被删除。 二.特点 栈顶元素总是最后被插入的元素，也是最早被删除的元素。 栈顶元素总是最早被插入的元素，也是最晚被删除的元素。 栈具有记忆作用。 在顺序存储结构下，栈的插入与删除运算都不需要移动表中其他数据元素。 栈顶指针top动态反映了栈中元素的变化情况。 栈的修改原则是“先进后出”（last in first out,lifo）,或后进先出（first in frist out,filo）,栈也被称为”后进先出“表。 三.基本运算栈的基本运算是： 入栈：在栈顶位置插入一个新元素。 退栈：取出栈顶元素并赋予制定变量。 读栈顶元素：将指针top指向的元素的值赋给一个指定的变量。 栈的存储可以采用顺序方式和链式方式来实现。 a.空栈 -&gt; b.插入元素A后 -&gt; c.插入元素b,c,e,f后 -&gt; d.删除元素e,f后 top F E D top D C C B B top A A A top 四.最后今天只是介绍了一部分，以后再补充。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://guanqi.xyz/categories/计算机基础/"}],"tags":[{"name":"栈运算","slug":"栈运算","permalink":"https://guanqi.xyz/tags/栈运算/"}]},{"title":"gulp使用指南","slug":"tool-gulp-use","date":"2017-09-17T00:16:21.000Z","updated":"2019-03-08T03:06:37.806Z","comments":true,"path":"2017-09-17/tool-gulp-use/","link":"","permalink":"https://guanqi.xyz/2017-09-17/tool-gulp-use/","excerpt":"","text":"我写这篇博客的目的只是为了帮助那些还不会gulp的人能够完整的使用gulp这个工具来协助你完成web开发！我希望这篇博客可以帮助你，那样我才会快乐! 这是一篇gulp使用指南！在阅读此篇之前，请确保你的电脑已经安装上npm包管理器！ gulp简介。gulp是一款自动化构建工具,由外国人开发,可以增强你的工作流程! gulp作用。 易于使用 通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。 构建快速 利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 插件高质 Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 易于学习 通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 gulp安装。在安装之前,你需要新建一个文件夹,但是名字不能为gulp。 首先，你需要运行以下命令：$ npm init 这是让npm初始化一下,一路按回车。 这时,你的根目录下就有了package.json这样一个配置文件！ 然后，你在安装一下gulp：$ npm install gulp --save-dev 这条命令是让gulp保存在根目录下，并且作为扩展工具。 最后,你查看一下gulp的版本号,如果出来,就说明成功了：123$ glup -v[20:11:34] CLI version 3.9.1[20:11:34] Local version 3.9.1 至此,便成功的安装好了,你现在激动不？好戏还在后面！ gulp案例。接下来,就由我给大家做一个案例,如何使用gulp这款工具。 首先,我们在根目录下新建一个文件夹,比如src,在它下面又有img,css,js,index.html;然后,开始下载必备的gulp包,这里有：1234567891011&quot;browser-sync&quot;: &quot;^2.18.13&quot;,&quot;gulp&quot;: &quot;^3.9.1&quot;,&quot;gulp-autoprefixer&quot;: &quot;^4.0.0&quot;,&quot;gulp-concat&quot;: &quot;^2.6.1&quot;,&quot;gulp-concat-css&quot;: &quot;^2.3.0&quot;,&quot;gulp-csscomb&quot;: &quot;^3.0.8&quot;,&quot;gulp-htmlmin&quot;: &quot;^3.0.0&quot;,&quot;gulp-imagemin&quot;: &quot;^3.3.0&quot;,&quot;gulp-less&quot;: &quot;^3.3.2&quot;,&quot;gulp-uglifycss&quot;: &quot;^1.0.8&quot;,&quot;gulp-uglyfly&quot;: &quot;^1.4.2&quot; 运行此条命令可以下载以上这些包： $ npm install &lt;你要下载的包名&gt; --save-dev 下载完以后,你需要到配置文件package.json中查看也没有添加到devDependencies中,如果有,就说明成功了！ 接着需用建立一个名为gulpfile.js的文件,然后输入以下命令： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//这些主要是引刚才下载的包var gulp = require('gulp'); var less = require('gulp-less');var uglifycss = require('gulp-uglifycss');var autoprefixer = require('gulp-autoprefixer');var csscomb = require('gulp-csscomb');var concat = require('gulp-concat');var uglyfly = require('gulp-uglyfly');var img = require('gulp-imagemin');var htmlmin = require('gulp-htmlmin');var browserSync = require('browser-sync').create();//接下来就是建立任务：//这个任务是把less编译成cssgulp.task('style',function()&#123; gulp.src(['src/css/*.less','!src/css/_*.less']) //入口文件 *在css下面以.less所有文件编译 .pipe(less()) .pipe(autoprefixer(&#123; browsers: ['Android 2.3', 'Android &gt;= 4', 'Chrome &gt;= 20', 'Firefox &gt;= 24', // Firefox 24 is the latest ESR 'Explorer &gt;= 8', 'iOS &gt;= 6', 'Opera &gt;= 12', 'Safari &gt;= 6'], cascade: false &#125;)) .pipe(csscomb()) .pipe(uglifycss()) //less编译 .pipe(gulp.dest('dest/css')) //出口文件&#125;);//这个任务是把所有的js文件合并成一个名为main.js的文件gulp.task('script',function()&#123; gulp.src('src/js/*.js') .pipe(concat('main.js')) .pipe(uglyfly()) .pipe(gulp.dest('dest/js'))&#125;);//这个任务是把图片复制,压缩gulp.task('img',function()&#123; gulp.src('src/img/*.*') .pipe(img()) .pipe(gulp.dest('dest/img'))&#125;);//这个任务是把所有的html文件压缩gulp.task('htmlmin',function()&#123; gulp.src('src/*.html') .pipe(htmlmin(&#123; collapseWhitespace: true, removeComments: true &#125;)) .pipe(gulp.dest('dest'))&#125;);//这个任务就是游览器热更新var reload = browserSync.reload;gulp.task('server',function()&#123; browserSync.init(&#123; server: &#123; baseDir: \"dest\" &#125; &#125;); gulp.watch('src/*.html',['htmlmin']).on(\"change\",reload); gulp.watch('src/js/*.js',['script']).on(\"change\",reload); gulp.watch('src/css/*.less',['style']).on(\"change\",reload); gulp.watch('src/img/*.*',['img']).on(\"change\",reload);&#125;) 最后大功告成！ 总结。gulp作为一款工具目前非常流行,希望大家多用它。此片博文还有许多不足之处,希望大家批评指正。","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://guanqi.xyz/categories/构建工具/"}],"tags":[{"name":"构建工具","slug":"构建工具","permalink":"https://guanqi.xyz/tags/构建工具/"},{"name":"gulp","slug":"gulp","permalink":"https://guanqi.xyz/tags/gulp/"}]}]}