{"meta":{"title":"猿七笔记","subtitle":null,"description":"fed","author":"猿七","url":"https://guanqi.xyz"},"pages":[{"title":"categories","date":"2019-01-16T01:32:14.000Z","updated":"2019-01-16T01:32:29.712Z","comments":false,"path":"categories/index.html","permalink":"https://guanqi.xyz/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-16T01:31:24.000Z","updated":"2019-01-16T01:32:25.407Z","comments":false,"path":"tags/index.html","permalink":"https://guanqi.xyz/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2019-07-14T08:09:59.461Z","updated":"2019-07-14T08:09:59.461Z","comments":false,"path":"/404.html","permalink":"https://guanqi.xyz//404.html","excerpt":"","text":""}],"posts":[{"title":"构建vue应用方法总结","slug":"vue-build-project","date":"2019-08-12T13:54:21.000Z","updated":"2019-08-12T13:53:27.997Z","comments":true,"path":"/note/vue-build-project/","link":"","permalink":"https://guanqi.xyz/note/vue-build-project/","excerpt":"","text":"导语：踏入前端以后，我接触的第二个js框架就是vuejs，第一个jQuery。vuejs的虚拟dom和数据双向绑定，mvvm设计模式都挺吸引我的，还有那模板编译语法，组件化开发以及路由管理、状态管理，组成了一个生态系统。今天这篇主要是介绍如何构建一个vue应用。 构建方法我认为有以下几个比较好的方法。 原生引入vue 如果你不想使用脚手架，可以使用原生方式构建轻量级vue应用。 Vue-cli脚手架 这种是伴随着nodejs的和前端工程化的迅猛发展，还有webpack等构建工具的诞生，有了脚手架开发这一非常便捷的开发方式。 自建脚手架开发 vuejs官方开发的脚手架固然好用，但是仍要了解如何搭建一款自己的webpack脚手架开发工具。 原生引入vue这种方法是属于比较简单的页面开发方式，不需要webpack打包工具，不需要下载很大包，只需要引入必要的css和js即可实现简单项目开发。 引入vuejs，vue-router,vuex 可以本地引入，也可以使用cdn。 推荐几个比较不错的cdn服务网站。 bootcdn 新浪cdn 又拍云cdn cdnjs.net cdnjs.com 七牛云cdn jsdelivr unpkg 在网页的head里面加入以下js。 123456789//本地引入&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"js/vue-router.js\"&gt;&lt;/script&gt;&lt;script src=\"js/vuex.js\"&gt;&lt;/script&gt;//使用cdn(bootcdn)&lt;script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.bootcss.com/vue-router/3.0.7/vue-router.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.bootcss.com/vuex/3.1.1/vuex.min.js\"&gt;&lt;/script&gt; 在body里面写vuejs的模板内容。 123&lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt;&lt;/div&gt; 123456789101112let vm = new Vue(&#123; el: '#app', //vue模板id data: &#123; // 数据对象 title: 'hello, vuejs', //定义的变量 &#125;, methods: &#123; //方法 print () &#123; // some things &#125; &#125; // 。。。&#125;) 我认为这就是一个简单的vue应用，里面是一个vue实例，还可以注册全局和内部组件，多个页面就组成一个简单的站点。如果你想写单页面应用，可以使用vue的路由管理，只写一个页面，然后定义不同的组件，注册到vm的实例里面使用。 Vue-cli脚手架这种方法是比较常用的广泛使用的，下面说一下使用方法，确保你的电脑上一定要装node和npm环境。 安装node和npm 全局安装vue-cli 创建启动vue项目 安装node和npm打开nodejs官网,选择适合你电脑的软件包，下载安装到电脑上。 打开cmd，输入以下命令，有输出版本号即是安装成功。 12345node -vv10.15.3npm -v6.4.1 全局安装vue-cli这里使用3.x版本的脚手架。 12345# 全局安装npm install -g @vue/cli# 查看版本vue -V3.6.3 如果你想使用2.x版本的脚手架，可以这样安装。 12# 安装旧版本npm install -g @vue/cli-init 创建启动vue项目 3.x启动项目 12345678# 使用命令行创建项目vue create myapp# 使用图形界面创建项目vue ui# 启动项目npm run serve# 打包项目npm run build 2.x启动项目 123456# 你熟悉的方法vue init webpack myapp# 启动项目npm run dev# 打包项目npm run build 自建脚手架开发这种方法就比较广泛了，不仅适用于vue，也适用于其他框架，这次使用webpack来进行搭建脚手架。如果你不熟悉webpack，可以读这篇文章了解一下。示例在github上面，可以参考一下。febuild-cli。 初始化项目 安装依赖包 配置文件 启动运行 打包 初始化项目使用npm命令建一个私有包。 12# -y表示一路回车npm init -y 安装依赖包包很多，我就不一一阐述了,这里直接上json文件。复制到你的json文件中，执行npm install安装所有用到的依赖包。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; \"name\": \"my-cli\", \"version\": \"1.0.0\", \"description\": \"my cli\", \"private\": true, \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev:vue\": \"webpack-dev-server --open --config ./build/webpack.config.js\", \"build:vue\": \"webpack --config ./build/webpack.base.js\", &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"@babel/core\": \"^7.4.4\", \"@babel/preset-env\": \"^7.4.4\", \"babel-loader\": \"^8.0.6\", \"clean-webpack-plugin\": \"^2.0.2\", \"css-loader\": \"^2.1.1\", \"csv-loader\": \"^3.0.2\", \"express\": \"^4.16.4\", \"extract-text-webpack-plugin\": \"^3.0.2\", \"file-loader\": \"^3.0.1\", \"html-webpack-plugin\": \"^3.2.0\", \"less-loader\": \"^5.0.0\", \"mini-css-extract-plugin\": \"^0.6.0\", \"node-sass\": \"^4.12.0\", \"postcss-loader\": \"^3.0.0\", \"raw-loader\": \"^2.0.0\", \"sass-loader\": \"^7.1.0\", \"style-loader\": \"^0.23.1\", \"ts-loader\": \"^6.0.0\", \"uglifyjs-webpack-plugin\": \"^2.1.2\", \"webpack\": \"^4.31.0\", \"webpack-cli\": \"^3.3.2\", \"webpack-dev-middleware\": \"^3.6.2\", \"webpack-dev-server\": \"^3.3.1\", \"webpack-merge\": \"^4.2.1\", \"xml-loader\": \"^1.2.1\" &#125;, \"dependencies\": &#123; \"axios\": \"^0.18.0\", \"lodash\": \"^4.17.11\", \"url-loader\": \"^1.1.2\", \"vue\": \"^2.6.10\", \"vue-loader\": \"^15.7.0\", \"vue-router\": \"^3.0.6\", \"vue-style-loader\": \"^4.1.2\", \"vue-template-compiler\": \"^2.6.10\", \"vuex\": \"^3.1.1\" &#125;&#125; 配置文件接着写配置文件，创建三个webpack的配置文件，放在build文件夹下。 基础配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//保存为webpack.common.jsconst path = require('path');const htmlWebpackPlugin = require('html-webpack-plugin');const cleanHtmlPlugin = require('clean-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');const webpack = require('webpack');const VueloaderPlugin = require('vue-loader/lib/plugin')module.exports = &#123; mode: 'development', output: &#123; filename: 'static/js/[name].[hash].js', publicPath: '/' &#125;, module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125; &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: '/', &#125;, &#125;, 'css-loader', ], &#125;, &#123; test: /\\.scss$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: '/', &#125;, &#125;, 'style-loader', 'css-loader', 'sass-loader' ], &#125;, &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ &#123; loader: 'file-loader', options: &#123; limit: 50000, outputPath: 'static/image/', filename: '[name].[ext]', &#125;, &#125;, ] &#125;, &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ &#123; loader: 'file-loader', options: &#123; limit: 50000, filename: 'static/fonts/[name].[ext]', &#125;, &#125;, ] &#125;, &#123; test: /\\.(csv|tsv)$/, use: [ 'csv-loader' ] &#125;, &#123; test: /\\.xml$/, use: [ 'xml-loader' ] &#125;, &#123; test: /\\.vue$/, use: [ 'vue-loader' ] &#125; ] &#125;, plugins: [ new cleanHtmlPlugin(), new htmlWebpackPlugin(&#123; template: './index.html' &#125;), new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin(), new MiniCssExtractPlugin(&#123; filename: 'static/css/[name].[hash].css', chunkFilename: '[id].css', &#125;), new VueloaderPlugin() ],&#125; 开发环境配置文件 1234567891011121314151617181920212223//保存为webpack.base.js// 开发环境配置const path = require('path');const merge = require('webpack-merge');const common =require('./webpack.common.js');const ASSET_PATH = process.env.ASSET_PATH || '/';module.exports = merge(common, &#123; entry: &#123; app: './src/vue/main.js' &#125;, output: &#123; path: path.resolve(__dirname, '../dist'), publicPath: ASSET_PATH &#125;, devtool: 'inline-source-map', devServer: &#123; contentBase: path.join(__dirname, 'dist'), hot: true, compress: true, port: 8090 &#125;&#125;) 生成环境配置文件 12345678910111213141516171819202122232425262728//保存为webpack.config.js// 生产环境配置const path = require('path');const webpack = require('webpack');const merge = require('webpack-merge');const common = require('./webpack.common.js');const uglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin');const ASSET_PATH = process.env.ASSET_PATH || '/febuild-cli/';module.exports = merge(common, &#123; entry: &#123; app: './src/vue/main.js' &#125;, output: &#123; path: path.resolve(__dirname, '../docs'), publicPath: ASSET_PATH &#125;, devtool: 'source-map', plugins: [ new uglifyjsWebpackPlugin(&#123; sourceMap: true &#125;), new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify('production'), 'process.env.ASSET_PATH': JSON.stringify(ASSET_PATH) &#125;) ]&#125;) 启动运行在启动之前，先创建几个文件夹，用来编写vue文件。 目录如下： 1234567+ src + components - hello.vue + router - index.js - App.vue - main.js 运行npm命令启动项目。 1npm run dev:vue 在游览器打开http://localhost:8090或者是http://127.0.0.1:8090，即可访问站点。 打包这个就不仅简单了，直接运行命令npm run build:vue。 安装http服务插件，在游览器打开http://localhost:8090/dist/或者是http://127.0.0.1:8090/dist/，即可访问站点。 写在最后以上就是我日常开发过程中的vue应用搭建方法总结，有欠缺之处，还请各位大佬指正，谢谢，以上项目代码仅供学习交流使用，转载请注明出处。","categories":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/categories/vuejs/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/tags/vuejs/"},{"name":"vue项目","slug":"vue项目","permalink":"https://guanqi.xyz/tags/vue项目/"}]},{"title":"前端跨域知识总结","slug":"front-end-cross-origin","date":"2019-08-12T02:30:21.000Z","updated":"2019-08-12T13:54:23.129Z","comments":true,"path":"/note/front-end-cross-origin/","link":"","permalink":"https://guanqi.xyz/note/front-end-cross-origin/","excerpt":"","text":"导语: 在日常的开发过程中,跨域是一个令人头疼的事情,也在跨域的过程中学到了不少知识,也吃了不少跨域的亏,一直没有时间整理这部分的知识点,现在就我脑海中的跨域知识以及结合开发过程中遇到的坎进行一个系统的总结。 目录 跨域是什么 跨域解决方法 跨域是什么说到跨域,就不得不提游览器的同源安全策略。按照MDN所说，同源策略限制了从同一个源加载的文档或者脚本如何和来自另一个源的文档和脚本等资源进行交互，这是阻止恶意文件程序攻击的一个重要安全机制。 同源就是协议(http\\https),域名（www.taobao.com）和端口号（80，8080）都相同，这才称之为同源，与之相对的皆是不同源，是跨域的范围了。 这里列一个表格来说明一下： 假设这里有一个url为http://www.example.com/a.html, 想要请求以下地址,默认端口为80。 序号 url 是否同源 原因 1 http://www.example.com/b.html 是 协议、域名、端口相同，只是文件路径不同 2 https://www.example.com/c.html 否 协议不同（http\\https） 3 http://store.example.com/c.html 否 子域域名不同(www\\store) 4 http://www.example.com:81/c.html 否 端口不同(80/81) 5 https://shop.example.com:82/c.html 否 协议、域名、端口都不同 注意：有时候w3c的标准到了ie这里就行不通了。所以根据ie游览器的标准，有两个不同点：一是授信范围，也就是高度互信的两个域名，不受同源限制；二是端口不同的两个域名，不受同源限制。 跨域解决方法据我所知，跨域有以下几种方法： jsonp方法，只适用于get请求 CROS，（跨域资源共享协议），适用于各种请求 domain设置，只适用于子域 post Message，适用于父子网页iframe通信 jsonp方法采用这种方法，是由于html标签src属性不受同源限制，下面就封装一个jsonp方法来进行跨域资源请求。 原生方法 12345function jsonp(&#123;url,callback&#125;) &#123; let script = document.createElement('script'); script.src = `$&#123;url&#125;&amp;callback=$&#123;callback&#125;`; document.head.appendChild(script);&#125; 一个简单的案例： 先用node开一个3000端口，作为服务端，启动node server.js。 123456789101112131415161718192021222324// 保存为server.jsconst http = require('http');const url = require('url');const queryString = require('querystring');const data = JSON.stringify(&#123; title: 'hello,jsonp!'&#125;)const server = http.createServer((request, response) =&gt; &#123; let addr = url.parse(request.url); if (addr.pathname == '/jsonp') &#123; let cb = queryString.parse(addr.query).callback; response.writeHead(200, &#123; 'Content-Type': 'application/json;charset=utf-8' &#125;) response.write(cb + '('+ data +')'); &#125; else &#123; response.writeHead(403, &#123; 'Content-Type': 'text/plain;charset=utf-8' &#125;) response.write('403'); &#125; response.end();&#125;)server.listen(3000, () =&gt; &#123; console.log('Server is running on port 3000!');&#125;) 最后请求返回内容。 12345678jsonp(&#123; url: 'http://localhost:3000/jsonp?from=1', callback: 'getData',&#125;)function getData(res) &#123; console.log(res); // &#123;title: \"hello,jsonp!\"&#125;&#125; jquery方法 1234567891011&lt;script src=\"https://unpkg.com/jquery@3.4.1/dist/jquery.js\"&gt;&lt;/script&gt;$(function () &#123; $.ajax(&#123; url: 'http://localhost:3000/jsonp?from=1', type: 'get', dataType: 'jsonp', success: function(res) &#123; console.log(res); // &#123;title: \"hello,jsonp!\"&#125; &#125; &#125;)&#125;) CROSCORS(Cross -Origin Resource Sharing),跨域资源共享，是一个W3C标准，在http的基础上发布的标准协议。 CORS需要游览器和服务器同时支持，解决了游览器的同源限制，使得跨域资源请求得以实现。它有两种请求，一种是简单请求，另外一种是非简单请求。 简单请求 满足以下两个条件就属于简单请求，反之非简单。 1)请求方式是GET、POST、HEAD;2)响应头信息是Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type(只限于application/x-www-form-urlencoded、multipart/form-data、text/plain); 简单请求有三个CORS字段需要加在响应头中，前面部分都是以Access-Control开头： 1.Access-Control-Allow-Origin,这个表示接受哪些域名的请求，如果是*号，那就是任何域名都可以请求；2.Access-Control-Allow-Credentials,这个表示是否允许携带cookie，默认是false,不允许携带； 如果设置为true, 要发送cookie，允许域就必须指定域名方法；客户端http请求必须设置: 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 3.Access-Control-Expose-Headers,这个表示服务器可接受的响应头字段，如果客户端发送过来请求携带的Cache-Control、Content-Language、Content-Type、Expires、Last-Modified,还有自定义请求头字段。 例如：请求一个本地get接口。 本地服务端开启访问限制，打开server.js，输入以下内容：设置允许域名为http://localhost:8089,允许访问请求方式是POST请求。 1234567891011121314151617181920212223242526272829303132333435363738const http = require('http');const url = require('url');const queryString = require('querystring');const data = JSON.stringify(&#123; title: 'hello,jsonp!'&#125;)const dataCors = JSON.stringify(&#123; title: 'hello,cors!'&#125;)const server = http.createServer((request, response) =&gt; &#123; let addr = url.parse(request.url); response.setHeader(\"Access-Control-Allow-Origin\", 'http://localhost:8089'); response.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type\"); response.setHeader(\"Access-Control-Allow-Methods\",\"POST\"); response.setHeader(\"Content-Type\", \"application/json;charset=utf-8\"); if (addr.pathname == '/jsonp') &#123; let cb = queryString.parse(addr.query).callback; response.writeHead(200, &#123; 'Content-Type': 'application/json;charset=utf-8' &#125;) response.write(cb + '('+ data +')'); &#125; else if (addr.pathname == '/test')&#123; if (request.method == 'POST') &#123; response.writeHead(200, &#123; 'Content-Type': 'application/json;charset=utf-8' &#125;) response.write(dataCors); &#125; else &#123; response.writeHead(404, &#123; 'Content-Type': 'text/plain;charset=utf-8' &#125;) &#125; &#125; else &#123; response.writeHead(403, &#123; 'Content-Type': 'text/plain;charset=utf-8' &#125;) response.write('403'); &#125; response.end();&#125;)server.listen(3000, () =&gt; &#123; console.log('Server is running on port 3000!');&#125;) express框架设置如下： 1234567app.all(\"*\", function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-control-Allow-Headers\", \"X-Auth\"); res.header(\"Access-Control-Allow-Methods\", \"GET,POST,DELETE,PUT,OPTIONS,HEAD,FETCH\"); res.header(\"Access-control-max-age\", 60*60*24); //测试通过 next();&#125;) 如果使用get访问http://localhost:3000/test这个接口地址，那么就会报错404。 httpReq这个方法在这篇文章查看。 123456789async function getReqData() &#123; let data = await httpReq(&#123; type: 'get', url: 'http://localhost:3000/test', data: null, &#125;) console.log(data);&#125;getReqData(); cors_get.png cors_get_req 如果是post访问，就会返回正常内容。 123456789async function getReqData() &#123; let data = await httpReq(&#123; type: 'post', url: 'http://localhost:3000/test', data: null, &#125;) console.log(data);&#125;getReqData(); post post 非简单请求 就是除了简单请求的几种方法外，比如说PUT请求、DELETE请求，这种都是要发一个预检请求的，然后服务器允许，才会发送真正的请求。 非简单请求有以下几个字段需要传递： 1.Access-Control-Allow-Methods,值是以逗号分隔，比如：GET,POST,DELETE;2.Access-Control-Allow-Headers,值是默认字段或者自定义字段，例如：X-Auth-Info;3.Access-Control-Allow-Credentials,是否携带cookie信息;4.Access-Control-Max-Age，代表预检请求的有效期限，单位是秒。 例如：以下这个put请求,服务端设置一个put请求接口,这里使用axios来请求。 12345678910111213141516// 设置返回信息const dataUpdate = JSON.stringify(&#123; title: 'update success!'&#125;)// 设置允许response.setHeader(\"Access-Control-Allow-Methods\",\"POST,PUT\");response.setHeader(\"Access-Control-Allow-Credentials\",false);response.setHeader(\"Access-Control-Max-Age\", 60*60*24);if (addr.pathname == '/update')&#123; if (request.method == 'PUT') &#123; response.writeHead(200, &#123; 'Content-Type': 'application/json;charset=utf-8' &#125;) response.write(dataUpdate); &#125; else &#123; response.writeHead(404, &#123; 'Content-Type': 'text/plain;charset=utf-8' &#125;) &#125;&#125; 客户端请求，返回内容。 12345678910&lt;script src=\"https://cdn.bootcss.com/axios/0.19.0/axios.min.js\"&gt;&lt;/script&gt;async function saveInfo () &#123; let data = await axios.put('http://localhost:3000/update', &#123; title: 'far', body: 'bar', userId: 121, &#125;) console.log(data);&#125;saveInfo(); put put domain设置这种方法只适用于子域不同时候的跨域请求，可以使用document.domain来设置。 比如：map.domaintest.org子域名指向根域名domaintest.org，可以使用下面的设置。 123if (document.domain != 'domaintest.org') &#123; document.domain = 'domaintest.org';&#125; 例如: 123456789101112async function saveInfo () &#123; let data = await httpReq(&#123; type: 'get', url: 'http://map.domaintest.org:8089/ky.html', data: null, &#125;) console.log(data);&#125;saveInfo();if (document.domain != 'domaintest.org') &#123; document.domain = 'domaintest.org';&#125; domain domain 看情况，使用谷歌请求，不加这段也可以成功请求到子域的页面内容。 post Message这个post Message可以安全的实现跨源通信，适用于父页面和子页面或是两个不同页面之间的请求，iframe的情况就适合用这个。 父页面通过postMessage(&#39;&lt;msg&gt;&#39;,&#39;&lt;url&gt;&#39;)，子页面接收消息，并且返回消息到父页面，父页面监听message事件接收消息。 例如：http://map.domaintest.org:8089/parent.html发送消息给子页面http://map.domaintest.org:8089/son.html,子页面返回消息。 父页面的： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;父级页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;发送消息&lt;/button&gt; &lt;iframe id=\"child\" src=\"http://map.domaintest.org:8089/son.html\" width=\"100%\" height=\"300\"&gt;&lt;/iframe&gt; &lt;script&gt; let sendBtn = document.querySelector('#btn'); sendBtn.addEventListener('click', sendMsg, false); function sendMsg () &#123; window.frames[0].postMessage('getMsg', 'http://map.domaintest.org:8089/son.html'); &#125; window.addEventListener('message', function (e) &#123; let data = e.data; console.log('接收到的消息是：'+ data); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; parent 子页面的： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;子页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;窗口&lt;/h2&gt; &lt;p&gt;我是另外一个窗口!&lt;/p&gt; &lt;script&gt; window.addEventListener('message', function (e) &#123; if (e.source != window.parent) return; window.parent.postMessage('我是来自子页面的消息!', '*'); &#125;, false) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; son 跨域代理方法补充有时候可以使用代理的方式来发送跨域请求，比如axios的跨域代理，nodejs跨域代理，nginx跨域代理。下面介绍常见的几种跨域代理设置方法。 axios的跨域代理 创建实例建立代理： 12345import axios from 'axios';var server = axios.create(&#123; baseURL: 'https://domain.com/api/', timeout: 1000,&#125;); vue中跨域设置 在config/index.js中设置： 12345678910111213module.exports = &#123; dev: &#123; //... proxyTable: &#123; '/api': &#123; target: 'http://10.0.100.7:8081', //设置调用接口域名和端口号别忘了加http changeOrigin: true, pathRewrite:&#123; \"^/api\":\"\" &#125; &#125; &#125;, &#125; 接口调用时： 123456789this.axios.get('/api/user',&#123; params: &#123; userId:'1' &#125;&#125;).then(function (res) &#123; console.log(res);&#125;).catch(function (err) &#123; console.log(err);&#125;) nodejs跨域代理 按照代理代理包 1npm i -S http-proxy 设置跨域 1234567891011121314151617181920212223242526272829303132333435363738394041424344var http = require('http');var url=require('url');var path=require('path');var httpProxy = require('http-proxy');//服务端口var PORT = 8080;//接口前缀var API_URL='api';//真正的api地址var API_DOMAIN='http://www.example.com/';//创建一个代理服务器var proxy = httpProxy.createProxyServer(&#123; target: API_DOMAIN,&#125;);//代理出错则返回500proxy.on('error', function(err, req, res)&#123; res.writeHead(500, &#123; 'content-type': 'text/plain' &#125;); res.end('server is error!');&#125;);//建立一个本地的servervar server = http.createServer(function (request, response) &#123; var pathname = url.parse(request.url).pathname; var realPath = path.join(\"./\", pathname); var ext = path.extname(realPath); ext = ext ? ext.slice(1) : 'unknown'; //判断如果是接口访问，则通过proxy转发 console.log(pathname); console.log(API_URL); if(pathname.indexOf(API_URL) &gt; 0)&#123; console.log(request.url.substring(4,request.url.length)); request.url=request.url.substring(4,request.url.length) proxy.web(request, response); return; &#125;&#125;);server.listen(PORT);console.log(\"Server runing at port: \" + PORT + \".\"); nginx跨域代理 设置cors 123456789101112131415161718192021location / &#123; if ($request_method = &apos;OPTIONS&apos;) &#123; add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;; add_header &apos;Access-Control-Max-Age&apos; 64800; add_header &apos;Content-Type&apos; &apos;text/plain charset=UTF-8&apos;; add_header &apos;Content-Length&apos; 0; return 204; &#125; if ($request_method = &apos;POST&apos;) &#123; add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;; &#125; if ($request_method = &apos;GET&apos;) &#123; add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;; &#125;&#125; 或者是反向代理 12345678910111213server &#123; listen 80; #监听80端口 server_name localhost; # 当前服务的域名 location / &#123; proxy_pass http://localhost:81; proxy_redirect default; &#125; location /apis &#123; #添加访问目录为/apis的代理配置 rewrite ^/apis/(.*)$ /$1 break; proxy_pass http://localhost:82; &#125;&#125; 写在最后跨域的方法就介绍这么多，还有什么不懂的可以给我留言，我的github，获取更多欢迎访问我的个人博客。","categories":[{"name":"前端跨域","slug":"前端跨域","permalink":"https://guanqi.xyz/categories/前端跨域/"}],"tags":[{"name":"前端跨域","slug":"前端跨域","permalink":"https://guanqi.xyz/tags/前端跨域/"}]},{"title":"Nginx部署vue站点","slug":"nginx-deployment-vue","date":"2019-07-14T13:40:21.000Z","updated":"2019-07-14T10:42:54.757Z","comments":true,"path":"/note/nginx-deployment-vue/","link":"","permalink":"https://guanqi.xyz/note/nginx-deployment-vue/","excerpt":"","text":"导语：本篇讲解如何使用nginx配置vue打包后的文件站点。 准备工作 linux centos7操作系统 ssh软件 nginx node环境 nginx配置vue站点新建nginx配置文件，输入以下内容。 1vi /etc/nginx/vhost/vue.conf 在里面输入： 12345678910111213141516171819server &#123; listen 8080; # 监听端口 server_name localhost vue.example.org; # 访问域名 access_log /var/www/vue/access.log; # 成功日志 error_log /var/www/vue/error.log; # 错误日志 root /var/www/vue; index index.html; location / &#123; try_files $uri $uri/ @router; index index.html; &#125; location @router &#123; rewrite ^.*$ /index.html last; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 打开8080端口。 12firewall-cmd --add-port=8080/tcp --permanentfirewall-cmd --reload 配置完了以后重载重启nginx。 12systemctl reload nginxsystemctl restart nginx 上传文件然后创建一个vue文件，上传文件访问地址，便可以看到输出结果。 创建目录：mkdir /var/www/vue 上传文件: scp -P 8080 dist/* root@192.168.1.123:/var/www/vue scp命令scp命令用于Linux系统之间复制文件和目录。scp是 secure copy的缩写。 -1： 强制scp命令使用协议ssh1-2： 强制scp命令使用协议ssh2-4： 强制scp命令只使用IPv4寻址-6： 强制scp命令只使用IPv6寻址-B： 使用批处理模式（传输过程中不询问传输口令或短语）-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）-p：保留原文件的修改时间，访问时间和访问权限。-q： 不显示传输进度条。-r： 递归复制整个目录。-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，-P port：注意是大写的P, port是指定数据传输用到的端口号-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 预览在本地hosts文件增加解析记录,这里的ip就是你远程服务器的ip地址了。 1192.168.1.123 vue.example.org 打开游览器，输入http://vue.example.org或者访问192.168.1.123:8080就可以看到之前编辑的站点的vue文件内容了。","categories":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/categories/vuejs/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://guanqi.xyz/tags/nginx/"},{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/tags/vuejs/"}]},{"title":"CentOS7系统中node安装配置","slug":"node-installation-and-configuration-in-centos7-system","date":"2019-07-14T12:40:21.000Z","updated":"2019-07-14T10:43:11.628Z","comments":true,"path":"/note/node-installation-and-configuration-in-centos7-system/","link":"","permalink":"https://guanqi.xyz/note/node-installation-and-configuration-in-centos7-system/","excerpt":"","text":"导语：本篇讲解如何配置node开发环境，让你的node代码可以正常的在网页中运行。 准备工作 linux centos7操作系统 ssh软件 nginx node资源想要了解更多关于node的内容，请访问： nodejs官网 安装node本次安装介绍两个版本的安装方法，一个是源码安装,另一个是已编译版本安装， 源码安装 已编译版本安装 源码安装 第一步,到官网查看最新源码，并下载 12cd /home/downloadswget https://nodejs.org/dist/v10.16.0/node-v10.16.0.tar.gz 第二步，解压源码 12tar xzvf node-v10.16.0.tar.gzcd node-v10.16.0 第三步，安装编译软件 1sudo yum install gcc gcc-c++ 第四步，编译安装 123./configuremakesudo make install 大概需要半个小时时间,编译完成查看版本号。 1node --version 如果有显示版本号，说明安装成功。 已编译版本安装 下载已编译版本 12cd /home/downloadswget https://nodejs.org/dist/v10.16.0/node-v10.16.0-linux-x64.tar.xz 解压 12tar -xvf node-v10.16.0-linux-x64.tar.xzmv node-v10.16.0-linux-x64 /home/soft/node10 建立软连接 这样就可以全局使用了。 12ln -s /home/soft/node10/bin/npm /usr/local/bin/ln -s /home/soft/node10/bin/node /usr/local/bin/ 查看版本 12node -vnpm -v 自动化node 安装pm2管理软件 1npm install pm2 -g 全局配置 1ln -s /home/soft/node10/bin/pm2 /usr/local/bin/pm2 pm2常用命令 启动：pm2 start app_name|app_id停止：pm2 stop app_name|app_id删除：pm2 delete app_name|app_id重启：pm2 restart app_name|app_id停止所有：pm2 stop all查看所有的进程：pm2 list查看所有的进程状态：pm2 status查看某一个进程的信息：pm2 describe app_name|app_id nginx配置node环境新建nginx配置文件，输入以下内容。 1vi /etc/nginx/vhost/node.conf 在里面输入： 1234567891011121314151617server &#123; listen 80; # 监听端口 server_name node.example.org; # 访问域名 access_log /var/www/node/access.log; # 成功日志 error_log /var/www/node/error.log; # 错误日志 location / &#123; proxy_pass http://127.0.0.1:3000; &#125; # 静态文件图片规则 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 30d; &#125; # 静态文件js、css规则 location ~ .*\\.(js|css)?$ &#123; expires 1h; &#125;&#125; 打开3000端口。 12firewall-cmd --add-port=3000/tcp --permanentfirewall-cmd --reload 配置完了以后重载重启nginx。 12systemctl reload nginxsystemctl restart nginx 然后创建一个node文件，访问地址，便可以看到输出结果。 创建目录：mkdir /var/www/node 创建文件: vi /var/www/node/app.js 输入以下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 保存为app.js文件// 引入http模块const http = require('http');const port = 3000;const success = &#123; msg: \"get_succ\", code: 201, data: &#123; list: [ &#123;\"id\":1,\"name\": \"alun\"&#125;, &#123;\"id\":2,\"name\": \"mark\"&#125;, &#123;\"id\":3,\"name\": \"jean\"&#125; ] &#125;&#125;const error = &#123; msg: \"get_fail\", code: 101, data: &#123; info: 'this request failed,again try!' &#125;&#125;const authy = &#123; msg: \"no visited!\", code: 403, data: &#123; info: 'not visited!' &#125;&#125;// 建立http服务const serve = http.createServer((req,res) =&gt; &#123; var lawDomainList = \"http://localhost:9925\"; res.setHeader('Content-Type', 'text/plain;charset=utf8'); res.setHeader(\"Access-Control-Allow-Origin\",lawDomainList); if (req.url == '/api') &#123; res.end(JSON.stringify(success)); &#125; else &#123; res.end(JSON.stringify(error)); &#125; res.end(authy);&#125;)// 监听端口serve.listen(port,function()&#123; console.log('serve is running on port 3000!');&#125;) 启动node程序，pm2 start app.js。 预览在本地hosts文件增加解析记录,这里的ip就是你远程服务器的ip地址了。 1192.168.1.123 node.example.org 打开游览器，输入http://node.example.org就可以看到之前编辑的站点的node文件内容了。","categories":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/tags/linux/"},{"name":"node","slug":"node","permalink":"https://guanqi.xyz/tags/node/"}]},{"title":"VSCode常用插件汇总","slug":"vscode-most-plugins","date":"2019-07-14T11:30:21.000Z","updated":"2019-07-14T09:17:58.936Z","comments":true,"path":"/note/vscode-most-plugins/","link":"","permalink":"https://guanqi.xyz/note/vscode-most-plugins/","excerpt":"","text":"导语：这篇博客主要是我使用vscode过程中的插件汇总，使用了这么长时间，总想有个总结，也方便日后查看，这里我将我使用的插件分为基础、框架、工具三个类型。 官网地址VSCode插件官网地址，里面有很多的插件可以使用。 基础插件这部分插件主要是和html、css、js有关的。 html CSS Support这个插件支持以下语言，提供基础的语法知识编写辅助。 这是插件地址 html laravel-blade razor vue pug jade handlebars php twig md nunjucks javascript javascriptreact HTML Snippets这个插件主要是针对html的语法的，支持以下标签，插件地址 html5的全部标签 标签含义信息提示 一些描述性的语法 HTMLHint这个插件提供html的编写提示，包括到属性的格式监测，语法细致监测纠正，非常好的。插件地址 htmlhint stylelint这个插件是有个css，sass,less的语法监测。插件地址 stylelint JavaScript (ES6) code snippets这个插件就是js方面的内容，主要提供以下支持，插件地址 JavaScript (.js) TypeScript (.ts) JavaScript React (.jsx) TypeScript React (.tsx) Html (.html) Vue (.vue) ESLint这个是有关js的语法监测插件，也很棒。插件地址 Latest TypeScript and Javascript Grammar这个插件提供最新的TypeScript和Javascript语法，可以看一下。插件地址 typescript语法支持 JavaScript语法支持 markdownlint这个是提供markdown语法监测的插件，非常好用，帮助你养成良好的markdown编写风格。插件地址 框架插件这部分插件主要是和各个框架有关的插件，比如jquery,bootstrap,vue等ui框架，html模板引擎和js框架。 EJS language support这是一个非常好用的html模板引擎插件，提供ejs的用法。 插件地址 if for 插值 … jQuery Code Snippets虽然jQuery诞生于2006年，距今已有13年历史，但是还是有很多人在使用，所以也推荐一下。插件地址 提供以下方法： jQuery Code Snippets func jqAfter jqAjax jqAjaxAspNetWebService jqAppend jqAppendTo jqAttrGet jqAttrRemove jqAttrSet jqAttrSetFn jqAttrSetObj jqBefore jqBind jqBindWithData jqBlur jqChange … vetur这个是vuejs官方团队的一名成员写的有关vuejs语法的插件，强力推荐。插件地址 Syntax-highlighting Snippet Emmet Linting / Error Checking Formatting Auto Completion Debugging Vue 2 Snippets这个也是vue的语法插件，也作为补充插件。插件地址 Vue 2 Snippets 工具插件这部分插件主要是日常工作过程中的一些工程化编译，构建还有辅助等工具，辅助编程。 Auto Rename Tag这是一款有关html标签的工具，具有自动重命名标签的功能，插件地址 Auto Rename Tag ]### Beautify这是一款代码格式化的插件，可以对你写的代码进行格式调整，使得代码易读，规整，好看。插件地址### cssrem这是一款有关css的px和rem转换的工具插件，方便移动端网页设计稿开发。插件地址 cssrem ]### Document This这是一款给js函数方法添加参数注解的插件。插件地址 Document This ]### filesize这是一款计算每个文件大小的插件，方便你对你的代码量进行可视化观察，及时缩小代码量，提供代码质量。插件地址### JSON Tools这是一款有关json数据格式化的插件，可以压缩和解压格式化json代码。插件地址+ Ctrl(Cmd)+Alt+M,格式化json数据+ Alt+M，压缩json数据### Live Server这是一款可以提供http协议服务的插件，可以使用http进行访问本地网页,而且是实时更新内容。插件地址 Live Server ]### Material Icon Theme这是一款Material主题风格的图标插件，涵盖了大多数文件对应的图标，非常容易识别确认。插件地址 Material Icon Theme ]### Minify这是一款代码压缩插件，可以对html,css,js代码进行压缩，就像webpack打包工具那样压缩你的代码，使代码体积变小，打开速度加快。插件地址默认是压缩以后，生成一个原来名字后加.的文件，里面是压缩后的代码,比如：example.html压缩后的名字变为example.min.html。### npm这个插件主要是用来管理npm包的，可以在编辑器内下载，安装，查询，卸载npm包，非常方便。插件地址 npm open in browser这个插件是在默认游览器打开你的网页，可以预览，但是需要手动刷新内容。插件地址 open in browser Path Intellisense这个插件具有自动补全功能，非常方便。插件地址 Path Intellisense Sass这个插件是一个sass编译工具，方便书写sass代码。插件地址 Sass Sass Lint这个是和sass配套的一个插件，检查sass语法是否正确，插件地址 vscode-fileheader这个插件可以在文档顶部插入一段说明注释，非常便于你查看当日写了哪些内容，插件地址 vscode-fileheader webpack这个插件是一个webpack的辅助工具，可以创建webpack配置文件的，还有babel编译帮助功能,插件地址 webpack ] 最后这就是我日常使用的一些vscode的插件，在此作为一个汇总，方便日后查看。","categories":[{"name":"前端工具","slug":"前端工具","permalink":"https://guanqi.xyz/categories/前端工具/"}],"tags":[{"name":"前端工具","slug":"前端工具","permalink":"https://guanqi.xyz/tags/前端工具/"},{"name":"编辑器","slug":"编辑器","permalink":"https://guanqi.xyz/tags/编辑器/"},{"name":"vscode","slug":"vscode","permalink":"https://guanqi.xyz/tags/vscode/"},{"name":"plugin","slug":"plugin","permalink":"https://guanqi.xyz/tags/plugin/"}]},{"title":"linxu服务器配置免费ssl证书","slug":"linux-server-configuration-free-ssl-certificate","date":"2019-07-01T10:36:21.000Z","updated":"2019-07-14T09:35:10.212Z","comments":true,"path":"/note/linux-server-configuration-free-ssl-certificate/","link":"","permalink":"https://guanqi.xyz/note/linux-server-configuration-free-ssl-certificate/","excerpt":"","text":"导语：之前买过一台阿里云服务器，现在想配置一个ssl证书，现在就收集到的资料进行整理归纳，说一下如何配置一个域名ssl证书。 配置环境准备 一台Linux系统的在线服务器 一个经过dns解析可以正常访问的http协议的网站 配置方法这里主要介绍的是免费ssl证书配置，付费证书请访问以下网站购买。 沃通 亚洲诚信 以上两个比较权威。 下面介绍免费配置方法。 ssl免费证书网 cert包进行配置 ssl证书ssl证书是类似于驾驶证、护照的数字证书，遵守ssl协议，由信任的CA机构验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能。很多网站都启用了ssl证书，来确保他们的网站避免信息被获取盗用。 一般来说，ssl证书分为以下三种： 扩展验证型(EV)SSL证书，迄今为止审核最为严格的证书，不仅验证网站服务器身份，还会通过律师函第三方验证； 组织验证型(OV)SSL证书，针对网站域名和所有权进行严格的审查，强化企业信任度； 域名验证型（DV）SSL证书，只验证网站域名所有权的简易型证书，仅能起到网站信息加密的作用，无法验证网站的所有者真实身份。 ssl免费证书网这个网站主要目的还是宣传普及ssl证书，顺便向大众提供免费的基础的ssl申请使用服务。 申请步骤就是： 点击进入官网,注册账号； 进入首页选择证书，这里提供品牌证书和收费证书； 填写你需要的域名，然后点击创建 这里是具体的申请方法，我就不详细说明了。 申请免费的ssl证书 安装申请通过的ssl证书 linux安装ssl证书这个才是本文重点，主要介绍如何在linux系统的服务器上面免费申请ssl证书，并使用nginx进行配置。 下载安装certbot使用ssh工具登录服务器，然后把安装包下载下来，安装。 123456cd /homewget https://github.com/certbot/certbot/archive/master.zipunzip master.zipcd master./certbot-auto --help./certbot-auto certonly --webroot --agree-tos -v -t --email eg@126.com -w /var/www/eg.com/web -d eg.com 修改nginx配置文件进入/etc/nginx/vhost/,然后打开配置文件，eg.conf，把80端口改成重写到https，增加443端口的配置。 12cd /etc/nginx/vhostvi eg.conf 下面是简单的配置内容： 12345678910111213141516171819202122232425262728293031server &#123; listen 80; server_name eg.com; location / &#123; rewrite (.*) https://eg.com$1 permanent; &#125;&#125;server &#123; listen 443; server_name eg.com; ssl on; root /var/www/eg.com/web; index index.html index.php; ssl_certificate &quot;/etc/letsencrypt/live/eg.com/fullchain.pem&quot;; ssl_certificate_key &quot;/etc/letsencrypt/live/eg.com/privkey.pem&quot;; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / &#123; try_files $uri $uri/ /index.php$is_args$query_string; &#125; location ~ \\.php$ &#123; try_files $uri =404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 重启nginx即可1sudo systemctl restart nginx 这时候打开https://eg.com，你就可以看到小锁，说明配置成功! 证书的更新这种证书一般有效期只有三个月，使用到期要续,到期后发邮件，renew即可。 1/home/certbot-master/certbot-auto renew 傻瓜配置安装ssl证书这种方法下载一个yum包，一键即可配置成功，不需要写配置文件，不需要敲命令和输入邮箱域名名称等信息。 下载包1sudo yum install python2-certbot-nginx 开始配置1sudo certbot --nginx 下面会出现几个选项，选择你要配置的域名序号，然后再输入是否自动配置，然后重启nginx就可以了。 1sudo systemctl restart nginx 续期执行以下命令便可续期 1sudo certbot renew --dry-run 写在最后本篇所讲ssl证书配置只是为了开发测试使用，如果是开展正常商务活动和电商交易以及其他企业贸易活动，请配置正规的付费的证书，会比较好。 有什么不懂的可以留言。","categories":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/tags/linux/"},{"name":"ssl","slug":"ssl","permalink":"https://guanqi.xyz/tags/ssl/"}]},{"title":"在linux中使用vim","slug":"use-vim-in-linux","date":"2019-06-01T01:36:21.000Z","updated":"2019-07-14T07:02:48.700Z","comments":true,"path":"/note/use-vim-in-linux/","link":"","permalink":"https://guanqi.xyz/note/use-vim-in-linux/","excerpt":"","text":"导语:vim是Linux系统中的一个文本编辑器，类似于vscode，记事本等编辑器；是从vi发展继承过来的，是一款广受Linux程序员欢迎的工具。今天，我就一探究竟，揭开vim的神秘面纱。 目录 环境准备 安装vim 常用语法 实战演练 环境准备 centos7 可以联网 putty或xshell 安装vim要想富，先修路，要想使用vim，先安装包，这是 vim官网。 开始安装vim： 检查本机是否安装好vim 1rpm -qa | grep vim //查看vim命令的软件包 检测vim 安装相关软件包 1yum install -y vim* 查看vim 常用语法下面这幅图片是一个经典的vim命令图。 vim命令图 命令模式vim有三种模式： 命令模式，就是使用vim启动一个文件；可以按下i/a/o进入输入模式。 输入模式，就是可以编辑文件内容，可以Esc退出输入模式到命令模式。 底线命令模式，就是按下冒号(英文):进入底线命令模式。 命令大全下面是常用的一些命令：包括光标移动、复制、粘贴和搜索、替换、切换模式等命令。 序号 类型 方法 说明 1 移动光标 h 或 向左箭头键(←) 光标向左移动一个字符 2 移动光标 j 或 向下箭头键(↓) 光标向下移动一个字符 3 移动光标 k 或 向上箭头键(↑) 光标向上移动一个字符 4 移动光标 l 或 向右箭头键(→) 光标向右移动一个字符 5 移动光标 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) 6 移动光标 [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) 7 移动光标 [Ctrl] + [d] 屏幕『向下』移动半页 8 移动光标 [Ctrl] + [u] 屏幕『向上』移动半页 9 移动光标 + 光标移动到非空格符的下一行 10 移动光标 - 光标移动到非空格符的上一行 11 移动光标 n&lt;space&gt; 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20&lt;space&gt; 则光标会向后面移动 20 个字符距离。 12 移动光标 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) 13 移动光标 $ 或功能键[End] 移动到这一行的最后面字符处(常用) 14 移动光标 H 光标移动到这个屏幕的最上方那一行的第一个字符 15 移动光标 M 光标移动到这个屏幕的中央那一行的第一个字符 16 移动光标 L 光标移动到这个屏幕的最下方那一行的第一个字符 17 移动光标 G 移动到这个档案的最后一行(常用) 18 移动光标 nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) 19 移动光标 gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) 20 移动光标 n&lt;Enter&gt; n 为数字。光标向下移动 n 行(常用) 21 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) 22 搜索替换 ?word 向光标之上寻找一个字符串名称为 word 的字符串。 23 搜索替换 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ 24 搜索替换 N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 25 搜索替换 :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s/vbird/VBIRD/g』。(常用) 26 搜索替换 :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) 27 搜索替换 :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) 28 删除、复制与粘贴 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) 29 删除、复制与粘贴 nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 30 删除、复制与粘贴 dd 删除游标所在的那一整行(常用) 31 删除、复制与粘贴 ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) 32 删除、复制与粘贴 d1G 删除光标所在到第一行的所有数据 33 删除、复制与粘贴 dG 删除光标所在到最后一行的所有数据 34 删除、复制与粘贴 d$ 删除游标所在处，到该行的最后一个字符 35 删除、复制与粘贴 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 36 删除、复制与粘贴 yy 复制游标所在的那一行(常用) 37 删除、复制与粘贴 nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) 38 删除、复制与粘贴 y1G 复制游标所在行到第一行的所有数据 39 删除、复制与粘贴 yG 复制游标所在行到最后一行的所有数据 40 删除、复制与粘贴 y0 复制光标所在的那个字符到该行行首的所有数据 41 删除、复制与粘贴 y$ 复制光标所在的那个字符到该行行尾的所有数据 42 删除、复制与粘贴 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) 43 删除、复制与粘贴 J 将光标所在行与下一行的数据结合成同一行 44 删除、复制与粘贴 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] 45 删除、复制与粘贴 u 复原前一个动作。(常用) 46 删除、复制与粘贴 [Ctrl]+r 重做上一个动作。(常用) 47 删除、复制与粘贴 . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) 48 切换模式 i, I 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用) 49 切换模式 a, A 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) 50 切换模式 o, O 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！(常用) 51 切换模式 r, R 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) 52 切换模式 [Esc] 退出编辑模式，回到一般模式中(常用) 53 储存、离开 :w 将编辑的数据写入硬盘档案中(常用) 54 储存、离开 :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ 55 储存、离开 :q 离开 vi (常用) 56 储存、离开 :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 57 储存、离开 :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) 58 储存、离开 ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ 59 储存、离开 :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） 60 储存、离开 :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 61 储存、离开 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 62 储存、离开 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ 63 环境变更 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 64 环境变更 :set nonu 与 set nu 相反，为取消行号！ 注意:数字通常代表重复做几次的意，也有代表去到第几个的意思。 实战演练学以致用，经过上面的学习，应该或多或少对这个vim工具的命令使用有了了解，下面就是实战演练。 现在，我创建一个名为gqxyz的文本文件，并且切换模式输入内容，然后保存退出。 进入创建文件打开putty或者xshell，在命令行输入vim gqxyz.txt，便创建并且进入了文件，输入i进入编辑模式。 创建进入vim 输入内容按下Insert插入内容。 编辑保存vim 保存内容按下Esc，输入冒号:，输入wq，保存编辑内容并且退出。 vim的学习就到这里了，以上的内容要勤加练习，方能成功掌握vim工具的使用。","categories":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/tags/linux/"},{"name":"vim","slug":"vim","permalink":"https://guanqi.xyz/tags/vim/"}]},{"title":"Vue基础教程之组件开发","slug":"vue-basic-tutorial-components","date":"2019-05-30T13:54:21.000Z","updated":"2019-07-14T07:00:39.817Z","comments":true,"path":"/note/vue-basic-tutorial-components/","link":"","permalink":"https://guanqi.xyz/note/vue-basic-tutorial-components/","excerpt":"","text":"导语：今天给大家讲解vue的组件化开发知识，本文参考vue的部分文档知识。 目录 组件命名 全局组件 局部组件 父子组件通信 组件命名每一个组件都代表不同的含义，有着不同的功能，比如说注册组件就是专门用来做用户注册时候使用的，分页组件就是专门用作表格列表分页使用。所以不同功能的组件都有不同的名字，组件的命名一般有以下两个方法。 短横线命名法kebab-case，这是官方推荐的方法，也就是两个单词之间使用短横线连接起来。 例如： 1Vue.component('my-page', &#123; /*...*/ &#125;) 小驼峰命名法PascalCase，顾名思义，就是首字母大小，但是直接在DOM(非字符串的模板中)使用时只有短横线命名法的组件是有效的。 例如： 1Vue.component('MyPage', &#123; /*...*/ &#125;) 全局注册全局注册的组件在任何vue实例的模板中都可以使用，在子组件也是这样。 例如：我这里创建一个全局组件component-a。 1234Vue.component('my-page', &#123; /*...*/ &#125;)new Vue(&#123; el: '#app',&#125;) 在html模板中就可以使用了。 123&lt;div id=\"app\"&gt; &lt;my-page&gt;&lt;/my-page&gt;&lt;/div&gt; 局部注册局部注册，就是只能在一个Vue实例中使用，不能在其他Vue实例中使用。 例如：js创建一个局部注册组件。 1234567var MyPage = &#123; /**/ &#125;new Vue(&#123; el: '#app', components: &#123; 'my-page': MyPage, &#125;&#125;) 在html模板中就可以使用了。 123&lt;div id=\"app\"&gt; &lt;my-page&gt;&lt;/my-page&gt;&lt;/div&gt; 这样就可以非常灵活，不会增加无谓的消耗增加js。 父子组件通信当我们注册好了组件后，就要学会进行父子组件通信，传递消息。 首先，我们先创建一个子组件my-post 123456789101112var MyPost = Vue.component('my-post', &#123; props: &#123; post: Object, &#125;, template: ` &lt;div class=\"post\"&gt; &lt;h2 class=\"post-title\"&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt; &lt;p class=\"post-content\"&gt;&#123;&#123; post.content &#125;&#125;&lt;/p&gt; &lt;a class=\"post-link\" href=\"#\"&gt;&#123;&#123; post.link &#125;&#125;&lt;/a&gt; &lt;/div&gt; `&#125;) 接着注册到Vue实例 12345678910111213new Vue(&#123; el: '#app', data: &#123; post: &#123; title: '文章标题', content: '文章内容', link: '#1' &#125; &#125;, components: &#123; 'my-post': MyPost, &#125;&#125;) 最后在模板里面使用 123&lt;div id=\"app\"&gt; &lt;my-post :post=\"post\"&gt;&lt;/my-post&gt;&lt;/div&gt; 最后Vue组件的一些常用知识就介绍到这里，下次再会。","categories":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/categories/vuejs/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/tags/vuejs/"},{"name":"vue基础","slug":"vue基础","permalink":"https://guanqi.xyz/tags/vue基础/"},{"name":"组件","slug":"组件","permalink":"https://guanqi.xyz/tags/组件/"}]},{"title":"CentOS7系统配置gitlab","slug":"centos7-system-configuration-gitlab","date":"2019-05-08T12:55:21.000Z","updated":"2019-07-14T08:43:36.427Z","comments":true,"path":"/note/centos7-system-configuration-gitlab/","link":"","permalink":"https://guanqi.xyz/note/centos7-system-configuration-gitlab/","excerpt":"","text":"导语：今天介绍的是如何在Linux CentOS7系统中配置gitlab。记得我在工作过程中使用过别的公司搭建的内部代码平台，也是用的gitlab，所以我既然学了这个linux，自然要学会配置搭建一个gitlab平台，这是一件非常有意义的事情。 目录 环境准备 安装步骤 基本设置 网站预览 环境准备 linux centos7系统 ssh软件 nginx服务器 mysql数据库 安装步骤gitlab官网安装 安装前，请使用xshell连接远程服务器。 这次使用yum进行下载安装。 进入下载文件夹。 这里是你存放下载包的地方。 1cd /home/downloads 第一步：安装依赖 12345sudo yum install -y curl policycoreutils-python openssh-serversudo systemctl enable sshdsudo systemctl start sshdsudo firewall-cmd --permanent --add-service=httpsudo systemctl reload firewalld 如果你想支持邮件发送，请安装以下包： 123sudo yum install postfixsudo systemctl enable postfixsudo systemctl start postfix 第二步：安装gitlab包，ee是商业版，需付费；ce是社区版免费。 这里主要是体验，所以安装社区版即可。 12curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bashsudo yum install -y gitlab-ce 基本设置 首先，修改默认url。 找到external_url修改为你需要的地址，我这里是git.example.com。 12sudo vi /etc/gitlab/gitlab.rbexternal_url 'git.example.com' 其次，重新启动。 1sudo gitlab-ctl reconfigure 网站预览在本地hosts文件中加入一条dns记录。 1192.168.1.123 git.example.com; 接下来在游览器输入git.example.com,就可以访问了。 我的gitlab 这是我写的一个demo仓库，并且上传至我搭建的gitlab平台。 我的gitlab 写在最后非常激动人心的一刻，操练起来。","categories":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/tags/linux/"},{"name":"gitlab","slug":"gitlab","permalink":"https://guanqi.xyz/tags/gitlab/"}]},{"title":"Node发布命令","slug":"npm-release-command","date":"2019-05-01T14:27:21.000Z","updated":"2019-07-14T08:39:35.500Z","comments":true,"path":"/note/npm-release-command/","link":"","permalink":"https://guanqi.xyz/note/npm-release-command/","excerpt":"","text":"导语：之前说的是如何下载、更新、卸载npm包，今天说一下如何发布自己的npm包到npm的平台上，让别人可以作为项目的依赖包来下载安装和使用。本次使用一个拖拽的案例来演示如何操作。 目录 初始化npm 登录npm 发布包 更新包 删除包 初始化npm包在初始化之前一定要安装node环境，然后到npm官网查看包名是否存在，如果存在则换一个。这次我使用g-drag来作为本次包名，你也在本地写一个通用的方法作为一个单独的包。 开始初始化npm init 会生成一个packagejson的文件，项目的配置信息。 1npm init 1234567891011121314151617&#123; \"name\": \"g-drag\", //包名 \"version\": \"1.0.0\", //版本号 \"description\": \"this is a grag elem package!\", //描述 \"main\": \"src/index.js\", //入口文件 \"directories\": &#123; \"example\": \"example\" &#125;, \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [ \"grag\" ], \"author\": \"gitguanqi\", \"license\": \"ISC\"&#125; 到这里初始化就完成了。 登录npm接着就是到官网注册一个账号登录。 1npm login 输入用户名和密码，即可登录成功。一定要设置为国外的npm源， 1npm config set registry https://registry.npmjs.org/ 这样就登录了。 123456Username: XXXnpm WARN Name may not contain non-url-safe charsUsername: (XXX) XXXPassword: XXXEmail: (this IS public) XXXLogged in as XXX on https://registry.npmjs.org/. 发布包接着我们发布自己的包。 12345678910111213141516npm publishnpm noticenpm notice package: g-drag@1.0.0npm notice === Tarball Contents ===npm notice 324B package.jsonnpm notice 1.4kB src/index.jsnpm notice === Tarball Details ===npm notice name: g-dragnpm notice version: 1.0.0npm notice package size: 757 Bnpm notice unpacked size: 1.7 kBnpm notice shasum: 3f1b5ca4746b4be1fd42285fbf62d9683a7757bcnpm notice integrity: sha512-ClYLLs51O7jSw[...]6tjR0e+5c16aw==npm notice total files: 2npm notice+ g-drag@1.0.0 到这里就发布完成。 可以运行npm view &lt;包名&gt; version查看包信息。 1npm view g-drag version 可以试着运行npm install g-drag --save安装依赖了。 更新包更新包分为三个版本。 第一个版本是补丁修复，可以使用npm version patch,例如从0.0.1到0.0.2； 第二个版本是新功能，可以使用npm version minor,例如从0.2.1到0.4.2； 第三个版本是重大更新，可以使用npm version major,例如从1.2.1到2.4.2； 删除包可以使用npm unpublish &lt;包名&gt; –force,或者npm deprecate &lt;包名&gt; 写在最后心动不如行动，快练习一下巩固知识。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/tags/nodejs/"},{"name":"node命令","slug":"node命令","permalink":"https://guanqi.xyz/tags/node命令/"}]},{"title":"react学习总结","slug":"learning-react-tutorial","date":"2019-04-19T06:16:21.000Z","updated":"2019-07-14T09:00:43.068Z","comments":true,"path":"/note/learning-react-tutorial/","link":"","permalink":"https://guanqi.xyz/note/learning-react-tutorial/","excerpt":"","text":"导语：最近react非常火，所以我就简单跟着学了几个简单的知识点，在这里做一个学习总结。网址收藏：React官网，React的Github，React的中文文档 react是什么React起源于Facebook的内部项目，因为该公司对市场上所有的Javascript MVC框架都不满意，决定自己写一套，用来架设Instargm的网站。做完以后，发现很好用，就在2013年5月开源。 安装react 全局安装react脚手架工具npm install create-react-app -g 安装阮一峰老师的教程 git clone git@github.com:ruanyf/react-demos.git下载下来 react特性重点：组件，状态核心： 状态 语法html模板123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!-- 这是核心js --&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;!-- 这是处理虚拟dom相关的js --&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;!-- 这是把JSX语法转换为js语法 （注意：JSX就是可以把html写在js里面。） --&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; &lt;!-- 这里加type就是告诉游览器，这里使用的是JSX语法模板。 --&gt; &lt;script type=\"text/babel\"&gt; //这里写 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ReactDOM.render() React最基本的方法，用于把模板转换成html语言，并且插入指定的节点。 例如： 1234ReactDOM.render( &lt;h2&gt;Welcome to React World!&lt;/h2&gt;, document.getElementById('myapp')) JSX语法 JSX是可以在js中写html，遇到html标签（例如：&lt;）就用html解析，遇到代码块（例如：{）就用javascript规则解析。 例如： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; &lt;div id=\"food\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var names = ['Alice', 'Emily', 'Kate']; var foods = ['meal','sala','milk']; ReactDOM.render( &lt;div&gt; &#123; names.map(function (name, index) &#123; return &lt;div key=&#123;index&#125;&gt;Hello, &#123;name&#125;!&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example') ); ReactDOM.render( &lt;div&gt; &#123; foods.map(function (food, index) &#123; return &lt;div key=&#123;index&#125;&gt;I like eat &#123;food&#125;!&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('food') ) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 组件 React.createClass() React允许将代码封装成组件(component)，然后把它当成html标签插入到网页中。React.createClass()就是可以创建一个组建类。 例如： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"foods\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var LikeFood = React.createClass(&#123; //创建组件类 render: function() &#123; return &lt;p&gt;I like eat &lt;mark&gt;&#123;this.props.name&#125;&lt;/mark&gt;&lt;/p&gt;; &#125; &#125;); ReactDOM.render( &lt;LikeFood name=\"Apple\"/&gt;, document.getElementById('foods') ) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; this.props.children this.props对象的属性与组件的属性基本上是一致的，特殊在于this.props.children属性，它表示组件的所有子节点。 注意： this.props.children有三个可能，如果当前组件没有子节点，就是显示undefined;如果有一个子节点，数据类型就是object；如果有多个子节点，就是array，所以要小心。但React提供了一个方法遍历所有子节点，React.Children,通过this.props.children来遍历。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"foods\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var FoodList = React.createClass(&#123; render: function() &#123; return ( &lt;ul&gt; &#123; React.Children.map(this.props.children,function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ul&gt; ) &#125; &#125;) ReactDOM.render( &lt;FoodList&gt; &lt;span&gt;Hello,&lt;/span&gt; &lt;span&gt;I like eat&lt;/span&gt; &lt;span&gt;Apple!&lt;/span&gt; &lt;/FoodList&gt;, document.getElementById('foods') ) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; PropTypes 组件的属性可以接受任何值，如字符串，数字，数组，对象，函数，但是需要一种机制来验证使用组件提供的参数是否符合要求，PropTypes就是用来验证这个的。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"foods\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var str = 123; var MyNum = React.createClass(&#123; propTypes: &#123; num: React.PropTypes.number.isRequired, &#125;, render: function() &#123; return &lt;h2&gt;&#123;this.props.num&#125;&lt;/h2&gt; &#125; &#125;); ReactDOM.render( &lt;MyNum num=&#123;str&#125; /&gt;, document.getElementById('foods') ) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 补充： 还可以添加默认值。’ 12345getDefaultProps: function() &#123; return &#123; num: 1818 &#125;&#125; 例如： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"foods\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var str; var MyNum = React.createClass(&#123; getDefaultProps: function() &#123; return &#123; num: 1818 &#125; &#125; propTypes: &#123; num: React.PropTypes.number.isRequired, &#125;, render: function() &#123; return &lt;h2&gt;&#123;this.props.num&#125;&lt;/h2&gt; &#125; &#125;); ReactDOM.render( &lt;MyNum num=&#123;str&#125; /&gt;, document.getElementById('foods') ) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 获取真实的DOM节点 组件并不是真的dom节点，只是存在内存中的数据结构，叫做虚拟DOM(virtual)。当它插入到文档以后，才会变成真实的DOM。 所有的DOM变动，先是在虚拟DOM上发生变动，然后再在实际发生变动的部分，反映在真实的DOM，这种叫做DOM diff,它可以极大提高网页的性能表现。 有时需要从组件获取真实的DOM的节点，这个时候就要用到ref属性。 注意： React还支持许多事件，更多请访问事件。 例如： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"foods\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var MyFoods = React.createClass(&#123; showContent: function() &#123; this.refs.myFoodInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type=\"text\" ref=\"myFoodInput\" /&gt; &lt;input type=\"button\" value=\"自动聚焦\" onClick=&#123;this.showContent&#125; /&gt; &lt;/div&gt; ) &#125; &#125;) ReactDOM.render( &lt;MyFoods /&gt;, document.getElementById('foods') ) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; this.state 组件免不了要和用户互动，React的一大创新就是把组件看成是一个状态机，一开始有个初始状态，然后用户互动，导致状态变化，从而重新出发渲染UI。 注意： getInitialState 方法用于定义初始状态，但同时它是一个对象，这个可以通过this.state属性读取。 当用户点击组件，导致状态发生变化，this.setState 方法就会修改状态值，每次修改完，会自动调用this.render方法，再次渲染组件。 this.props和this.state都是描述组件的特性，但是不同的是this.props是指一旦定义好了，就不再发生变化的特性，而this.state是会随着用户互动而产生变化的特性。 例如： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"foods\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var FoodButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;food: false&#125;; &#125;, callClick: function(event) &#123; this.setState(&#123;food: !this.state.food&#125;); &#125;, render: function() &#123; var text1 = this.state.food ? 'like eat apple' : 'hate eat apple'; return ( &lt;p onClick=&#123;this.callClick&#125;&gt; You &#123;text1&#125;! &lt;/p&gt; ); &#125; &#125;); ReactDOM.render( &lt;FoodButton /&gt;, document.getElementById('foods') ) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 表单 用户在表单填入的内容，属于用户和组件之间的互动，所以不能用this.state，而要定义一个onChange事件的回调函数，通过event.target.value读取用户的值。 注意：textarea,select,radio都属于这种情况。 例如： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"food\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var Food = React.createClass(&#123; getInitialState: function() &#123; return &#123;val: 'Welcome to React!'&#125;; &#125;, hanChange: function(event) &#123; this.setState(&#123;val:event.target.value&#125;); &#125;, render: function() &#123; var val = this.state.val; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;val&#125; onChange=&#123;this.hanChange&#125; /&gt; &lt;p&gt;&#123;val&#125;&lt;/p&gt; &lt;/div&gt; ); &#125; &#125;) ReactDOM.render(&lt;Food /&gt;,document.getElementById('food')) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 组件的生命周期 React中组件的生命周期分为三个状态，Mounting 是已经插入真实DOM，Updating 是正在被重新渲染，Unmounting 是已移出真实DOM。 每个状态都有两种处理函数，will 函数是进入状态之前，did 函数是进入状态之后，三种状态共计五种函数。 注意：组件的样式style不能写成 12&lt;div style=&#123;opacity: this.state.opacity&#125;&gt;&lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; 因为React组件样式是个对象，所以第一个大括号表示Javascript语法，第二个大括号表示样式对象。 五种函数: componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentWillUpdate(object prevState, object prevState) componentWillUnMount() 例如：第二种，在已插入真实DOM之后触发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"food\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var Food = React.createClass(&#123; getInitialState: function() &#123; return &#123; opacity: 0 &#125; &#125;, componentDidMount: function() &#123; this.timer = setInterval(function() &#123; var opacity = this.state.opacity; opacity += .05; if (opacity &gt; 1) &#123; opacity = 0; &#125; this.setState(&#123; opacity: opacity &#125;) &#125;.bind(this),100); &#125;, render: function() &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello, &#123;this.props.title&#125; &lt;/div&gt; ); &#125; &#125;); ReactDOM.render( &lt;Food title=\"apple\"/&gt;, document.getElementById('food') ) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Ajax的使用 组件的数据来源一般都是通过Ajax请求从服务器获取，可以使用componentDidMount()方法设置Ajax请求，等到请求成功，再用this.setState方法重新渲染UI。 例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"food\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var ClientGits = React.createClass(&#123; getInitialState: function() &#123; return &#123; id: '', addr: '' &#125;; &#125;, componentDidMount: function() &#123; $.get(this.props.source,function (result) &#123; var gits = result[0]; this.setState(&#123; id: gits.id, addr: gits.git_pull_url &#125;); &#125;.bind(this)); &#125;, render: function() &#123; return ( &lt;div&gt; UserId is &lt;a href='#userId'&gt;&#123;this.state.id&#125;&lt;/a&gt;, Git Address is &lt;a href=&#123;this.state.addr&#125;&gt;&#123;this.state.addr&#125;&lt;/a&gt;! &lt;/div&gt; ); &#125; &#125;); ReactDOM.render( &lt;ClientGits source=\"https://api.github.com/users/octocat/gists\" /&gt;, document.getElementById('food') ) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意： 上面采用了jquery的Ajax，还可以采用其他的库。我们甚至可以把Promise对象传入组件。 例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"projects\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var Projects = React.createClass(&#123; getInitialState: function() &#123; return &#123; loading: true, error: null, data: null &#125;; &#125;, componentDidMount() &#123; this.props.promise.then( value =&gt; this.setState(&#123;loading: false, data: value&#125;), error =&gt; this.setState(&#123;loading: false, error: error&#125;) ) &#125;, render: function() &#123; if (this.state.loading) &#123; return &lt;span&gt;Loading...&lt;/span&gt;; &#125; else if (this.state.error != null) &#123; return &lt;span&gt;Error:&#123;this.state.error.message&#125;&lt;/span&gt;; &#125; else &#123; var res = this.state.data.items; var resList = res.map(function (res,index) &#123; return ( &lt;li key=&#123;index&#125;&gt;&lt;a href=&#123;res.html_url&#125; target=\"_blank\"&gt;&#123;res.name&#125;&lt;/a&gt;(&#123;res.stargazers_count&#125; stars)&lt;br/&gt;&#123;res.description&#125;&lt;/li&gt; ); &#125;); return ( &lt;main&gt; &lt;h1&gt;Github上最受欢迎的JS项目&lt;/h1&gt; &lt;ul&gt;&#123;resList&#125;&lt;/ul&gt; &lt;/main&gt; ); &#125; &#125; &#125;); ReactDOM.render( &lt;Projects promise=&#123;$.getJSON('https://api.github.com/search/repositories?q=javascript&amp;sort=stars')&#125; /&gt;, document.getElementById('projects') ) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 以后还会总结一些有关react的知识点。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/tags/javascript/"},{"name":"react","slug":"react","permalink":"https://guanqi.xyz/tags/react/"}]},{"title":"CentOS7系统配置phpMyAdmin","slug":"centos7-system-configuration-phpmyadmin","date":"2019-04-01T09:46:21.000Z","updated":"2019-07-14T08:37:57.752Z","comments":true,"path":"/note/centos7-system-configuration-phpmyadmin/","link":"","permalink":"https://guanqi.xyz/note/centos7-system-configuration-phpmyadmin/","excerpt":"","text":"导语：今天介绍的是如何在Linux CentOS7系统中配置phpMyAdmin。 目录 环境准备 安装包 基本设置 网站预览 环境准备 linux centos7系统 ssh软件 php语言环境 mysql数据库 安装包phpMyAdmin官网下载 安装前，请使用xshell连接远程服务器。 这次使用wget进行下载安装。 首先，进入下载文件夹。 这里是你存放下载包的地方。 1cd /home/downloads 其次，下载phpMyAdmin包。 如果没有wget安装可以下载yum install wget 1wget https://files.phpmyadmin.net/phpMyAdmin/4.8.5/phpMyAdmin-4.8.5-all-languages.zip 最后，解压安装包。 如果没有zip安装可以下载yum install zip unzip 1unzip phpMyAdmin-4.8.5-all-languages.zip 基本设置 移动解压后的安装包到指定的文件夹中。 12mv phpMyAdmin-4.8.5-all-languages /usr/share/nginx/html/myadmcd /usr/share/nginx/html/myadm 配置nginx站点 1vi /etc/nginx/vhost/pam.conf 1234567891011121314151617181920server &#123; listen 80; server_name phpmyadmin.guan.org; access_log /var/log/nginx/phpmyadmin-access.log main; error_log /var/log/nginx/phpmyadmin-error.log; location / &#123; root /usr/share/nginx/html/myadm; index index.php; &#125; location ~ \\.php$ &#123; root /usr/share/nginx/html/myadm; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/share/nginx/html/myadm/$fastcgi_script_name; include fastcgi_params; &#125; location ~ /\\.ht &#123; deny all; &#125;&#125; 网站预览在本地hosts文件中加入一条dns记录。 1192.168.1.123 phpmyadmin.example.org; 接下来在游览器输入phpmyadmin.example.org,就可以访问了。 写在最后这是最基础的准备,就到这里吧。","categories":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/tags/linux/"},{"name":"phpmyadmin","slug":"phpmyadmin","permalink":"https://guanqi.xyz/tags/phpmyadmin/"}]},{"title":"CentOS7系统中php安装配置","slug":"php-installation-and-configuration-in-centos7-system","date":"2019-03-26T08:40:21.000Z","updated":"2019-07-14T08:33:45.435Z","comments":true,"path":"/note/php-installation-and-configuration-in-centos7-system/","link":"","permalink":"https://guanqi.xyz/note/php-installation-and-configuration-in-centos7-system/","excerpt":"","text":"导语：本篇讲解如何配置php开发环境，让你的php代码可以正常的在网页中运行。 准备工作 linux centos7操作系统 ssh软件 nginx php资源想要了解更多关于php的内容，请访问： php官网 安装php本次安装介绍两个版本的安装方法，一个是广泛应用的5.x,另一个是最新版的7.2。 安装php5.4+ 安装php7.2 安装php5.x第一步,使用yum安装php。 1yum install php 第二步，安装php的相关模块。 1yum install php-mysql php-fpm php-cli php-dba php-embedded php-gd php-common php-bcmatch php-enchant php-devel 第三步，打印php版本。 1php -v 如果有显示版本号，说明安装成功。 安装最新版php7.2安装之前，如果你的系统还有php旧版本，请卸载，避免发生冲突。 卸载方法：yum -y remove php* 由于yum没有php7.2，所以需要额外配置php7.2版本,方法如下: 12rpm -Uvh https://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/e/epel-release-7-11.noarch.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 开始安装php7.2版本 1yum -y install php72w php72w-cli php72w-fpm php72w-common php72w-devel php72w-embedded php72w-gd php72w-mbstring php72w-mysqlnd php72w-opcache php72w-pdo php72w-xml php-fpm是php的一个php的fast-cgi服务管理器，专门用于控制php-cgi的fastcgi进程。 所以我们开始启动php-fpm服务。 12systemctl start php-fpmsystemctl enable php-fpm 最后运行php -v就可以查看版本号了。 nginx配置php环境打开nginx配置文件，输入以下内容。 1vi /etc/nginx/nginx.conf 在配置文件里面找到http { }，在里面输入： 123456789101112131415161718192021222324252627282930313233# fastcgi conffastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; # php配置server &#123; listen 80; # 监听端口 server_name www.example.org; # 访问域名 access_log /var/www/eg/access.log; # 成功日志 error_log /var/www/eg/access.log; # 错误日志 root /var/www/eg; # 根目录 index index.html index.htm index.php; # 首页文件格式 # php解析配置 location ~ .*\\.(php|php5)?$ &#123; root /var/www/html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/eg$fastcgi_script_name; include fastcgi_params; &#125; # 静态文件图片规则 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 30d; &#125; # 静态文件js、css规则 location ~ .*\\.(js|css)?$ &#123; expires 1h; &#125;&#125; 配置完了以后重载重启nginx。 12systemctl reload nginxsystemctl restart nginx 然后创建一个php文件，访问地址，便可以看到输出结果。 创建目录：mkdir /var/www/eg 创建文件: vi /var/www/eg/info.php 输入以下内容： 1234&lt;?php echo \"hello,world！\"; phpinfo();?&gt; 预览在本地hosts文件增加解析记录,这里的ip就是你远程服务器的ip地址了。 1192.168.1.123 www.example.org 打开游览器，输入http://www.example.org/info.php就可以看到之前编辑的站点的php文件内容了。","categories":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/tags/linux/"},{"name":"php","slug":"php","permalink":"https://guanqi.xyz/tags/php/"}]},{"title":"CentOS7系统配置nginx服务器","slug":"centos7-system-configuration-nginx-server","date":"2019-03-26T08:36:21.000Z","updated":"2019-07-14T10:41:45.587Z","comments":true,"path":"/note/centos7-system-configuration-nginx-server/","link":"","permalink":"https://guanqi.xyz/note/centos7-system-configuration-nginx-server/","excerpt":"","text":"导语：作为一个以服务器为主要市场的操作系统，主要就是对客户端的请求进行响应，进行处理的。在经历过系统镜像安装和本地配置好ssh功能后，接下来进行服务器的安装，这里我以nginx为主，介绍一下如何安装nginx和配置站点， 安装要求 linux centos7系统 ssh软件 nginx简介nginx官网 nginx作者是伊戈尔·赛索耶夫，最初是为一个俄罗斯访问量第二大的网站开发的服务器。 nginx主要是有以下几个功能： 免费开源的服务器 轻量级的服务器，安装包只有几百KB 高性能的web服务器 反向代理服务器 负载均衡 电子邮件代理服务器 nginx国内大陆的网站用户有腾讯、百度、淘宝、网易、京东和新浪等。 nginx安装 添加安装包 1sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装软件包 1yum install -y nginx nginx程序启动你可以执行nginx -v查看版本。 系统启动并且设置为开机自启动。 12systemctl start nginxsystemctl enable nginx 由于nginx默认是80端口，所以你需要开放80端口。 12firewall-cmd --add-port=80/tcp --permanentfirewall-cmd --reload 增加一条hosts记录打开系统hosts文件,这里就以www.example.com为例。 如果你不清楚自己的系统ip是多少，可以运行下面这个命令安装服务包。 12yum install -y net-toolsifconfig 就会看到自己的ip地址了。 首先我们进入hosts文件，vi /etc/hosts 然后按一下键盘上的Insert， 输入内容 127.0.0.1 www.example.com; 最后按住键盘上的Esc，输入:wq或者:x保存并且退出。 到游览器地址栏输入刚刚保存的网址，就可以看到一下内容。 nginx 配置一个站点nginx的全局配置文件vi /etc/nginx/nginx.conf 接下来我会配置一个简单的静态站点作为示例。 创建一个文件夹用来存放站点文件。 1mkdir /var/www/sites 新建一个网页 1vi /var/www/sites/index.html 然后依照上面的文件编辑保存步骤输入内容并且保存。 这是我的网站首页内容。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;示例站点&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Hello,World!&lt;/h2&gt; &lt;p&gt;Welcome to visted my web site!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 添加配置文件夹和文件 进入nginx的目录下，创建一个文件夹和文件。 进入nginx.conf文件，在http属性下面加一个include /etc/nginx/vhost/*.conf;。 12mkdir /etc/nginx/vhostvi /etc/nginx/vhost/example.com.conf 输入以下内容并且保存。 1234567891011121314server &#123; listen 80; # 监听的端口，这里是80端口 server_name www.example.com example.com; # 这里是地址栏要访问的域名，可以写多个 access_log /var/www/sites/access.log; # 访问成功日志文件 error_log /var/www/sites/error.log; # 访问错误日志文件 location / &#123; root /var/www/sites; # 站点目录 index index.html index.htm; # 站点首页文件名称 &#125; error_page 500 502 503 504 /50x.html; #错误页面 location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 配置完了以后重载重启nginx。 12systemctl reload nginxsystemctl restart nginx 【技巧】这里有一个小技巧，可以检测你写的nginx配置站点文件语法是否正确，可以帮助你减少不必要的烦恼。 12nginx -t -c /etc/nginx/nginx.conf//如果结果没有报错，说明是你写的语法没有问题，反之则要根据错误提示，找到对应的配置文件，更改内容。 在本地hosts文件增加解析记录,这里的ip就是你远程服务器的ip地址了。 12192.168.1.123 www.example.com192.168.1.123 example.com 预览 打开游览器，输入www.example.com或者example.com就可以看到之前编辑的站点首页内容了。 写在最后今天只是初步探究nginx的用法，其他的功能下次补充完善。","categories":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"https://guanqi.xyz/tags/nginx/"}]},{"title":"CentOS7系统中ssh的用法","slug":"usage-of-ssh-in-centos7-system","date":"2019-03-26T08:36:21.000Z","updated":"2019-07-14T10:43:33.675Z","comments":true,"path":"/note/usage-of-ssh-in-centos7-system/","link":"","permalink":"https://guanqi.xyz/note/usage-of-ssh-in-centos7-system/","excerpt":"","text":"导语:大家都知道，公司买上服务器，不可能实时在线操作虚拟机，也没有那个时间和精力登录到公司的云服务商官网进行操作，一来不安全，二来也效率不高。 如果是购买的虚拟主机，你可以使用ftp进行本地程序文件传输和从虚拟主机下载文件到本地。但是对于云服务器来说这种操作方法就显得落后许多了。 今天主要是重点讲解如何使用ssh来操作Linux系统，还是以centos7为蓝本。 安装要求 linux centos7系统 安装ssh程序包打开系统命令行，输入以下命令下载包。 1yum install -y openssh-server 等待几分钟就下载好了。 启动ssh服务接下来我们运行以下命令使ssh服务可以长时间在线运行。 启动ssh服务程序 1systemctl start sshd 开机自启动 1systemctl enable sshd 开启防火墙服务 123firewall-cmd --add-service=ftp/tcp --permanentfirewall-cmd --add-service=http/tcp --permanentfirewall-cmd --reload 下载ssh软件这里推荐两个不错的软件。 putty； xshell； 下载完了安装到本地，下一步安装你懂的。 连接服务下载好 以后，你就可以进行连接远程云服务器进行操作了. 那个ip地址就是你服务器的ip，账号和密码就是你服务器的登录账号的密码，或者是你在系统上创建的其他账户的用户名和密码。 那个端口号是默认22，所以你要开启防火墙添加这个端口号。 1firewall-cmd --add-port=22/tcp --permanent 温馨提示：如果你的账号是root账号，就不需要加sudo了，否则请在命令前面加。 写在最后本文主要是自己的亲身体验，最后做一个总结。如有不足之处，还请多多指教。","categories":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/tags/linux/"},{"name":"ssh","slug":"ssh","permalink":"https://guanqi.xyz/tags/ssh/"}]},{"title":"CentOS7系统中mysql8安装配置","slug":"mysql8-installation-configuration-in-centos7-system","date":"2019-03-26T08:36:21.000Z","updated":"2019-07-14T08:29:57.218Z","comments":true,"path":"/note/mysql8-installation-configuration-in-centos7-system/","link":"","permalink":"https://guanqi.xyz/note/mysql8-installation-configuration-in-centos7-system/","excerpt":"","text":"导语：mysql是世界上最流行的关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司所有。今天我将记录一下如何在Linux centos7系统上安装和配置MySQL。 目录 环境准备 安装包 基本设置 语法操作 环境准备 linux centos7操作系统 ssh软件 MySQL官网 安装包第一步：进入下载文件夹，就是你要存放安装包的文件夹。 1cd /home/downloads 第二步：下载安装包，并且用rpm添加MySQL程序包。 12wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpmrpm -ivh mysql80-community-release-el7-1.noarch.rpm 第三步：安装包。 1yum install -y mysql-community-server 基本设置 启动并开机自启动MySQL程序 12systemctl start mysqldsystemctl enable mysqld 查看版本信息 1mysql -V 修改密码 12345678//查看临时密码grep \"A temporary password\" /var/log/mysqld.log//进入mysqlmysql -u root -p//修改密码ALTER USER 'root'@'localhost' IDENTIFIED BY 'MYsql123.'; 添加防火墙端口 MySQL默认的端口是3306，所有在防火墙中添加一个永久的端口。 12firewall-cmd --add-port=3306/tcp --permanentfirewall-cmd --reload 语法操作MySQL的一些语法操作基本上是增删查改不离手，分为数据库操作、数据表操作、用户操作、权限管理等，这次介绍一些查用的操作命令。 想要获取更多内容，请访问MySQL的官方文档。 数据库操作 123456//添加数据库mysql&gt; CREATE DATABASE mydb;//查看数据库mysql&gt; SHOW DATABASES;//使用数据库mysql&gt; USE &lt;database name&gt;; 数据表操作 12345//查看数据表mysql&gt; SHOW TABLES;//创建数据表mysql&gt; CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20), species VARCHAR(20), sex CHAR(1), birth DATE, death DATE); 用户操作 1234567891011121314151617//新建本地用户mysql&gt; CREATE USER 'test'@'localhost' IDENTIFIED BY '123456';//新建远程用户mysql&gt; CREATE USER 'test'@'%' IDENTIFIED BY '123456';//赋予指定账户指定数据库远程访问权限mysql&gt; GRANT ALL PRIVILEGES ON mydb.* TO 'test'@'%';//赋予指定账户对所有数据库远程访问权限mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'test'@'%';//赋予指定账户对所有数据库本地访问权限mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'test'@'localhost';//刷新权限mysql&gt; FLUSH PRIVILEGES; 权限管理 1234567891011121314//查看权限SHOW GRANTS FOR 'test'@'%';//赋予权限GRANT ALL PRIVILEGES ON *.* TO 'test'@'%';//收回权限REVOKE ALL PRIVILEGES ON *.* FROM 'test'@'%';//刷新权限FLUSH PRIVILEGES;//删除用户DROP USER 'test'@'localhost'; 常见问题打开phpadmin无法登录 因为MySQL8使用了更高级的方法，phpmyadmin不支持，所以需要使用以下语法来重置登录密码。 123CREATE USER '&lt;你的用户名&gt;' IDENTIFIED WITH 'mysql_native_password' BY '&lt;你的密码&gt;';GRANT ALL PRIVILEGES ON *.* TO 'test'@'%';FLUSH PRIVILEGES;","categories":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"https://guanqi.xyz/tags/mysql/"}]},{"title":"linux系统探索","slug":"linux-system-exploration","date":"2019-03-25T10:36:21.000Z","updated":"2019-07-14T08:16:54.433Z","comments":true,"path":"/note/linux-system-exploration/","link":"","permalink":"https://guanqi.xyz/note/linux-system-exploration/","excerpt":"","text":"导语：想着用着微软家的windows系统很多年了，也想尝试一下其他的操作系统。很快的就想到了Linux操作系统，它不是面向用户的，而是面向服务器的，在服务器端的市场中占了很大的市场份额，备受好评。 目录 Linux特点 特别说明 yum常用命令 程序相关命令 防火墙相关命令 Linux特点基于以下几点，我决定探究一下Linux系统。 Linux系统是全世界少有的免费、开源的、自由传播的类Unix操作系统； 命令行操作文件、程序比较灵活、迅速，非常高效； 特别说明本文主要是使用centos7进行系统的各项操作。 centos7操作系统镜像下载地址 yum常用命令yum是一个shell前端软件包管理器，基于rpm管理，一次性安装所有依赖，无需频繁下载依赖。 查找软件包1yum search &lt;keyword&gt; 安装软件1yum install &lt;package_name&gt; 安装包列表1yum list 更新软件包 更新一个包 1yum update &lt;package_name&gt; 更新所有 1yum update 查询软件信息1yum info &lt;package_name&gt; 卸载安装包1yum remove &lt;package_name&gt; 清除缓存1yum clean packages 程序相关命令 启动程序运行 123systemctl start &lt;name&gt;.service//或者systemctl start &lt;name&gt; 停止程序运行 123systemctl stop &lt;name&gt;.service//或者systemctl stop &lt;name&gt; 重启程序 123systemctl restart &lt;name&gt;.service//或者systemctl restart &lt;name&gt; 重载程序配置 123systemctl reload &lt;name&gt;.service//或者systemctl reload &lt;name&gt; 查看程序状态 123systemctl status &lt;name&gt;.service//或者systemctl status &lt;name&gt; 开机自启动程序 1systemctl enable &lt;name&gt; 禁止开机启动程序 1systemctl disable &lt;name&gt; 防火墙相关命令端口操作命令 查看防火墙版本 1firewall-cmd --version 防火墙帮助 1firewall-cmd --help 查看防火墙状态 1firewall-cmd --state 查看已启用的端口 1firewall-cmd --list-port 开启某个端口 12firewall-cmd --add-port=&lt;port&gt;/tcp --permanent// --permanent表示永久有效 开启某个区间的端口 1firewall-cmd --add-port=&lt;port_start&gt;-&lt;port_end&gt;/tcp --permanent 关闭某个端口 1firewall-cmd --remove-port=&lt;port&gt;/tcp --permanent 开启某个区间的端口 1firewall-cmd --remove-port=&lt;port_start&gt;-&lt;port_end&gt;/tcp --permanent 开启服务 1firewall-cmd --add-service=&lt;service_name&gt; --permanent 关闭服务 1firewall-cmd --remove-service=&lt;service_name&gt; --permanent 重载防火墙配置 1firewall-cmd --reload Linux初次探索就到这里，下次我再分享其他有趣好玩的故事。","categories":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://guanqi.xyz/tags/linux/"},{"name":"centos7","slug":"centos7","permalink":"https://guanqi.xyz/tags/centos7/"}]},{"title":"表单输入验证案例","slug":"form-input-verification-case","date":"2019-02-01T08:33:21.000Z","updated":"2019-07-14T08:14:10.515Z","comments":true,"path":"/note/form-input-verification-case/","link":"","permalink":"https://guanqi.xyz/note/form-input-verification-case/","excerpt":"","text":"导语：之前已经说过了事件的来龙去脉和属性以及方法，今天就说一下表单的案例。 案例步骤 1.建好表单结构和样式； 2.获取输入内容进行验证； 3.不正确进行文字提示； 4.输入成功后提交表单 代码展示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;form action=\"\" method=\"get\" name=\"myform\" id=\"myform\" onsubmit=\"return returnForm();\" onreset=\"return confirmForm();\"&gt; &lt;p&gt; &lt;label for=\"username\"&gt;昵称：&lt;/label&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" placeholder=\"请输入用户名称\"&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;密码：&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" placeholder=\"请输入用户密码\"&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;性别：&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"man\" value=\"man\"&gt;&lt;label for=\"man\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"woman\" value=\"woman\"&gt;&lt;label for=\"woman\"&gt;女&lt;/label&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"hobbies\"&gt;爱好：&lt;/label&gt; &lt;input type=\"checkbox\" name=\"hobbies\" id=\"song\" value=\"song\"&gt;&lt;label for=\"song\"&gt;唱歌&lt;/label&gt; &lt;input type=\"checkbox\" name=\"hobbies\" id=\"read\" value=\"read\"&gt;&lt;label for=\"read\"&gt;看书&lt;/label&gt; &lt;input type=\"checkbox\" name=\"hobbies\" id=\"sport\" value=\"sport\"&gt;&lt;label for=\"sport\"&gt;运动&lt;/label&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;城市：&lt;/label&gt; &lt;select name=\"city\" id=\"city\"&gt; &lt;option value=\"bj\" selected&gt;北京&lt;/option&gt; &lt;option value=\"tj\"&gt;天津&lt;/option&gt; &lt;option value=\"cq\"&gt;重庆&lt;/option&gt; &lt;option value=\"sh\"&gt;上海&lt;/option&gt; &lt;option value=\"hz\"&gt;杭州&lt;/option&gt; &lt;option value=\"nj\"&gt;南京&lt;/option&gt; &lt;option value=\"gz\"&gt;广州&lt;/option&gt; &lt;option value=\"sz\"&gt;深圳&lt;/option&gt; &lt;option value=\"xa\"&gt;西安&lt;/option&gt; &lt;/select&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"headimg\"&gt;头像：&lt;/label&gt; &lt;input type=\"file\" name=\"headimg\" id=\"headimg\"&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;input type=\"hidden\" name=\"token\" value=\"20190201\" id=\"token\"&gt; &lt;p&gt; &lt;label for=\"comment\"&gt;介绍：&lt;/label&gt;&lt;br&gt; &lt;textarea name=\"comment\" id=\"comment\" cols=\"30\" rows=\"10\" placeholder=\"自我介绍一下吧！\"&gt;&lt;/textarea&gt; &lt;span class=\"tips\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"reset\" id=\"reset\" value=\"重置\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"提交\"&gt; &lt;/p&gt;&lt;/form&gt;&lt;script src=\"https://guanqi.xyz/demo/assets/scripts/gjs.min.js\"&gt;&lt;/script&gt; 温馨提示：前提是你要引入一个js文件，分别是gjs.js 123.tips &#123; color: #f00;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//禁止默认提交function returnForm() &#123; return false;&#125;//确定重置提示function confirmForm() &#123; var reset = confirm('你确定要清空所有输入的内容吗？'); return reset;&#125;//验证表单内容var tips = $g.ecls('tips');var btn = document.myform.submit;$g.addEvent(btn, 'click', checkFrom, false);function checkFrom() &#123; //正则表达式 var formreg = /\\w&#123;5,&#125;/; //表单元素 var myform = document.myform; var username = myform.username.value; var password = myform.password.value; var sex = myform.sex.value; var hobbies = myform.hobbies; var city = myform.city.value; var headimg = myform.headimg.value; var comment = myform.comment.value; var flag = false; if (username == '') &#123; tips[0].innerText = '昵称不能为空'; flag = false; &#125; else if (!formreg.test(username)) &#123; tips[0].innerText = '请输入6-10位名字'; flag = false; &#125; else &#123; tips[0].innerText = ''; flag = false; &#125; if (password == '') &#123; tips[1].innerText = '密码不能为空'; flag = false; &#125; else if (!formreg.test(password)) &#123; tips[1].innerText = '请输入至少6位密码'; flag = false; &#125; else &#123; tips[1].innerText = ''; flag = false; &#125; if (sex == '') &#123; tips[2].innerText = '性别不能为空'; flag = false; &#125; else &#123; tips[2].innerText = ''; flag = false; &#125; var isChecked; for (var i = 0; i &lt; hobbies.length; i++) &#123; var checked = hobbies[i].checked; if (checked) &#123; isChecked = true; &#125; &#125; if (!isChecked) &#123; tips[3].innerText = '爱好不能为空'; flag = false; &#125; else &#123; tips[3].innerText = ''; flag = false; &#125; if (city == '') &#123; tips[4].innerText = '城市不能为空'; flag = false; &#125; else &#123; tips[4].innerText = ''; flag = false; &#125; if (headimg == '') &#123; tips[5].innerText = '头像不能为空'; flag = false; &#125; else &#123; tips[5].innerText = ''; flag = false; &#125; if (comment == '') &#123; tips[6].innerText = '自我介绍不能为空'; flag = false; &#125; else &#123; tips[6].innerText = ''; flag = true; &#125; return flag;&#125; 效果展示这个例子是兼容IE5-11，Firefox，Google Chrome等游览器的。 如果你想要看效果，请点击【这里】前去GitHub查看。","categories":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/categories/前端案例/"}],"tags":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/tags/前端案例/"},{"name":"表单验证","slug":"表单验证","permalink":"https://guanqi.xyz/tags/表单验证/"}]},{"title":"鼠标和键盘事件案例","slug":"mouse-and-keyboard-event-case","date":"2019-02-01T02:33:21.000Z","updated":"2019-07-14T08:09:51.122Z","comments":true,"path":"/note/mouse-and-keyboard-event-case/","link":"","permalink":"https://guanqi.xyz/note/mouse-and-keyboard-event-case/","excerpt":"","text":"导语：之前已经说过了事件的来龙去脉和属性以及方法，今天就说一下鼠标和键盘事件的案例。 温馨提示前提是你要引入一个gjs.js文件 https://guanqi.xyz/demo/assets/scripts/gjs.min.js 才可以运行。 1&lt;script src=\"https://guanqi.xyz/demo/assets/scripts/gjs.min.js\"&gt;&lt;/script&gt; 鼠标和键盘事件鼠标和键盘事件就是设备相关的事件，可以使用鼠标和键盘对文档进行操作，触发相应的事件。 鼠标事件案例既然之前已经知道了如何使用鼠标事件，那本节就提出两个案例，来对学过的知识的实践。 本节有两个案例，第一个是有关右击鼠标显示自定义菜单的；第二个是有关如何使用鼠标进行拖拽元素。 鼠标右击自定义菜单原理： 当鼠标右键按下后，获取鼠标坐标，然后赋值并且显示菜单元素； 当鼠标左键按下后，隐藏菜单元素； 菜单样式123456&lt;ul id=\"list\"&gt; &lt;li&gt;&lt;a href=\"#menu1\"&gt;菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#menu2\"&gt;菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#menu3\"&gt;菜单3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#menu4\"&gt;菜单4&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627#list &#123; margin: 0; padding: 0; width: 150px; height: 240px; border: 1px solid #eee; box-shadow: 1px 1px 5px #eee; list-style: none;&#125;#list li &#123; width: 150px; height: 60px; line-height: 60px; text-align: center;&#125;#list li:hover &#123; background-color: #ddd;&#125;#list li:hover a &#123; color: #333;&#125;#list li a &#123; display: inline-block; width: 100%; color: #666; text-decoration: none;&#125; 动效js操作1234567891011var uls = $g.eid('list');$g.addEvent(document, 'contextmenu', function (e) &#123; $g.prevent(e); $g.stoppro(e); uls.style.left = e.clientX + 'px'; uls.style.top = e.clientY + 'px'; uls.style.display = 'block';&#125;, false);$g.addEvent(document, 'click', function () &#123; uls.style.display = 'none';&#125;, false); 这个案例就到此为止，请点这里在GitHub上查看效果。 元素拖拽示例原理： 1.当点击鼠标，获取到鼠标坐标位置；然后减去元素距离左/上边的距离； 2.当移动元素，获取到元素距离左上的距离；用鼠标的坐标值减去上一步的值； 3.当放开鼠标，禁用鼠标移动事件和按下事件； 元素和样式1&lt;div class=\"box\"&gt; 123456789101112.box &#123; position: absolute; right: 0; top: 0; width: 150px; height: 150px; line-height: 150px; background-color: #f00; color: #fff; font-size: 20px; text-align: center;&#125; js动效1234var box = $g.eone('.box');var box1 = $g.eone('.box1');new $g.Drag(box);new $g.Drag(box1); 这个案例就到此为止，请点这里在GitHub上查看效果。 键盘事件案例键盘事件案例一般是用于鼠标事件案例的替代选择，如果用户的设备只支持键盘，就可以使用键盘事件代替是鼠标事件。 大多数事件都是有鼠标事件对应的键盘事件，两个事件都是可以触发同一函数方法的。 这个案例就是模拟聊天窗口，按住Enter键盘键，然后发送聊天内容。 聊天窗口模拟案例原理：当输入框输完内容后，按下键盘上的Enter发送聊天内容。 123&lt;div id=\"box\"&gt;&lt;/div&gt;&lt;input type=\"text\" name=\"con\" id=\"con\" placeholder=\"请输入聊天内容\"&gt;&lt;button id=\"send\"&gt;发送&lt;/button&gt; 1234567891011121314151617181920212223242526#box &#123; padding: 10px 15px; width: 250px; height: 400px; background-color: #f9f9f9; border: 1px solid #eee; overflow: auto;&#125;#con &#123; margin: 10px 0; padding: 0 10px; width: 200px; height: 30px; line-height: 30px; color: #333;&#125;#send &#123; position: relative; top: 2px; width: 50px; height: 35px; line-height: 35px; border: none; border: 1px solid #f8f8f8; cursor: pointer;&#125; 1234567891011121314151617181920212223242526272829var box = $g.eid('box');var con = $g.eid('con');var send = $g.eid('send');$g.addEvent(send, 'click', sendCon, false);function sendCon() &#123; if (con.value == '') &#123; alert('请输入内容！'); return; &#125; box.innerHTML += '&lt;p style=\"margin:2px auto;\"&gt;' + con.value + '&lt;/p&gt;&lt;br&gt;' con.value = '';&#125;$g.addEvent(con, 'keypress', sendKey, false);function sendKey(e) &#123; var e = e || window.event; var code = e.code; if (code == 'Enter' || e.keyCode == 13) &#123; if (con.value == '') &#123; alert('请输入内容！'); return; &#125; box.innerHTML += '&lt;p style=\"margin:2px auto;\"&gt;' + con.value + '&lt;/p&gt;&lt;br&gt;' con.value = ''; &#125;&#125; 如果想看效果，可以点这里在GitHub上查看。","categories":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/categories/前端案例/"}],"tags":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/tags/前端案例/"},{"name":"表单键盘案例","slug":"表单键盘案例","permalink":"https://guanqi.xyz/tags/表单键盘案例/"}]},{"title":"js之事件解读","slug":"interpretation-of-js-events","date":"2019-01-31T02:33:21.000Z","updated":"2019-07-14T08:06:09.915Z","comments":true,"path":"/note/interpretation-of-js-events/","link":"","permalink":"https://guanqi.xyz/note/interpretation-of-js-events/","excerpt":"","text":"导语：在js中，具有交互性程序的是事件驱动。它可以很好的和用户进行互动，增强网页的趣味性和互动效果，提高更好的用户体验。今天我分享一篇有关事件驱动的文章，讲诉事件的来龙去脉，文章有不妥之处，还请电邮反馈。 事件的起源这节开始说事件的起源，也就是原始事件模型。这是最初始的事件处理模式，通常把它当作0级DOM的一部分，所有游览器都支持。 事件以及事件类型事件就是当用户在用鼠标或者键盘对网页进行操作时所，触发了的网页调用某个方法，反馈给用户的结果。不同的事件类型，生成的事件也不一样，反馈效果也不一样。 在原始事件模型中，事件不能被js直接操作，是游览器从内部提取的。这些事件类型都是响应事件调用时的事件句柄名称。HTML属性就可以用来处理这些事件代码。 下面是收集总结的事件句柄列表： 序号 事件句柄 触发条件 支持元素 1 onload 文档加载完毕 &lt;body&gt; 2 unonload 文档卸载完毕 &lt;body&gt; 3 onresize 调整窗口大小 &lt;body&gt; 4 onabort 图像加载被中断 &lt;img&gt; 5 onerror 图像加载发生错误 &lt;img&gt; 6 onclick 鼠标按下被释放 大多数元素 7 ondbclick 双击鼠标 大多数元素 8 onmousedown 鼠标键被按下 大多数元素 9 onmousemove 鼠标移动 大多数元素 10 onmouseup 释放鼠标键 大多数元素 11 onmouseover 鼠标移到元素上 大多数元素 12 onmouseout 鼠标离开元素 大多数元素 13 onkeydown 键盘被按下 表单元素、&lt;body&gt; 14 onkeyup 键盘被按下后释放 表单元素、&lt;body&gt; 15 onkeypress 键盘按下被释放，返回false取消默认 表单元素、&lt;body&gt; 16 onblur 元素失去焦点 &lt;body&gt;&lt;input&gt;&lt;textarea&gt;&lt;button&gt;&lt;select&gt; 17 onfocus 元素得到焦点 &lt;body&gt;&lt;input&gt;&lt;textarea&gt;&lt;button&gt;&lt;select&gt; 18 onchange 得到焦点使值发生了改变 &lt;input&gt;&lt;textarea&gt;&lt;select&gt; 19 onselect 选中表单文本 &lt;input&gt;&lt;select&gt;&lt;textarea&gt; 20 onreset 表单重置，返回false取消 &lt;form&gt; 21 onsubmit 表单提交，返回false取消 &lt;form&gt; 以上是一些定义的事件列表，仔细点，你会发现列表中可以大致的分为鼠标事件、键盘事件、表单事件以及其他事件。后面会详细介绍。 html属性的事件之前说过，事件是用户在对html标签进行触发时调用的js方法，用来执行一些相关的任务。 所以在html中，以上列表的事件可以被当作html的属性来使用。这里部分大小写，但是我还是习惯小写。 【例如】：给一个按钮加上事件，弹出内容。 1&lt;button onclick=\"alert('你好啊，事件！');\"&gt;点我&lt;/button&gt; js属性的事件如果不想再html属性值里面写js的方法，字符串，可以在js中写这样一个方法，然后在html属性中进行调用，同样也可以的。 【例如】：给一个输入框加上提示。 1&lt;input type=\"text\" name=\"username\" onchange=\"tips(event);\"&gt; 1234567function tips(event) &#123; var val = event.target.value; var nameReg = /^[\\u4e00-\\u9fa5]&#123;0,&#125;$/; if (!nameReg.test(val)) &#123; alert('请输入中文！'); &#125;&#125; 还可以这样写。 1&lt;input type=\"text\" name=\"username\"&gt; 1234567891011121314151617var username = document.getElementsByName('username')[0];username.onchange = tips;function tips(event) &#123; var val = event.target.value; var nameReg = /^[\\u4e00-\\u9fa5]&#123;0,&#125;$/; if (!nameReg.test(val)) &#123; alert('请输入中文！'); &#125;&#125;// 或者这样username.onchange = function (event) &#123; var val = event.target.value; var nameReg = /^[\\u4e00-\\u9fa5]&#123;0,&#125;$/; if (!nameReg.test(val)) &#123; alert('请输入中文！'); &#125;&#125; js事件的返回值大多数情况下，事件都有返回值，如果是true就执行，不是就取消。 比如说：onclick事件，如果返回true就执行，否则不执行。 【例如】:提交表单不执行默认提交方法。 1234&lt;form name=\"login\" onsubmit=\"return checkForm();\"&gt; &lt;input type=\"text\" name=\"username\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 123function checkForm() &#123; return false;&#125; 其实还有表单重置事件也是这样，你可以私下里去练习一下。 this关键词js中的this是一个很神奇的存在，一般情况下，它都指向的是Window顶层全局对象，也包括函数调用。 【例如】：你打印一下这个this，你会发现结果是Window。 12345console.log(this); // Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;function hello() &#123; console.log(this); // Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;&#125;hello(); 但是也有其他情况，比如说对象方法调用，事件调用。这种情况下，就是谁调用，指向谁。对象里面的方法调用会指向对象本身。 【例如】： 1.对象方法调用 12345678910//对象方法调用var obj = &#123; name: 'mark', sayName: function () &#123; console.log(this); // &#123;name: \"mark\", sayName: ƒ&#125; console.log(this.name); // mark return this.name; &#125;&#125;console.log(obj.sayName()); // mark 注意:如果把对象中的方法赋予另一个变量，由于这个变量是Window下的变量、属性，所以再次打印this会指向Window对象。 123456789//对象方法调用var obj = &#123; name: 'mark', sayName: function () &#123; console.log(this); // Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125; &#125;&#125;var fn = obj.sayName;console.log(fn()); 2.事件调用 1&lt;button id=\"tip\"&gt;点我&lt;/button&gt; 123456//事件方法调用var tip = document.getElementById('tip');tip.onclick = function(event) &#123; console.log(this); // &lt;button id=\"tip\"&gt;点我&lt;/button&gt; console.log(this.id); // tip&#125; 作用域在js中，有变量作用域，有函数作用域，但是所有作用域的顶层都是全局对象。 在事件句柄中，也存在作用域，但是这个作用域只是适用于html属性的事件句柄。 例如：在一个button按钮中调用了名为form的变量，那么就会解析成form属性。 1234&lt;form&gt; &lt;input type=\"text\" name=\"username\" value=\"hello\"&gt; &lt;button onclick=\"alert(this.form.username.value);\"&gt;点我&lt;/button&gt;&lt;/form&gt; 在此案例中，当点我按钮点击后会把form解析成这个表单属性，从而获取到旁边输入框的值hello。 事件的2级DOM标准在经历了原始事件模型后，DOM又进行了扩展，定义了一些高级的事件处理方法。这些方法除了ie游览器外其他的游览器都支持。ie有自己的处理方法，这些方法会在第三节进行补充。 事件传播在0级DOM事件模型中，是游览器负责把事件分配到发生事件的元素，如果那个元素有合适的事件类型就会触发，不会再执行其他的操作。 但是2级DOM标准中规定的是只要事件发生在文档元素（目标元素）上，就会触发。它的上级元素也有机会触发该事件。 此时就有了事件传播，它主要是分为3个阶段进行。 事件传播的捕捉阶段(capturing)这个阶段事件从Document对象沿着DOM树向下传播给那个目标节点。 这个阶段是从上到下进行传播，如果在途中有目标节点的祖先注册了捕捉事件句柄，就会先执行这个事件。 事件传播的第二个阶段(self)这个阶段已经到达了目标元素本身，直接注册在元素本身的事件就会执行。 事件传播的起泡阶段(bubbling)这个阶段，目标元素已经执行完自身的事件句柄了，所以这个阶段的事件就会沿着DOM树向上回到Document对象。如果在途中有目标节点的祖先有合适的事件句柄，就会先执行这个事件。 但是并非所有的事件类型都起泡，像表单这种form元素执行完自身事件后再往Document对象走没有意义。 一般来说，原始事件起泡，而高级语义的事件不起泡。 下面一张表就列出了哪些适用于哪个阶段的事件传播。 序号 事件类型 接口 B(起泡) C(捕捉) 支持元素/属性 1 abort Event yes no &lt;img&gt; 2 blur Event no no &lt;a&gt;&lt;area&gt;&lt;button&gt;&lt;input&gt;&lt;select&gt;&lt;textarea&gt; 3 change Event yes no &lt;input&gt;&lt;select&gt;&lt;textarea&gt; 4 click MouseEvent yes yes screenX,screenY,clientX,clientY,altKey,ctrlKey 5 error Event yes no &lt;body&gt;,&lt;frameset&gt;&lt;img&gt; 6 focus Event no no &lt;a&gt;&lt;area&gt;&lt;button&gt;&lt;input&gt;&lt;select&gt;&lt;textarea&gt; 7 load Event no no &lt;body&gt;&lt;frameset&gt;&lt;iframe&gt;&lt;img&gt; 8 mousedown MouseEvent yes yes screenX,screenY,clientX,clientY,altKey,ctrlKey 9 mousemove MouseEvent yes no screenX,screenY,clientX,clientY,altKey,ctrlKey 10 mouseout MouseEvent yes yes screenX,screenY,clientX,clientY,altKey,ctrlKey 11 mouseover MouseEvent yes yes screenX,screenY,clientX,clientY,altKey,ctrlKey 12 mouseup MouseEvent yes yes screenX,screenY,clientX,clientY,altKey,ctrlKey 13 reset Event yes no &lt;form&gt; 14 resize Event yes no &lt;body&gt;&lt;iframe&gt;&lt;frameset&gt; 15 scroll Event yes no &lt;body&gt; 16 select Event yes no &lt;input&gt;&lt;textarea&gt; 17 submit Event yes yes &lt;form&gt; 18 unload Event no no &lt;body&gt;&lt;frameset&gt; 19 DOMActivate UIEvent yes yes detail 20 DOMFocusIn UIEvent yes no none 21 DOMFocusOut UIEvent yes no none 温馨提示: 在事件传播的过程中，任何事件句柄都可以使用表示事件的Event对象提供的stopPropagation()方法来停止事件的传播。 也有一些事件会引起游览器对元素的默认动作，比如a标签，默认动作是超链接跳转。在事件传播阶段结束后，便会进行默认动作。可以使用Event对象提供的preventDefault()方法来阻止默认动作的发生。 在0级DOM模型中，只能为特定对象的特定类型的事件注册一个事件句柄，但是在2级模型中，就可以为特定对象的特定类型的事件注册多个事件句柄。 事件句柄注册在0级DOM事件中，通过html属性或者js来为元素注册事件;但在2级DOM事件中，可以调用addEventListener()方法来为某个元素注册事件,该方法有3个参数。 第一个参数是事件类型，不加前缀on，比如：onmouseover要写成mouseover; 第二个参数是句柄函数，也就是事件发生时调用的函数;这个函数只接受唯一的Event对象； 第三个参数是布尔值，值为true，那就用于捕捉事件，否则就是直接发生在元素本身的事件； 这个注册方法只对注册的元素有用，是独立的，可以为一个元素注册多个事件而互相不受影响的。 【例如】： 为按钮注册一个点击事件。 1&lt;button id=\"clickme\"&gt;点我&lt;/button&gt; 12345var clickme = document.getElementById('clickme');clickme.addEventListener('click',clickMe,false);function clickMe(e) &#123; console.log(this.id); // clickme&#125; 监听一个元素中发生的所有鼠标移入事件 1&lt;button id=\"overme\"&gt;点我&lt;/button&gt; 12345var overme = document.getElementById('overme');overme.addEventListener('mouseover',handlerMouse,true);function handlerMouse(e) &#123; console.log(this.id); // clickme&#125; 既然有注册，也就有注销事件，与之对应的是方法是removeEventListener(),它和注册方法接受的参数一样，不过是从元素上面移除了这个事件。 12345var overme = document.getElementById('overme');overme.removeEventListener('mouseover',handlerMouse,true);function handlerMouse(e) &#123; console.log(this.id); // clickme&#125; 小提示：这个注册方法中第二个参数的函数内部的this是指向注册事件的元素。 事件模块在2级DOM中，事件是模块化的，所以你可以使用以下方法来测试游览器是否支持2级DOM事件模块。 下面是我封装的一个方法，只需要传入两个参数就可以查询是否支持。 123456789101112function searchDomSupport(name,version) &#123; if (document.implementation &amp;&amp; document.implementation.hasFeature &amp;&amp; document.implementation.hasFeature(name,version) ) &#123; return true; &#125; else &#123; return false; &#125;&#125;var res = searchDomSupport('Event','2.0');console.log(res); // true; Event接口和Event2级DOM API提供了事件发生时事件的一些额外信息，包括事件发生的时间，类型，元素的属性等等。事件是模块化的，所以一个模块就有一个相关的事件接口，声明了该事件类型的详细信息。 Event接口就是这个事件接口，它包括以下几部分： 序号 模块名 事件接口 事件类型 1 HTMLEvents Eevent abort,blur,change,load,resize,scroll,select 2 MouseEvents MouseEvent click,mousedown,mouseup,mouseover,mouseout 3 UIEvents UIEvent DOMActivate,DOMFocusIn,DOMFocusOut Event的属性 type,发生事件的类型，和注册事件名称一样，比如：click，mouseover； target,发生事件的节点信息； currentTarget,发生当前事件的节点,在事件传播过程中和target的值不一样； eventPhase,一个数字表明当前所处的传播阶段，是一个常量； timeStamp,一个Date()对象，表面事件发生的时间； bubbles,一个布尔值，声明该事件是否在文档中起泡； cancelable,一个布尔值，声明该事件是否能用preventDefault()方法； 【例如】：获取按钮的点击事件的属性。 1&lt;button id=\"tips\"&gt;点我&lt;/button&gt; 1234567891011var tips = document.getElementById('tips');tips.onclick = function (e) &#123; var e = e || window.event; console.log(e.type); // click console.log(e.target); // target: button#tips console.log(e.currentTarget); // null console.log(e.eventPhase); // 2 console.log(e.timeStamp); // 3006.099999998696 console.log(e.bubbles); // true console.log(e.cancelable); // true&#125; Event的方法 stopPropagation(),阻止事件从当前正在处理它的节点传播； preventDefault()，阻止游览器执行节点的默认动作； 【例如】: 12345678// 调用此函数function clickMe(e) &#123; e.stopPropagation();&#125;//超链接跳转禁用function clickMe(e) &#123; e.preventDefault();&#125; UIEvent的属性 view,发生事件的Window对象； detail，对于鼠标点击事件来说，值为1就是点击1次，为2就是点击2次。如果值为2，说明之前还有一个点击为1的事件； MouseEvent的属性 button,一个数字，声明在mousedown,mouseup,click事件中，哪个鼠标键改变了状态。0为左键，1为中间键，2为右键； altKey、ctrlKey、metaKey、shiftKey,这四个值都是布尔值，声明在鼠标事件发生时，是否同时按住了这四个键盘键；alt,ctrl,shift,meta; clientX、clientY,声明鼠标指针位于游览器窗口的X坐标和Y坐标；不考虑文档滚动，如果在顶部则clientY始终是0；在ie以外，要转换成文档坐标，而不是游览器窗口坐标；可以使用window.pageXOffset和window.pageYOffset来获取。 screenX、screenY,声明鼠标指针位于用户显示器的左上角的X坐标和Y坐标; relatedTarget,引用事件的节点相关的节点。比如：对于mouseover，是鼠标移入目标节点离开时的那个节点； 【例如】：按钮的点击事件属性 1&lt;button id=\"tips\"&gt;点我&lt;/button&gt; 12345678var tips = document.getElementById('tips');tips.onclick = function (e) &#123; console.log(e.button); // 0 console.log(e.altKey,e.ctrlKey,e.metaKey,e.shiftKey); // false false false true console.log(e.clientX,e.clientY); // 22 17 console.log(e.screenX,e.screenY); // 22 119 console.log(e.relatedTarget); // null&#125; 温馨提示：2级DOM事件模型是可以兼容0级DOM事件的一些属性和方法。这叫混合事件模型。 IE事件模型本节介绍的是IE4、5、6支持的中间模型，它介于0级模型和2级DOM事件模型之间。包括以下几部分： Event对象，和2级DOM事件模型的Event属性有些相似； IE事件的传播、注册和内存泄漏 Event对象的属性 type,发生事件的类型，和2级DOM中的type属性兼容。比如：click，mouseover； srcElement,发生事件的文档元素，和2级DOM中的target属性兼容； button,声明鼠标被按下的鼠标键；值为1是左键，2为右键，4为中间键； clientX、clientY,声明鼠标指针位于游览器窗口的X坐标和Y坐标；要转换成文档坐标,需要加文档滚动的量； offsetX、offsetY,声明鼠标指针位于元素的位置； altKey、ctrlKey、shiftKey,这四个值都是布尔值，声明在鼠标事件发生时，是否同时按住了这三个键盘键; keyCode,声明在键盘事件(keydown,keyup,keypress)中的键盘码；可以用String.fromCharCode()方法把字符代码转换成字符串； fromElement、toElement,fromElement声明mouseover事件移动过的文档元素，toElement声明mouseout事件移到的文档元素； cancelBubble,布尔值为true时阻止当前事件进一步起泡到上一层次的元素；相当于2级DOM中的stopPropagation()方法； returnValue,布尔值为false时可以阻止游览器执行默认动作，相当于2级DOM中的preventDefault()方法； 【例如】：在ie游览器中进行点击事件。 1&lt;button id=\"tips\"&gt;点我&lt;/button&gt; 1234567891011var tips = document.getElementById('tips');tips.onclick = function (e) &#123; console.log(e.type); // click console.log(e.srcElement); // &lt;button id=\"tips\"&gt;点我&lt;/button&gt; console.log(e.button); // 0 console.log(e.clientX,e.clientY); // 30.399999618530273 14.399999618530273 console.log(e.offsetX,e.offsetY); // 29.399999618530273 11.800000190734863 console.log(e.altKey,e.ctrlKey,e.shiftKey); // false false false console.log(e.cancelBubble); // false console.log(e.returnValue); // undefined&#125; 温馨提示：IE中事件模型Event对象是作为全局的变量，在Window对象下的，所以要使用必须这样写window.event。 IE事件注册ie4中是和0级模型一样的方法；ie5以及以后的版本是使用attachEvent()方法和detachEvent()方法，类似于2级DOM事件模型中的事件监听注册方法；但是不同的是： IE事件模型不支持事件捕捉，所以这两个方法的参数只要两个； 第一个参数的事件类型名称应该包括on这个前缀；例如：click要写成onclick; attachEvent()方法注册的函数将作为全局函数调用，而不是事件的目标元素，this关键词指向Window; attachEvent()方法允许注册多次，当事件发生时，注册函数的被调用次数和注册次数一样多； 事件起泡:IE事件模型中的事件起泡，想要阻止只能把cancelBubble这个属性设置为true,当新事件生成时，又会自动还原成false。 事件捕捉：IE事件模型中的事件捕捉，可以使用setCapture()和releaseCapture()方法来实现，只是对鼠标事件适用。 内存泄漏：IE6之前的嵌套函数容易引起内存泄漏。 IE兼容性方法下面是我根据原始事件模型、2级DOM事件模型和IE事件模型，封装的一个方法。 1234567891011121314151617181920212223242526272829303132var uniHandler= &#123;&#125;;if (document.addEventListener) &#123; uniHandler.add = function (elem,eventType,handleEvent,isCapture) &#123; elem.addEventListener(eventType,handleEvent,isCapture); &#125; uniHandler.remove = function (elem,eventType,handleEvent,isCapture) &#123; elem.removeEventListener(eventType,handleEvent,isCapture); &#125; uniHandler.stoppro = function () &#123; e.stopPropagation(); &#125;; uniHandler.prevent = function () &#123; e.preventDefault(); &#125;&#125; else if (document.attachEvent) &#123; uniHandler.add = function (elem,eventType,handleEvent) &#123; elem.attachEvent('on'+eventType,handleEvent); &#125; uniHandler.remove = function (elem,eventType,handleEvent) &#123; elem.detachEvent('on'+eventType,handleEvent); &#125; uniHandler.stoppro = function () &#123; e.cancelBubble = true; &#125;; uniHandler.prevent = function () &#123; e.returnValue = false; &#125;&#125; else &#123; uniHandler.eventOrigin = function (elem,eventType,handleEvent) &#123; elem.eventType = handleEvent; &#125;&#125; 【例如】:在ie和非ie游览器中测试，均没有问题；ie包括ie5-11。 一个按钮注册点击事件 1&lt;button id=\"tips\"&gt;点我&lt;/button&gt; 1234var tips = document.getElementById('tips');uniHandler.add(tips,'click',function () &#123; alert('你好！');&#125;,false); 一个链接注册点击事件，并且阻止游览器默认动作 1&lt;a id=\"goto\" href=\"#111\" target=\"_blank\"&gt;链接&lt;/a&gt; 123456var goto = document.getElementById('goto');uniHandler.add(goto,'click',function (e) &#123; var e = e || window.event; uniHandler.prevent(e); alert('我不走！');&#125;,false); 写在最后有关DOM中的事件今天就说到这里，还有不明白的可以到前面去仔细看看，多练练，你就会了。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/tags/javascript/"},{"name":"events","slug":"events","permalink":"https://guanqi.xyz/tags/events/"}]},{"title":"js之cookie操作","slug":"js-cookie-operation","date":"2019-01-30T09:33:21.000Z","updated":"2019-07-14T08:04:51.735Z","comments":true,"path":"/note/js-cookie-operation/","link":"","permalink":"https://guanqi.xyz/note/js-cookie-operation/","excerpt":"","text":"导语：今天，说一下这个cookie的属性和用法，包括设置cookie,获取cookie,删除cookie。cookie是Document对象的一个属性，可以使js方便的把一些数据放在在本地进行存取操作。cookie还用于客户端脚本化，是http协议的一个标准扩展。 cookie的概念cookie是Web游览器存储的少量命名数据，它作用于某个特定的网页或者网站。它可以在客户端和服务器之间的传递数据，位于服务器端的脚本可以读取到客户端的cookie。 常用的使用场景有以下几个： 用户登录，服务器记录下用户的登录信息，以便验证下次是否重新登录； 电商网站的购物车，记录下用户的购物车购买东西喜好，以便下次推广相关的产品； 网络广告主和网络广告服务商的广告推广，对于不同网站进行用户广告的推送。 温馨提示：由于cookie是http协议的标准扩展，所以要在http协议下的网站和页面才可以使用cookie。不要使用在游览器中打开（类似于：file:///D:/test.html），建议开启http服务（http://localhost:2009/test.html）。 检测是否支持由于用户登录或者购物车需要记录cookie的有关信息，所以首先要检测用户的游览器是否开启了cookie，没有开启要提示用户开启cookie后在操作。 下面是检测游览器的cookie是否开启的方法： 1&lt;p id=\"cookieTips\"&gt;&lt;/p&gt; 12345678910111213141516//isOpenCookie这个方法需要传一个id用来给用户显示提示语。function isOpenCookie(id) &#123; var cookieTips = document.getElementById(id); var result = window.navigator.cookieEnabled; if (result) &#123; cookieTips.style.color = '#269d26'; cookieTips.style.fontSize = '18px'; cookieTips.innerHTML = '您的cookie已激活!'; &#125; else &#123; cookieTips.style.color = '#f00'; cookieTips.style.fontSize = '18px'; cookieTips.innerHTML = '您的cookie未激活，可能不能享受好的服务!'; &#125; return result;&#125;console.log(isOpenCookie('cookieTips')); // true cookie的属性cookie的属性有名字和值，最大期限，当前可以访问cookie信息的文件路径，可以访问cookie的网站域名，还有安全性属性，下面一一介绍。 名字和值这个就是name和value属性了，name是你要存的数据的名字，value是你要存的名字对应的值。 由于这个值是明文可见的，非常的不安全，所以你要进行编码和解码操作，可以使用以下两种方法： 早期的方法：escape()编码，unescape()解码；（已废弃，但可以用） 新的方法：encodeURIComponent()编码，decodeURIComponent()解码。 方法： document.cookie = &quot;&lt;名字&gt;=&lt;值&gt;&quot;。 例如：document.cookie = &quot;title=&quot; + encodeURIComponent(&#39;世界那么大&#39;)。 最大期限最大期限之前是expires属性（已废弃）；现在是max-age来表示，它接收秒作为单位。 方法： document.cookie = &quot;max-age=&lt;数字&gt;&quot;。 例如：document.cookie = &quot;title=&quot; + encodeURIComponent(&#39;你好啊&#39;) + &quot;;max-age=&quot; + 60*60*24*7;。 pathpath就是当前文件所在的目录，在这个目录下的所以网页都可以共享这个cookie信息，但是不在这个路径下的网页就享受不到这个cookie信息了。 比如说：test.html在server这个目录下，test.html的网页设置了cookie，那么这个server下面的其他网页也可以共享这一个cookie信息；但是不在server这个目录下的网页就享受不到这个cookie信息了。 可以通过设置这个属性来告诉游览器哪些目录下的网页可以获取cookie信息。 方法： document.cookie = &quot;path=&#39;&lt;文件路径名字&gt;&#39;&quot;。 例如：document.cookie = &quot;title=&quot; + encodeURIComponent(&#39;你好啊&#39;) + &quot;;max-age=&quot; + 60*60*24*7 + &#39;;path=&#39; + &#39;/&#39;;。 domaindomain就是当前html文件所在的这个网站（不包括二级域名），在这个网站下的所以网页都可以共享这个cookie信息，但是不在这个网站下的网页就享受不到这个cookie信息了。 比如说：test.html在http://www.examle.com这个目录下，test.html的网页设置了cookie，那么这个http://www.examle.com网站下面的其他网页也可以共享这一个cookie信息；但是不在http://www.examle.com这个网站下的网站（比如：http://blog.examle.com）网页就享受不到这个cookie信息了。 可以通过设置这个属性来告诉游览器哪些网站可以获取cookie信息。 方法： document.cookie = &quot;domain=&#39;&lt;网站域名&gt;&#39;&quot;。 例如：document.cookie = &quot;title=&quot; + encodeURIComponent(&#39;你好啊&#39;) + &quot;;max-age=&quot; + 60*60*24*7 + &#39;;domain=&#39; + &#39;127.0.0.1&#39;; 那么其他的比如说localhost下面的网页无法获取cookie信息。 secure这个属性是一个布尔值，如果添加到一条cookie记录中，那么这个cookie只能在带有https安全协议或者其他安全协议的网站下面进行存取。 例如:document.cookie = &quot;title=&quot; + encodeURIComponent(&#39;你好啊&#39;) + &quot;;max-age=&quot; + 60*60*24*7 + &#39;;secure&#39; cookie的方法设置cookie可以通过封装一个方法来方便的设置cookie，下面是我封装的一个设置cookie的方法，里面要传五个参数，分别对于五个属性。 原理就是对传入的参数进行类型检测，然后遍历对象的属性和值进行存储。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function setCookie(name,value,maxAge,path,domain,secure) &#123; //检测flag var cookieinfo = &#123; name: name, value: value, maxAge: maxAge, path: path, domain: domain, secure: secure &#125;; var res = ''; //验证值 for(key in cookieinfo) &#123; var val = cookieinfo[key]; if (key == 'path') &#123; if (!val) &#123; continue; &#125;else if (typeof val != 'string') &#123; throw new Error('Error: path must be an string!'); &#125; &#125;else if (key == 'domain') &#123; if (!val) &#123; continue; &#125;else if (typeof val != 'string') &#123; throw new Error('Error: domain must be an string!'); &#125; &#125;else if (key == 'secure') &#123; if (!val) &#123; continue; &#125;else if (typeof val != 'boolean') &#123; throw new Error('Error: secure must be an boolean!'); &#125; &#125;else if (val == '' || val == undefined || val == null) &#123; throw new Error('Error:' + key + ' not a null value!'); &#125; &#125; //赋值 for (var key in cookieinfo) &#123; var val = cookieinfo[key]; if (val == undefined) &#123; continue; &#125; if (key == 'value') &#123; continue; &#125; if (key == 'name') &#123; res += cookieinfo['name'] + '=' + encodeURIComponent(cookieinfo['value']) + ';'; &#125;else if (key == 'maxAge') &#123; res += 'max-age' + '=' + cookieinfo['maxAge'] + ';'; &#125; else if (key == 'secure' &amp;&amp; cookieinfo['secure'] === true) &#123; res += 'secure;'; &#125; else &#123; res += key + '=' + val + ';'; &#125; &#125; if (res) &#123; document.cookie = res; &#125;&#125;//例如：setCookie('title',document.title,60*60*24*7,'/','127.0.0.1',secure); 读取cookie可以通过封装一个方法来方便的读取cookie，下面是我封装的一个读取cookie的方法，里面要传两个参数，第一个是布尔值，true表示获取全部cookie,false表示不用；第二个参数是你要获取的cookie名字。 原理就是对cookie进行分解，然后再进行对比，返回相应的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function getCookie(isAll,name) &#123; var tisAll = isAll; var tname = name; if (typeof tisAll != 'boolean') &#123; throw new Error('Error: tisAll not an boolean!'); &#125; if (!tisAll) &#123; if (tname == 'undefined' || tname == null || tname == '' || typeof tname == 'object' || typeof tname == 'function') &#123; throw new Error('Error: name not an object or function or undefined!'); &#125; &#125; var cookie = document.cookie; var cookies = cookie.split(';'); var value = ''; var allObj = &#123;&#125;; for(var i=0;i&lt;cookies.length;i++) &#123; var vals = cookies[i].split('='); var allKey = vals[0].trim(); var allVal = decodeURIComponent(vals[1]); if (allKey == '' &amp;&amp; allVal == '') &#123; continue; &#125; else &#123; if (tisAll) &#123; allObj[allKey] = allVal; &#125; else &#123; if (tname == allKey) &#123; value = allVal; &#125; &#125; &#125; &#125; if (!tisAll &amp;&amp; value == '') &#123; throw new Error('Error:' + tname + ' not found!'); &#125; if (tisAll) &#123; for (var key in allObj) &#123; if (key == '' &amp;&amp; allObj[key] == 'undefined') &#123; throw new Error('Error: all cookie not found!'); &#125; &#125; &#125; var res = tisAll ? allObj : value; return res;&#125;//例如：上面的cookie值console.log(getCookie(false,'title')); // 你好啊 删除cookie可以通过封装一个方法来方便的删除cookie，下面是我封装的一个删除cookie的方法，里面要传一个参数，参数是你要删除的cookie名字。 原理：只要设置这个cookie的期限为0，就可以删除这个cookie了。 12345678910111213141516171819202122function removeCookie(name) &#123; if (name == '' || name == undefined || name == null) &#123; throw new Error('Error: name not an null!'); &#125; var cookie = document.cookie; var cookies = cookie.split(';'); var res; for(var i=0;i&lt;cookies.length;i++) &#123; var vals = cookies[i].split('='); var allKey = vals[0].trim(); if (name == allKey) &#123; res = true; &#125; &#125; if (!res) &#123; throw new Error('Error:' + name +' not found!'); &#125; document.cookie = name + '=' + '' + ';max-age=0';&#125;//例如：删除上面的titleremoveCookie('title'); 写在最后有关cookie的知识点就讲这么多，老铁，赶快用起来吧！","categories":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/tags/javascript/"},{"name":"cookie操作","slug":"cookie操作","permalink":"https://guanqi.xyz/tags/cookie操作/"}]},{"title":"js之DOM详解","slug":"js-dom-detailed","date":"2019-01-27T01:35:21.000Z","updated":"2019-07-14T08:04:16.770Z","comments":true,"path":"/note/js-dom-detailed/","link":"","permalink":"https://guanqi.xyz/note/js-dom-detailed/","excerpt":"","text":"导语：之前说过BOM是游览器对象模型，提供了很多操作游览器、操作窗口的属性和方法。那从今天开始讲述有关DOM的知识点。 DOM的概念DOM英文全称是Document Object Model,简称DOM，含义是文档对象模型。这个是核心的js语法所没有的，是对核心js的扩展。 每个游览器窗口都显示一个HTML文档，那每个窗口就有一个Window对象，而它的属性document就是引用的Document对象。 DOM的发展也是一步步来的，从最开始的Netscape和ie指定的一些DOM操作属性和方法；到1998年10月，W3C组织制定了1级DOM标准，到2000年发布了2级DOM标准，DOM的功能也在不断的扩展补充，从最开始的静态显示到后面的动态读写，逐步完善起来。 注意：这里指的文档是HTML文档，HTML文档被人们习惯性的叫做网页。 0级DOM(旧规范)属性 title,文档的标题；位于&lt;title&gt;&lt;/title&gt;之间的文本； cookie,一个特殊属性,允许js可以读写HTTP Cookie； domain,可以使在同一域中的相互信任的服务器之间进行网页交互避免同源策略安全性的限制； lastModified,文档的修改日期； referrer,文档的URL，包含游览器带到当前文档的链接； URL，等同于Window对象的属性location.href； location,等价于属性URL,（现已废弃）； bgColor,文档的背景颜色，（现已废弃）； 例如： 12345678console.log('文档的标题：',document.title); // 文档的标题： Documentconsole.log('cookie值：',document.cookie); // cookie值：console.log('文档的域：',document.domain); // 文档的域： localhostconsole.log('文档的最新修改日期：',document.lastModified); // 文档的最新修改日期： 01/27/2019 09:02:46console.log('文档的链接：',document.referrer); // 文档的链接： http://localhost:2009/test.htmlconsole.log('文档的背景颜色：',document.bgColor = '#f808080'); // 文档的背景颜色： #f00console.log('文档的当前链接：',document.location); // 文档的当前链接： Location &#123;replace: ƒ, assign: ƒ, href: \"http://localhost:2009/test.html\"…&#125;console.log('文档的链接地址：',document.URL); // 文档的链接地址： http://localhost:2009/test.html 案例防止外链，当游览者在网站的其他页面，可以跳转到当前主页，再去访问其他页。 1234// 检测是否本网站域名，跳转到本网站主页if (document.referrer == '' || document.referrer.indexOf(\"example.com\") == -1) &#123; document.location = 'http://www.example.com';&#125; 方法这个方法就是向当前文档中插入一个文本，它有时会覆盖到已存在的一些文本，所以最好在文档解析完成后再调用此方法。 和open()以及close()方法一起组合会更加好。 例如： 1234567function hello() &#123; var d = window.document; d.open(); d.write('&lt;h2&gt;Hello,world!&lt;/h2&gt;'); d.close();&#125;hello(); 文档对象集合这个也是0级DOM中遗留下来的一些属性和方法，不过它们的值都是数组，可以访问文档的 某些元素。 anchors[], Anchors对象的一个数组，该对象代表文档中的锚，就是&lt;a&gt;的name属性。 links[], Links对象的一个数组，该对象代表文档中的超文本链接，就是&lt;a&gt;的href属性,也包括通过&lt;area&gt;标记创建的热点链接属性。 images[], Images对象的一个数组，该对象代表文档中的&lt;img&gt;元素，Images对象的src属性是可以赋值的。可以实现图像翻滚和简单动画。 forms[], Forms对象的一个数组，该对象代表文档中的&lt;form&gt;表单元素，每个Forms对象都有自己的一个名为elements[]的集合属性。 案例展示获取表单元素文档中有一个表单名称叫login,有一个表单元素叫username，那么就可以使用命名Document对象的方法，直接用元素的name属性来命名。 123&lt;form name=\"login\"&gt; &lt;input type=\"text\" name=\"username\"&gt;&lt;/form&gt; 1234// 第一个就是表示这个表单，表单的可以用forms[按照文档的顺序第几个表单索引]，表单的元素用elements[这个表单的按照表单里面的顺序第几个元素]。var login = document.forms[0] || document.login;var username = document.forms[0].elements[0] || document.login.username;console.log(login,username); 注意：如果文档中有两个表单name一样，它会返回一个数组，所以要尽量保持name属性在文档中的唯一性。 获取文档中所有的链接123&lt;a href=\"#1\"&gt;链接1&lt;/a&gt;&lt;a href=\"#2\"&gt;链接2&lt;/a&gt;&lt;a href=\"#3\"&gt;链接3&lt;/a&gt; 12var links = document.links;console.log('所有的链接：',links); // 所有的链接： HTMLCollection(7) [a, a, a, a, a, a, a] 1级DOM(W3C标准)之前的DOM都是被一些公司操作着定义着用法内容，是老早的约定俗成的东西，但是缺乏规范和标准。W3C组织在1998年10月发布了DOM的标准，被后人成为1级DOM标准，它规定了DOM的一些属性和方法，包括DOM树，节点操作，属性操作，以及对html文档元素进行的创建、获取、修改、删除以及添加和插入等操作方法。 DOM树html是嵌套的有层级关系的一种超文本标记语言，在DOM就表示对象的一棵树。这个树从树根开始，到下面的元素节点，文本节点，组成了一颗树。 例如：这是最简单的一颗DOM树。 123456789&lt;html&gt;&lt;head&gt; &lt;title&gt;DOM树&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;DOM树&lt;/h2&gt; &lt;p&gt;你好，DOM树！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; DOM节点每一个元素都是一个节点，有元素节点，文本节点等，每个节点都由Node对象定义类型，用nodeType属性来表示。 节点列表: 序号 接口 nodeType常量 nodeType值 1 Element Node.ELEMENT_NODE 1 2 Text Node.TEXT_NODE 3 3 Document Node.DOCUMENT_NODE 9 4 Comment Node.COMMENT_NODE 8 5 DocumentFragment Node.DOCUMENTFRAGMENT_NODE 11 6 Attr Node.ATTRIBUTE_NODE 2 DOM树根部的Node是一个Document对象，这个对象的documentElement属性引用了一个Element对象，代表了文档的根元素。那以此类推，代表body这个节点的就是body。 补充：DOM的节点总的来说分为四个大的板块。 第一个是Document代表文档节点，就是HTMLDocument; 第二个是CharacterData代表就是文本和注释节点，Text和Comment; 第三个就Element代表着元素节点HTMLElement，比如像head、body、title等。 第四个是属性节点Attr，包括元素的各个属性。 节点还有父节点、子节点、兄弟节点等关系的节点，这个关系的节点都有对应的元素。 父节点和元素，parentNode，parentElement； 子节点和元素，childNodes,children; 当前节点的第一个子节点和元素，firstChild,firstElementChild; 当前节点的最后一个子节点和元素，lastChild,lastElementChild; 上一个兄弟节点和元素，previousSibling,previousElementSibling; 下一个兄弟节点和元素，nextSibling,nextElementSibling; 节点案例获取一个元素的各类节点以及元素这个案例就是如何表示一个元素的各类节点。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;DOM树&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;DOM树&lt;/h2&gt; &lt;h3&gt;兄弟&lt;/h3&gt; &lt;p&gt; &lt;span&gt;你好，DOM树！&lt;/span&gt; &lt;span&gt;你好，DOM节点！&lt;/span&gt; &lt;span&gt;你好，DOM节点对应的元素！&lt;/span&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324var helem = document.getElementsByTagName('h3')[0];var pelem = document.getElementsByTagName('p')[0];//1.helem的父节点，爷爷节点以及元素。var parent = helem.parentNode;var grandParent = parent.parentNode;var parentElem = helem.parentElement;var grandParentElem = parentElem.parentElement;console.log(parent,grandParent,parentElem,grandParentElem);//2.helem的子节点，第一个和最后一个子节点以及元素。var childs = pelem.childNodes;var firstChild = pelem.firstChild;var lastChild = pelem.lastChild;var childsElem = pelem.children;var firstChildElem = pelem.firstElementChild;var lastChildElem = pelem.lastElementChild;console.log(childs,firstChild,lastChild,childsElem,firstChildElem,lastChildElem); //3.helem的兄弟节点,下一个兄弟节点，上一个兄弟节点以及元素。var nextSibling = helem.nextSibling;var previousSibling = helem.previousSibling;var nextSiblingElem = helem.nextElementSibling;var previousSiblingElem = helem.previousElementSibling;console.log(nextSibling,previousSibling,nextSiblingElem,previousSiblingElem); 属性操作元素的属性操作方法： 获取属性getAttribute(); 设置属性setAttribute(); 移除属性removeAttribute(); 例如：一个链接元素的属性操作。由于还没有涉及到元素的一些操作，这里还是以0级DOM的方法来做。 1&lt;a href=\"\"&gt;属性操作&lt;/a&gt; 123456789101112131415//获取元素var linka = document.links[0];//设置属性linka.setAttribute('title','属性提示语');linka.setAttribute('class','属性类');console.log(linka); // &lt;a href=\"\" title=\"属性提示语\" class=\"attr\"&gt;属性操作&lt;/a&gt;//获取属性linka.getAttribute('class');console.log(cls); // attr//移除属性linka.removeAttribute('title');console.log(linka); // &lt;a href=\"\" class=\"attr\"&gt;属性操作&lt;/a&gt; 元素的操作下面就是对html文档元素进行的创建、获取、修改、删除以及添加和插入等操作方法。 获取元素获取元素有以下几种方法，都是Document对象下面的方法。分别从不同的方面进行获取元素，如通过id获取元素；通过标签名称获取元素，这个获取到就是类数组，会返回一个类似于数组的结果。 通过元素的id名称来获取：document.getElementById(&lt;id名称&gt;); 通过元素的标签名称来获取：document.getElementsByTagName(&lt;标签名称&gt;); 通过元素的name属性名称来获取：document.getElementsByName(&lt;name属性名称&gt;); 通过元素的class名称来获取：document.getElementsByClassName(&lt;class名称&gt;); 注意:除了id以外，其他的都是类数组，可以用下标来表示某个元素。 例如：获取链接和输入框。 1234&lt;a id=\"food\" class=\"myfood\" href=\"#1\"&gt;香蕉&lt;/a&gt;&lt;a class=\"myfood\" href=\"#2\"&gt;苹果&lt;/a&gt;&lt;a class=\"myfood\" href=\"#3\"&gt;葡萄&lt;/a&gt;&lt;input type=\"text\" name=\"username\"&gt; 12345678910111213141516171819//通过idvar banana = document.getElementById('food');console.log(banana); // &lt;a id=\"food\" class=\"myfood\" href=\"#1\"&gt;香蕉&lt;/a&gt;//通过标签名称var links = document.getElementsByTagName('a');console.log(links); // HTMLCollection(4) [a.attr, a#food.myfood, a.myfood, a.myfood, food: a#food.myfood]// 通过name属性名称var username = document.getElementsByName('username');console.log(username); // NodeList [input]// 通过class名称var myfood = document.getElementsByClassName('myfood');console.log(myfood); // HTMLCollection(3) [a#food.myfood, a.myfood, a.myfood, food: a#food.myfood]// 获取类数组的第一个var myfoodOne = document.getElementsByClassName('myfood')[0];console.log(myfoodOne); // &lt;a id=\"food\" class=\"myfood\" href=\"#1\"&gt;香蕉&lt;/a&gt; 创建元素这个就是用document的方法来创建一个标签元素或者一个文本元素。 方法就是： 标签元素：document.createElement(&#39;&lt;元素名称&gt;&#39;); 文本元素：document.createTextNode(&#39;&lt;文本内容&gt;&#39;); 例如：创建一个a标签，还有一个内容为你好，元素的文本。 1234567// 创建链接元素var linka = document.createElement('a');console.log('linka:',linka); // linka: &lt;a&gt;​&lt;/a&gt;​// 创建打招呼文本var txta = document.createTextNode('你好，元素');console.log('txta:',txta); // txta: \"你好，元素\" 添加元素这个就是把一个元素或者文本添加到另一个元素的内容里面去。 用法：&lt;另一个元素&gt;.appendChild(&lt;要添加的元素&gt;)。 例如：把一个文本添加到一个链接中。 123456789// 创建链接元素var linka = document.createElement('a');// 创建打招呼文本var txta = document.createTextNode('你好，元素');//添加元素linka.appendChild(txta);console.log('linka:',linka); // linka: &lt;a&gt;​你好，元素​&lt;/a&gt;​ 修改元素修改元素的属性可以使用上面讲到的属性操作方法，这里主要讲修改元素的内容。 修改元素的内容有以下几种方法： 往元素里面添加新的文本内容：&lt;要修改的元素&gt;.innerText = &#39;&lt;新的内容&gt;&#39;; 往元素里面添加新的html元素和内容：&lt;要修改的元素&gt;.innerHTML = &#39;&lt;新的内容&gt;&#39; 注意：它们两个的区别就是innerText只是修改元素的内容文本，相当于创建了一个文本节点，然后添加到这个元素中，改变的只有元素的内容；而innerHTML,不仅修改元素的内容文本，还可以添加嵌套的元素和元素自己的属性和内容，相当于创建了一个元素和文本节点，并且赋予元素属性和属性值，然后添加到这个要修改的元素中。 例如:修改段落标签的内容，往段落标签里面添加一个链接，链接的class叫linka,href属性值叫#1,内容叫我是新链接。 12&lt;p id=\"con\"&gt;&lt;/p&gt;&lt;a id=\"linkb\" href=\"#1\"&gt;&lt;/a&gt; 12345678//只添加文本var linkb = document.getElementById('linkb');linkb.innerText = '你好，我的朋友！';console.log(linkb); // &lt;a id=\"linkb\" href=\"#1\"&gt;你好，我的朋友！&lt;/a&gt;//添加元素和文本var con = document.getElementById('con');con.innerHTML = '&lt;a class=\"linka\" href=\"#1\"&gt;我是新链接&lt;/a&gt;';console.log(con); // &lt;p id=\"con\"&gt;&lt;a class=\"linka\" href=\"#1\"&gt;我是新链接&lt;/a&gt;&lt;/p&gt; 其实也可以使用上面的方法来实现，不过比较麻烦一点。 1234567var con = document.getElementById('con');var linkb = document.createElement('a');linkb.setAttribute('href','#1');linkb.setAttribute('class','linka');var txtb = document.createTextNode('我是新链接');linkb.appendChild(txtb);con.appendChild(linkb); 插入元素插入元素就是把一个子元素插入到父元素中，方法就是&lt;父元素&gt;.insertBefore(&lt;子元素&gt;,&lt;插入子元素的位置&gt;)。 例如：往一个列表中插入一个子元素。 12345&lt;ul id=\"list\"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt; 1234567var list = document.getElementById('list');var lia = document.createElement('li');var txtc = document.createTextNode('葡萄');var lastElem = list.lastElementChild;lia.appendChild(txtc);list.insertBefore(lia,lastElem);console.log(list); // &lt;ul id=\"list\"&gt;&lt;li&gt;苹果&lt;/li&gt;&lt;li&gt;香蕉&lt;/li&gt;&lt;li&gt;葡萄&lt;/li&gt;&lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt; 替换元素替换元素就是把当前元素的子元素给替换成另外一个子元素，方法就是&lt;父元素&gt;.removeChild(&lt;要替换的子元素&gt;)。 例如：从列表中把苹果替换成葡萄。 12345&lt;ul id=\"list\"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt; 1234567var list = document.getElementById('list');var apple = list.firstElementChild;var putao = document.createElement('li');var txta = document.createTextNode('葡萄');putao.appendChild(txta);list.replaceChild(putao,apple);console.log(list); // &lt;ul id=\"list\"&gt;&lt;li&gt;葡萄&lt;/li&gt;&lt;li&gt;香蕉&lt;/li&gt;&lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt; 克隆元素克隆元素其实就是复制一个元素，分为以下两种： 深克隆，又叫深拷贝。就是既克隆元素本身，又克隆元素的子节点和节点的内容。 浅克隆，又叫浅拷贝。只是克隆节点本身，不包括节点的内容。 方法就是：&lt;要克隆的节点&gt;.cloneNode(&lt;deep: boolean&gt;),这个参数是接收一个布尔值，true就是深拷贝，false就是浅拷贝。 例如：克隆一个苹果。 12345&lt;ul id=\"list\"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt; 1234567891011var list = document.getElementById('list');var apple = list.firstElementChild;//浅拷贝var appleOne = apple.cloneNode(false);list.appendChild(appleOne);console.log(list); //&lt;ul id=\"list\"&gt;&lt;li&gt;苹果&lt;/li&gt;&lt;li&gt;香蕉&lt;/li&gt;&lt;li&gt;梨子&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;//深拷贝var appleOne = apple.cloneNode(true);list.appendChild(appleOne);console.log(list); //&lt;ul id=\"list\"&gt;&lt;li&gt;苹果&lt;/li&gt;&lt;li&gt;香蕉&lt;/li&gt;&lt;li&gt;梨子&lt;/li&gt;&lt;li&gt;苹果&lt;/li&gt;&lt;/ul&gt; 删除元素删除元素就是把一个子元素从到父元素中删去，方法就是&lt;父元素&gt;.removeChild(&lt;要删除的子元素&gt;)。 例如：从列表中删除最后一个子元素。 12345&lt;ul id=\"list\"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt; 1234var list = document.getElementById('list');var lastElem = list.lastElementChild;list.removeChild(lastElem);console.log(list); // &lt;ul id=\"list\"&gt;&lt;li&gt;苹果&lt;/li&gt;&lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt; 温馨提示:上面这些操作可以写成函数封装起来，日后使用比较方便了。 比如说获取元素是经常用到的，就写一个函数就可以了。 1234567891011121314151617181920212223242526//获取元素function getElem(name) &#123; var result; var $d = document; if (name.indexOf('#') != -1) &#123; name = name.split('#')[1]; result = $d.getElementById(name); &#125; else if (name.indexOf('.') != -1) &#123; name = name.split('.')[1]; result = $d.getElementsByClassName(name); &#125; else if (name.indexOf('%') != -1) &#123; name = name.split('%')[1]; result = $d.getElementsByTagName(name); &#125; else if (name.indexOf('&amp;') != -1) &#123; name = name.split('&amp;')[1]; result = $d.getElementsByName(name); &#125; return result;&#125;//例如：获取p标签var w1 = getElem('#con');var w2 = getElem('.cons');var w3 = getElem('%p');//获取输入框var w4 = getElem('&amp;user'); 12&lt;p id=\"con\" class=\"cons\"&gt;CSS样式脚本化的内容&lt;/p&gt;&lt;input type=\"text\" name=\"user\"&gt; CSSDOMCSSDOM就是DOM对于CSS样式进行脚本化，可以很轻松的创建动态的html文档，之前因为这个原因还出现了DHTML，文档不再是静态的文本和媒体等内容了，而是可以动态的获取和操作。 CSSDOM的操作有以下几种： Document对象的styleSheets来表示； 通过style这个属性来控制元素的样式变化的， 通过className可以给元素添加类名。 styleSheets[]数组通过Document对象引用的CSSStyleSheet对象属性和方法。可以用这个document.styleSheets[]就可以获取到所有的样式。 如果这个文档中引用了3个样式表，那么就会返回这3个样式表所定义的样式规则内容。 第一个样式表就可以用这样来表示document.styleSheets[0]。 属性：每个样式表都有以下几个属性 cssRules和rules，这里面记录着每一条规则的内容； disabled，这个属性表示这个样式表是否禁用掉，默认是false； href，这个属性表示这个样式表的url地址； type，这个样式表的类型。 例如： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;CSS样式脚本化&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"jbh.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;CSS样式脚本化&lt;/h2&gt; &lt;p&gt;CSS样式脚本化的内容&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112body &#123; margin: 0; padding: 0;&#125;h2 &#123; color: #f00; font-size: 20px;&#125;p &#123; padding: 5px 10px; color: #eee;&#125; 123456789var allstyle = document.styleSheets[0];var cssRules = allstyle.cssRules;var disabled = allstyle.disabled;var href = allstyle.href;var type = allstyle.type;console.log('规则：',cssRules); // CSSRuleList &#123;0: CSSStyleRule, 1: CSSStyleRule, 2: CSSStyleRule, length: 3&#125;console.log('是否禁用：',disabled); // falseconsole.log('url地址：',href); // url地址： http://localhost:2009/day/jbh.cssconsole.log('类型：',type); // 类型： text/css style属性控制这个就是通过html的style标签来控制元素的样式，适用于内联样式和内嵌样式。优先级比外部样式表要大，就是可以把外部样式表的样式给覆盖掉。 注意：这个style只是可以获取和改变文档内部的样式规则，对于外链的样式表，无法获取和改变样式的属性。 提示： 例如：给一个链接加上颜色和大小。 1&lt;p&gt;CSS样式脚本化的内容&lt;/p&gt; 123var con = document.getElementById('con');con.style.color = '#f00';con.style.fontSize = '20px'; className这个className就是给元素直接添加类名。只要文档内部或者外链样式表有这个类名的css规则就可以加上去。 用法：&lt;要加类名的元素&gt;.className=&quot;&lt;类名&gt;&quot;。 例如：给一个段落加一个类名。 1&lt;p&gt;给我加类名吧！&lt;/p&gt; 12345.con &#123; padding: 5px 10px; height: 300px; color: #eee;&#125; 123var con = document.getElementsByTagName('p')[0];con.className = 'con';console.log(con); // &lt;p class=\"con\"&gt;给我加类名吧！&lt;/p&gt; classList这个classList就是给元素直接添加多个类名。 用法：&lt;要加类名的元素&gt;.classList=&quot;&lt;类名1 类名2 类名3 ...&gt;&quot;，类名之间要空格。 例如：给一个段落加一个类名。 1&lt;p&gt;给我加多个类名吧！&lt;/p&gt; 123456789.con &#123; padding: 5px 10px;&#125;.con1 &#123; height: 300px;&#125;.con2 &#123; color: #eee;&#125; 123var con = document.getElementsByTagName('p')[0];con.classList = 'con con1 con2';console.log(con); // &lt;p class=\"con con1 con2\"&gt;给我加类名吧！&lt;/p&gt; DOM标准支持表由于游览器的各处林立，导致制定的标准在每个游览器的支持都不一样，下面这个表是有关如何查询游览器支持哪些DOM标准的。 Document对象的implementation引用了DOMImplementation对象，定义了一个方法用来查询是否支持。 方法用法：hasFeature(name,version);里面包含两个参数，第一个是你要查询的标准名称，你要查询的DOM级别。 在这里我封装了一个方法，可以用来查询，如果返回true说明支持，反之则不支持。 123456789101112function searchDomSupport(name,version) &#123; if (document.implementation &amp;&amp; document.implementation.hasFeature &amp;&amp; document.implementation.hasFeature(name,version) ) &#123; return true; &#125; else &#123; return false; &#125;&#125;var res = searchDomSupport('html','1.0');console.log(res); // true; 附表： 序号 特性名称 版本 说明 暗示 1 HTML 1.0 1级的Core和HTML接口 无 2 XML 1.0 1级的Core和XML接口 无 3 Core 2.0 2级的Core接口 无 4 HTML 2.0 2级的HTML接口 Core 5 XML 2.0 2级的XML专有接口 Core 6 Views 2.0 AbstractView接口 Core 7 StyleSheets 2.0 通用样式表遍历 Core 8 CSS 2.0 CSS样式 Core,Views 9 CSS2 2.0 CSS2Properties接口 CSS 10 Events 2.0 事件处理基础结构 Core 11 UIEvents 2.0 用户接口事件(Events+ Views) Events,Views 12 MouseEvents 2.0 Mouse事件 UIEvents 13 HTMLEvents 2.0 HTML事件 Events 提示：有时候这个方法可能不是太准确，兼容性不是很好。 这里提供两个网站，上面有着各个游览器的的兼容性的处理方法。 Peter Paul Koch的著名站点： quirksmode 这个站点提供了作者DOM和CSS标准对于游览器兼容性的进行广泛研究后的成果。 David Hammond的：webdevout 优缺点一个对象的出现，既有优点，又有缺点，不过缺点大于优点。 优点 易用性强 把文档信息都存于内存中，遍历简单方便 缺点 解析速度慢，占内存过高，非常大的文件就不适合操作； 在DOM运行的过程中，创建和修改、删除了大量的对象，机制不健全，导致效率低下，消耗了大量的时间 DOM有风险，使用需谨慎。切记，切记。 写在最后因为DOM在不断的发展，内容规则和标准在不断的扩展。所以今天讲的是0级和1级DOM的有关知识点。因为内容太多，所以有关2级DOM的内容放在以后来说。其实上面的内容已经非常多了，需要慢慢的去使用。实践出真知，理论联系实践，相信你自己一定可以成功的。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/tags/javascript/"},{"name":"DOM","slug":"DOM","permalink":"https://guanqi.xyz/tags/DOM/"}]},{"title":"js之BOM教程","slug":"js-bom-tutorial","date":"2019-01-25T07:35:21.000Z","updated":"2019-07-14T08:03:03.947Z","comments":true,"path":"/note/js-bom-tutorial/","link":"","permalink":"https://guanqi.xyz/note/js-bom-tutorial/","excerpt":"","text":"导语：今天开始介绍一篇有关BOM知识点的总结文章。 BOM顾名思义，就是游览器对象模型，英文是Browser Object Model的简称。这个套模型定义了JavaScript如何操作游览器窗口以及获取游览器本身的一些信息，包括窗口的各种高度和宽度，滚动高度和宽度，历史纪录，url的相关信息，游览器的相关信息等知识。 Window对象在游览器中，javascript的Window对象就等同于全局对象，并且在该全局对象下定义的属性和方法也就等同于Window对象的属性和方法。 例如：一个变量和一个函数 1234var i=10;console.log(window.i) // 10;function fn() &#123; console.log('fn'); &#125;console.log(window.fn) // ƒ fn() &#123; console.log('fn'); &#125; Window对象自身有很多的属性和方法，以下是几种Window对象中常用的属性和方法。这些方法由于是Window对象下面的方法，所以可以省略不写。 窗口信息这个有些方法ie是document.documentElement.方法，谷歌火狐是document.body.方法。 外边框的宽高用法：宽，window.outerWidth；高window.outerHeight。 例如： 1console.log('外边框的宽高:'+window.outerWidth+'*'+window.outerHeight); // 外边框的宽高:1536*824 内边框的宽高用法：宽，window.innerWidth；高window.innerHeight。 例如： 1console.log('内边框的宽高:'+window.innerWidth+'*'+window.innerHeight); // 内边框的宽高:1164*723 可视窗口的宽高用法：宽，document.documentElement.clientWidth；高document.documentElement.clientHeight。 例如： 1console.log('可视窗口的宽高:'+document.documentElement.clientWidth+'*'+document.documentElement.clientHeight); // 可视窗口的宽高:1164*723 滚动窗口的坐标用法：宽，window.scrollX；高window.scrollY。 例如： 1console.log('滚动窗口的坐标:'+window.scrollX+'*'+window.scrollY); // 滚动窗口的坐标:0*0 滚动窗口的左上用法：左，document.documentElement.scrollLeft；上document.documentElement.scrollTop。 例如： 1console.log('滚动窗口的左上:'+document.documentElement.scrollLeft+'*'+document.documentElement.scrollTop); // 滚动窗口的左上:0*0 元素的宽高左右用法： 左：document.documentElement.offsetLeft； 上：document.documentElement.offsetTop， 宽：document.documentElement.offsetWidth， 高：document.documentElement.offsetHeight。 例如： 1&lt;div class=\"box\" style=\"margin:10px;width:100px;height:100px;\"&gt;盒子&lt;/div&gt; 123var box = document.querySelector('.box');console.log('元素距离距离窗口的宽高:'+box.offsetWidth+'*'+box.offsetHeight); // 元素距离距离窗口的宽高:100*100console.log('元素距离距离窗口的左右:'+box.offsetLeft+'*'+box.offsetTop); // 元素距离距离窗口的左右:18*106 屏幕信息这个是Screen对象的有关属性，Window对象的screen属性就是引用的Screen对象。 显示器的大小用法：宽window.screen.width，高window.screen.height。 例如： 1console.log('显示器的大小:'+window.screen.width+'*'+window.screen.height); // 显示器的大小:1536*864 实际可用的显示大小用法：宽window.screen.availWidth，高window.screen.availHeight。 例如： 1console.log('实际可用的显示大小:'+window.screen.availWidth+'*'+window.screen.availHeight); // 实际可用的显示大小:1536*824 屏幕第一个可用位置的坐标用法：宽window.screen.availLeft，高window.screen.availTop。 例如： 1console.log('屏幕第一个可用位置的坐标:'+window.screen.availLeft+'*'+window.screen.availTop); // 屏幕第一个可用位置的坐标:0*0 对话框对话框就是你可以对它进行操作，但是用户体验稍微差点，所以后来慢慢的，这个对话框就变成了程序完成后调试bug的作用了。 对话框还有一点就是，它阻塞了游览器解析进程，你需要对当前对话框进行操作完成后才能进行下一项渲染，或者是看见了页面内容，或者是开始其他操作。 alert()这个方法就是一个简单的对话框，里面接受一个字符作为显示在游览器窗口的内容。向用户显示信息并且需要用户手动关闭。 用法：window.alert(&lt;内容&gt;);，这个方法是Window对象下面的方法，所以可以省略不写。 这样也可以执行的alert(&lt;内容&gt;);。 例如：window.alert(&#39;欢迎光临本网站！&#39;); confirm()这个方法就是一个简单的对话框，里面需要输入内容，有两个按钮，一个是确定，另一个是取消。它的返回值是布尔值，当你点击确定，会返回true；当你点击取消，会返回false。 用法：confirm(&lt;内容&gt;); 例如： 12var res = confirm('你过年回家吗？');console.log(res ? '我回家' : '我不回家'); // 点击确定：我回家；点击取消： 我不回家 prompt()这个方法就是一个简单的对话框，里面需要输入一个字符串，有两个按钮，一个是确定，另一个是取消。它的返回值是你输入框中的内容，当你点击确定，会返回输入框的内容；当你点击取消，会返回null。 用法：prompt(&lt;字符串&gt;); 例如： 12var res = prompt('你喜欢吃什么小吃？'); // 你可以输入任何字符串，例如我输入了沙县小吃console.log(res); // 点击确定：沙县小吃；点击取消： null 定时器定时器是web客户端里面定义的一个全局方法，核心的JavaScript并没有定义这个方法。 定时器的功能就是在未来某个时间进行某段代码的执行，可以有一次的或者多次的执行。 注意：setTimeout只执行一次，setInterval可以一直连续的执行。 setTimeout()这个方法就是用来使一个函数在指定的时间内（单位是毫秒ms）过去之后执行。这个有时候被拿来模拟ajax异步操作。 用法：setTimeout(fn,time);,第一个参数就是一个函数或者函数的名称，第二个参数就是时间。 例如：一秒后打印我爱你 123456789//1.函数名称setTimeout(fn,1000);function fn() &#123; console.log('我爱你'); // 我爱你&#125;//2.函数setTimeout(function()&#123; console.log('我爱你'); // 我爱你&#125;,1000); clearTimeout()这个方法可以取消setTimeout方法中第一个参数函数的执行。 用法：clearTimeout(函数名称);，参数是setTimeout方法中第一个参数的函数名称。 例如： 1234var fn = setTimeout(function()&#123; console.log('我爱你');&#125;,3000);clearTimeout(fn); setInterval()这个方法就是用来使一个函数在指定的时间内（单位是毫秒ms）重复的调用执行。这个有时候被拿来做模拟时钟或者动画。 用法：setInterval(fn,time);,第一个参数就是一个函数或者函数的名称，第二个参数就是时间。 例如：把当前时间显示在游览器窗口中，并且时间是动态走动。 1&lt;div id=\"time\"&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334//1.函数名称var time = document.querySelector('#time');var timer = setInterval(fn,1000);function fn() &#123; var now = new Date(); var year = now.getFullYear(); var month = now.getMonth() + 1; var day = now.getDay(); var hour = now.getHours(); var minute = now.getMinutes(); var second = now.getSeconds(); month = month &gt;= 10 ? month : '0' + month; day = day &gt;= 10 ? day : '0' + day; hour = hour &gt;= 10 ? hour : '0' + hour; minute = minute &gt;= 10 ? minute : '0' + minute; second = second &gt;= 10 ? second : '0' + second; time.innerHTML = year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second;&#125;//2.函数var timer = setInterval(function()&#123; var now = new Date(); var year = now.getFullYear(); var month = now.getMonth() + 1; var day = now.getDay(); var hour = now.getHours(); var minute = now.getMinutes(); var second = now.getSeconds(); month = month &gt;= 10 ? month : '0' + month; day = day &gt;= 10 ? day : '0' + day; hour = hour &gt;= 10 ? hour : '0' + hour; minute = minute &gt;= 10 ? minute : '0' + minute; second = second &gt;= 10 ? second : '0' + second; time.innerHTML = year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second;&#125;,1000); clearInterval()这个方法可以取消setInterval方法中第一个参数函数的执行，停止重复调用这个函数。 用法：clearInterval(函数名称);，参数是setInterval方法中第一个参数的函数名称。 例如：要取消上面那个例子的时钟走动。 1clearInterval(timer); 打开和关闭新窗口这个可以打开或者关闭一个新窗口，但是随着时代经济的发展，越来越多的网站把它用于投放展示广告，导致很多游览器封杀了这两个方法，除非是用户自己点击新窗口。 open()这个方法是可以打开一个新的窗口。 用法：open(一参,二参,三参,四参);，以下是参数说明： 第一参数是你要打开新窗口的url； 第二个参数是你要打开新窗口的名称，可以是a标签的target属性中的值，也可以自定义； 第三个参数是新窗口的一些属性定义，比如说状态了，宽和高，也没有菜单栏等； 第四个参数是是否覆盖掉当前的页面历史纪录，如果是true，那就覆盖掉，否则就新增一条历史记录。 例如：打开一个宽高为300*400的，显示状态栏的，内容为你好，世界，不覆盖当前url的历史纪录的一个新窗口。 12345678910111213&lt;!-- 保存为new.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;新窗口&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;你好，世界&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 1234function openNew() &#123; window.open('new.html','width=200,height=200,status=yes',false);&#125;openNew(); close()这个方法是关闭当前的窗口网页。 用法：close(); 例如： 1234function closeWin() &#123; window.close();&#125;closeWin(); Location对象这个Location对象提供了当前文档的url的一些信息，包括协议，域名，端口号，url参数等信息。 窗口的location属性引用的是Location对象。它代表当前文档的url信息。 location的属性用法：window.location，属性包括： protocol 网页通信协议； host 网页域名（包括域名和端口）； hostname 网页域名名字（）； port 端口号 href 网页地址 hash 哈希值 search 参数内容（包括?号） 123456789101112131415161718console.log('url信息：',window.location);/* url信息：Location &#123; ancestorOrigins: DOMStringList &#123;length: 0&#125; assign: ƒ () hash: \"\" host: \"localhost:2009\" hostname: \"localhost\" href: \"http://localhost:2009/test.html\" origin: \"http://localhost:2009\" pathname: \"test.html\" port: \"2009\" protocol: \"http:\" reload: ƒ reload() replace: ƒ () search: \"\" toString: ƒ toString()*/ location的方法 reload();重新载入当前网页 location或者location.href; 载入新的网页url replace(); 重新载入当前网页（会覆盖掉当前网页的历史纪录） 例如： 1234567//1.重新载入当前网页window.location.reload();//2.载入新的网页urlwindow.location = 'test.html';window.location.href = 'test.html';//3.重新载入当前网页（会覆盖掉当前网页的历史纪录）window.location.replace(); 案例：解析url的参数12345678910111213141516var url = 'http://www.abc.com/index?name=keke&amp;type=1';function getUrlArgs() &#123; var args = new Object(); var query = location.search.substring(1); var pairs = query.split('&amp;'); for(var i=0;i&lt;pairs.length;i++) &#123; var pos = pairs[i].indexOf('='); if (pos == -1) &#123; continue; &#125; var argname = pairs[i].substring(0,pos); var value = pairs[i].substring(pos+1); value = decodeURIComponent(value); args[argname] = value; &#125; return args;&#125;console.log(getUrlArgs()); // &#123; name: \"keke\", type: \"1\" &#125; History对象这个History对象可以允许载入新的文档或者游览器后退或者前进游览过的文档。 窗口的history属性引用的是History对象。 forward()这个方法可以使游览器载入到新文档，和游览器的前进箭头按钮功能一样。 用法：forward();，不需要传参。 例如： 1234function forwardTo() &#123; history.forward();&#125;forwardTo(); back()这个方法可以使游览器后退到以前游览过的网页，和游览器的后退箭头按钮功能一样。 用法：back();，不需要传参。 例如： 1234function backTo() &#123; history.back();&#125;backTo(); go()这个方法可以使游览器前进或者后退到以前游览过的网页。 用法：go();，需要传参，正参就是前进几个历史纪录，负参就是后退几个历史纪录。 例如： 12345function goTo(val) &#123; history.go(val);&#125;goTo(1);goTo(-1); Navigation对象这个Navigation对象可以储存的当前游览器的信息，包括版本号，app名称，游览器内核名称，系统版本等。 Window对象的navigator属性引用的是Navigation对象。 打印查看当前游览器信息直接执行console.log(window.navigator)就可以了。 常用的属性 appName，游览器的简称； appVersion，游览器的内部版本号； appCodeName，游览器的代码名称； platform，运行游览器的硬件平台； userAgent，用户代理，游览器在它的USER-AGENT HTTP头部发送字符串。 例如：打印当前游览器的信息 1234567891011121314151617181920function getnNavigatorInfo() &#123; var obj = new Object(); var proArr = ['appName','appVersion','appCodeName','platform','userAgent']; for (var key in navigator) &#123; for(var i=0;i&lt;proArr.length;i++) &#123; if (key == proArr[i]) &#123; obj[key] = navigator[key]; &#125; &#125; &#125; return obj;&#125;console.log(getnNavigatorInfo());/*appCodeName: \"Mozilla\"appName: \"Netscape\"appVersion: \"5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\"platform: \"Win32\"userAgent: \"Mozilla/5.0 (Windows NT 10.0; ...*/ 案例：检测游览器检测游览器名称1234567891011121314function checkBrowserName () &#123; if (navigator.userAgent.indexOf('Chrome') != -1) &#123; console.log('这是谷歌游览器'); &#125; else if (navigator.userAgent.indexOf('Trident') != -1 || navigator.appVersion.indexOf('MSIE') != -1 ) &#123; console.log('这是ie游览器'); &#125; else if (navigator.userAgent.indexOf('Firefox') != -1) &#123; console.log('这是火狐游览器'); &#125; else if (navigator.userAgent.indexOf('Opera') != -1) &#123; console.log('这是Opera游览器'); &#125; else if (navigator.userAgent.indexOf('Safari') != -1) &#123; console.log('这是Safari游览器'); &#125;&#125;checkBrowserName(); 检测ie游览器版本123456789101112131415161718192021function checkIeVersion () &#123; var ie = navigator.userAgent.indexOf('Trident') == -1 ? false : true; var version = navigator.appVersion; console.log(version); var versionName = ''; if (ie &amp;&amp; version) &#123; if (version.indexOf('rv:11.0') != -1) &#123; versionName = 'ie11' &#125; else if (version.indexOf('MSIE 10.0') != -1) &#123; versionName = 'ie10' &#125; else if (version.indexOf('MSIE 9.0') != -1) &#123; versionName = 'ie9' &#125; else if (version.indexOf('MSIE 8.0') != -1) &#123; versionName = 'ie8' &#125; else if (version.indexOf('MSIE 7.0') != -1) &#123; versionName = 'ie7' &#125; &#125; return versionName;&#125;console.log(checkIeVersion()); 写在最后这期的BOM知识分享就结束了，希望可以用起来，细细体会这其中的神奇奥秘。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/tags/javascript/"},{"name":"BOM","slug":"BOM","permalink":"https://guanqi.xyz/tags/BOM/"}]},{"title":"js常用方法集合","slug":"js-common-method-collection","date":"2019-01-24T10:16:21.000Z","updated":"2019-07-14T07:59:16.267Z","comments":true,"path":"/note/js-common-method-collection/","link":"","permalink":"https://guanqi.xyz/note/js-common-method-collection/","excerpt":"","text":"导语：今天来说一下js中经常用到的去重，排序等方法。 求多维数组的和1234567891011121314151617var total = 0; //初始值function getArrSum(arr) &#123; if ((arr instanceof Array) || (arr &amp;&amp; typeof arr == 'object' &amp;&amp; 'length' in arr)) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; if (!arr[i]) &#123; continue; &#125; if (typeof arr[i] == 'number') &#123; total += arr[i]; &#125;else if ((arr[i] instanceof Array) || (arr[i] &amp;&amp; typeof arr[i] == 'object' &amp;&amp; 'length' in arr[i])) &#123; getArrSum(arr[i]); &#125; &#125; &#125; else &#123; throw new Error('getArrSum():arr must be array!'); &#125;&#125; 实例： 123var arr = [1,[123],[45,[6,7,8]]];getArrSum(arr);console.log(total); //result is 190 返回参数中的最大值12345678910function max() &#123; var m = Number.NEGATIVE_INFINITY; for (let i = 0; i &lt; arguments.length; i++) &#123; const element = arguments[i]; if (element &gt; m) &#123; m = arguments[i]; &#125; &#125; return m;&#125; 实例： 12var large = max(10,20,1111,1212);console.log(large); // result is 1212; 检测参数类型求和123456789101112131415161718// 参数类型function getSum(a) &#123; if ((a instanceof Array) || (a &amp;&amp; typeof a == 'Object' &amp;&amp; 'length' in a)) &#123; var total = 0; for (let i = 0; i &lt; a.length; i++) &#123; let element = a[i]; if (!element) &#123; continue; &#125; if (typeof element == 'number') &#123; total += element; &#125; else &#123; throw new Error(\"sum():all array elements must be an number!\"); &#125; &#125; return total; &#125; else &#123; throw new Error(\"sum():argument must be an array!\"); &#125;&#125; 实例： 123456var res1 = getSum([123,12,15,21,54]);var res2 = getSum(121);var res3 = getSum([12,31,'121']);console.log(res1); // result is 225;console.log(res2); // result is Uncaught Error: sum():argument must be an array!;console.log(res3); // result is Uncaught Error: sum():all array elements must be an number! 返回阶乘1234567// 返回阶乘var stratum = function (num) &#123; if (num &lt;= 1) &#123; return 1; &#125; return num*arguments.callee(num-1);&#125; 实例： 1console.log(stratum(5)); // result is 120 数组排序123456789101112131415161718192021//数组元素为数字的排序（升序）function sortArrayUp(a,b) &#123; return b - a;&#125;//数组元素为数字排序（升序）function sortArrayDown(a,b) &#123; return a - b;&#125;//数组元素为对象排序function sortObject(protoname,type) &#123; // 如果type是up，是升序，否则为降序 return function (a,b) &#123; if (type == 'up') &#123; return b[protoname] - a[protoname]; &#125; else &#123; return a[protoname] - b[protoname]; &#125; &#125;&#125; 实例： 12345678910111213141516171819202122232425262728var arr = [12,13,234,121,1212,334,212,520,125];var resa = arr.sort(sortArrayUp);var resb = arr.sort(sortArrayDown);console.log(resa); //result is [1212, 520, 334, 234, 212, 125, 121, 13, 12];console.log(resb); //result is [12, 13, 121, 125, 212, 234, 334, 520, 1212];var arrb = [ &#123;num: 12,name: 'orange'&#125;, &#123;num: 112,name: 'banana'&#125;, &#123;num: 42,name: 'apple'&#125;, &#123;num: 31,name: 'orange'&#125;]var resc = arrb.sort(sortObject('num','up'));var resd = arrb.sort(sortObject('num','down'));console.log(resc);/* result is&#123;num: 112,name: 'banana'&#125;,&#123;num: 42,name: 'apple'&#125;,&#123;num: 31,name: 'orange'&#125;,&#123;num: 12,name: 'orange'&#125;*/console.log(resd);/* result is&#123;num: 12,name: 'orange'&#125;,&#123;num: 31,name: 'orange'&#125;,&#123;num: 42,name: 'apple'&#125;,&#123;num: 112,name: 'banana'&#125;*/ 数组去重123456789101112131415161718192021222324252627282930313233// 数组去重function arrayRemoveRepeat(arr,type,name) &#123; var arr = arr; //数组 var type = type; //类型，数组元素为对象，传'object',否则传'number' var name = name || ''; // 数组元素为对象，是对象的属性判断值； if ((arr instanceof Array) || (typeof arr == 'Object' &amp;&amp; 'length' in arr)) &#123; var newArr = []; var len = arr.length; for (let i = 0; i &lt; len; i++) &#123; if (!arr[i]) &#123; continue; &#125; if (type == 'object') &#123; if (typeof arr[i] == 'object') &#123; if (newArr.indexOf(arr[i][name]) == -1) &#123; newArr.push(arr[i][name]); &#125; &#125; else &#123; throw new Error(\"arrayRemoveRepeat():all element must be an object!\"); &#125; &#125; else if (type == 'number') &#123; if (typeof arr[i] == 'number') &#123; if (newArr.indexOf(arr[i]) == -1) &#123; newArr.push(arr[i]); &#125; &#125; else &#123; throw new Error(\"arrayRemoveRepeat():all element must be an number!\"); &#125; &#125; &#125; return newArr; &#125; else &#123; throw new Error(\"arrayRemoveRepeat():argument must be an array!\"); &#125;&#125; 实例： 123456789// 对象情况下:var arr31 = [&#123;num: 12&#125;,&#123;num: 12&#125;,&#123;num: 1&#125;,&#123;num: 13&#125;,&#123;num: 13&#125;,&#123;num: 13&#125;];var arr32 = arrayRemoveRepeat(arr31,'object','num');console.log(arr32); // result is [12, 1, 13];// 数字情况下：var arr22 = [12,12,11,212,1243,2321,11,1,123,261];var arr32 = arrayRemoveRepeat(arr22,'number','');console.log(arr32); // result is [12, 11, 212, 1243, 2321, 1, 123, 261]; 检测函数参数是否为制定个数1234567891011function sum(x,y,z) &#123; var sum = 0; if (arguments.length != 3) &#123; throw new Error('必须是三个参数！'); &#125; for (let i = 0; i &lt; arguments.length; i++) &#123; const element = arguments[i]; sum += element; &#125; return sum;&#125; 实例： 1234var res = sum(1,2,3);var res1 = sum(1,3);console.log(res); // result is 6;console.log(res1); // result is Uncaught Error: 必须是三个参数！ 写在最后上面就是我在日常使用中总结到的一些常用方法技巧。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/tags/javascript/"},{"name":"常用方法","slug":"常用方法","permalink":"https://guanqi.xyz/tags/常用方法/"}]},{"title":"js之正则表达式使用方法","slug":"js-regular-expression-usage","date":"2019-01-24T06:16:21.000Z","updated":"2019-07-14T07:58:05.688Z","comments":true,"path":"/note/js-regular-expression-usage/","link":"","permalink":"https://guanqi.xyz/note/js-regular-expression-usage/","excerpt":"","text":"导语：今天说一下有关js中正则表达式的一些知识点。正则表达式主要是在表单输入验证，以及一些文本字符处理中特表好用。 正则表达式的概念正则表达式是一个描述字符模式的对象，最早是诞生于Perl语言中，JavaScript继承了Perl语言的正则表达式的一些特性，方法和概念。在JavaScript中，有一个类RegExp表示正则表达式，而且String和RegExp都有对应的模式匹配和文本检索、替换的函数。 创建正则表达式创建正则表达式可以使用两种方法，这是js对象一以贯之的方法，就是new实例化一个对象，或者直接写正则表达式。 new运算符创建通过new运算符来实例化一个RegExp对象。 语法表达：new RegExp(code is here); 例如：创建一个验证数字的正则表达式。 1234//注意：这里使用test()方法来检测是否符合var numReg = new RegExp('a');var num = 'a123';console.log(numReg.test(num)); // true; 直接量创建直接量就是直接赋值，创建一个表达式。这个看着更加简洁好用，非常灵活。 例如：还是上面那个例子。 123var numReg = /a/;var num = 'a123';console.log(numReg.test(num)); // true; 正则表达式的匹配规则字符类之前都是直接写正则表达式，例如/abc/,只是匹配任意一个符合abc的字符，而如果想要匹配多个字符，就可以使用字符类来实现。 字符类是使用方括号[]，中间可以随意写一些匹配规则。 例如：我们要检测文本中是否包含0-9中的任意数字，就可以使用字符类。这里我们使用直接量比较方便。 12345var numReg = /[0-9]/;var num = 'a123';var str = 'hello';console.log(numReg.test(num)); // true;console.log(numReg.test(str)); // false; 补充：其他字符类 序号 字符 说明 1 […] 括号内的任意字符 2 [^…] 不再括号内的任意字符 3 .] 除换行符和Unicode行终止符之外的任意字符 4 \\w 任何ASCII(注释1)单字字符，等于[a-zA-Z0-9_] 5 \\W 任何非ASCII(注释1)单字字符，等于[^a-zA-Z0-9_] 6 \\s 任何Unicode空白符 7 \\S 任何非Unicode空白符的字符 8 \\d 任何ASCII数字，等于[0-9] 9 \\D 任何非ASCII数字，等于[^0-9] 10 [\\b] 退格直接量(特殊) 注释1：ASCII指的是美国信息交换标准代码。 以上就是一些字符类的说明，下面使用几个练习一下。 例如：一个检测是否包含数字、字母和下划线以及非空白符的正则表达式。 123var patten = /\\w\\s/;var str = 'abc 123';console.log(patten.test(str)); // true 避免重复定义上面的字符类，只能匹配单个，如果我们要匹配多个符合的字符，不能一直重复写吧，像这样/\\d\\d\\d/,那这样就不高效了。 为了解决上面的烦恼，正则表达式用一些方法来表示这种情况，下面是一些列表。 序号 字符 说明 1 {n,m} 表示匹配前一项至少n次，不能超过m次 2 {n,} 表示匹配前一项n次，或者更多次 3 {n} 表示匹配前一项正好n次 4 ? 表示匹配前一项0次或者1次，等于{0,1} 5 + 表示匹配前一项1次或者多次，等于{1,} 6 * 表示匹配前一项0次或者多次，等于{0,} 举个例子：匹配2到4位数字。 123var numReg = /\\d&#123;2,4&#125;/;var num = '123';console.log(numReg.test(num)); // true; 用于选择的字符正则表达式中有用于选择的字符|。这个是从左到右进行匹配，一旦左边符合就返回结果。 例如:匹配是带有ab或者cd或者ef的正则表达式。 123var numReg = /ab|cd|ef/;var num = 'ab123';console.log(numReg.test(num)); // true; 用于分组的字符正则表达式中有用于分组的字符()。 知识点：正则中括号的含义: 把单独的项目组合成子表达式，例如：/java(script)?/匹配的是字符串java,后面可以有script，也可以没有。 在完整的模式中定义子模式,例如：/[a-z]+(\\d+)/,匹配的是尾部是否是数字。 例如:匹配是带有ab或者cd或者ef的正则表达式。 123var numReg = /ab|cd|ef/;var num = 'ab123';console.log(numReg.test(num)); // true; 用于引用的字符括号()也可以表示引用，允许在同一个正则表达式中的后面部分引用前面的子表达式。 例如：开始和结束的引号相匹配。\\1引用的是第一个带括号的子表达式。 12var quoat = /(['\"])[^'\"]*\\1/;console.log(quoat.test('1\"2\"3')); // true 补充：正则表达式的选择、分组和引用字符 序号 字符 说明 1 竖杠 选择，匹配的是该符号左边或者右边的子表达式 2 (…) 分组，组合，将一个项目组合成一个独立的单元，还可以供后面的引用使用 3 (?:…) 只组合，把项目组合到一个单元，但是不记与该组匹配的字符 4 \\n 和第n个分组第一次匹配的字符相匹配 匹配指定的位置先来看一个列表，里面罗列了需要用到的锚字符。 序号 字符 说明 1 ^ 匹配字符串的开头；如果是匹配多行，那就是匹配一行的开头 2 $ 匹配字符串的结尾；如果是匹配多行，那就是匹配一行的结尾 3 \\b 匹配一个词语的边界，例如在\\w和\\W之间的位置，注意：\\b是退格符 4 \\B 匹配一个非词语的边界 5 (?=p) 正前向声明，要求接下来的字符都有和模式p匹配，但是不包括匹配中的那些字符 6 (?!p) 反前向声明，要求接下来的字符都不和模式p匹配 例如：匹配一个用户名，以字母开头，数字结尾的正则表达式。 123var nameReg = /^[a-zA-Z]\\d$/;var name = 'a1';console.log(111,nameReg.test(name)); // true; 标志正则表达式的标志说明了高级模式里面匹配的规则。和上面的正则表达式的语法不同的是标志出现在/符合之外说明的，位于第二个\\之后。 正则表达式中的标志列表 序号 字符 说明 1 g 模式匹配应该是全局的，应该找出被检索字符串所有的匹配。 2 i 模式匹配应该是不区分大小写的匹配。 3 m 多行模式，^匹配一行的开头和字符串的开头，$匹配一行的结尾和字符串的结尾 例如：匹配全局的a 123var patten = /a/g;var str = 'an apple';console.log(patten.test(str)); // true String模式匹配的方法search()方法这个方法的参数是正则表达式，返回一个与之匹配的子串的位置；如果找不到就返回-1，如果参数不是正则表达式，会转换成正则表达式进行匹配。 注意：该方法不支持全局检索，只要找到便会返回结果。 例如：匹配一个查找a的位置的正则表达式。 123var patten = /a/i;var str = 'apple';console.log(str.search(patten)); // 0 replace()方法这个方法的第一个参数是正则表达式，第二个参数是要替换的字符串，也可以是一个函数。用于把匹配到的字符串替换成别的内容。 例如：把小写字母a替换成大写字母*。 123var patten = /a/g;var str = 'apple';console.log(str.replace(patten,\"*\")); // *pple match()方法这个是比较常用的String正则表达式方法，参数只有一个就是正则表达式。把匹配到的内容以数组的形式返回。 例如：解析一个url地址 123var urlReg = /(\\w+):\\/\\/([\\w.]+)\\/(\\S*)\\/(\\d*)/;var text = 'http://www.abc.com/post/1';console.log(text.match(urlReg)); // [\"http://www.abc.com/post/1\", \"http\", \"www.abc.com\", \"post\", \"1\", index: 0, input: \"http://www.abc.com/post/1\", groups: undefined] split()方法这个也是比较常用的String正则表达式方法，参数只有一个就是正则表达式或者一个字符。把字符串分解为一个子串数组，使用的分隔符就是它的参数。 例如： 12345var patten = /\\s/;var num = '123,456,789';var num1 = '123 456 789';console.log(num.split(',')); // [\"123\", \"456\", \"789\"]console.log(num1.split(patten)); // [\"123\", \"456\", \"789\"] RegExp对象的属性和方法Javascript中的正则表达式是用RegExp对象来表示的，除了构造函数RegExp()，这个对象可以接受两个参数，一个是正则表达式的字符串，另一个是正则表达式的标志。 例如：new RegExp(&quot;\\\\d{2}&quot;,&quot;g&quot;); RegExp对象的属性每个RegExp对象都有五个属性。包括以下： source是一个只读字符串，存放的是正则表达式的文本。 global是一个只读的布尔值，是否具有标志g ignoreCase是一个只读的布尔值，是否具有标志i multiline是一个只读的布尔值，是否具有标志m lastIndex是一个可读写的整数。对于具有标志g的模式，这个属性存储在字符串中下一次可以检索的位置，由方法exec()和test()使用 exec()方法该方法是对于一个指定的字符串进行匹配，把匹配到的内容返回一个的数组。 例如： 123var patten = /a/i;var str = 'apple';console.log(patten.exec(str)); // [\"a\", index: 0, input: \"apple\", groups: undefined] test()方法该方法和exec()方法类似，但是不只限于字符串，其他字符也支持；而且它返回的是一个布尔值，表示是否符合正则表达式的匹配规则。 123var patten = /a/i;var str = 'apple';console.log(patten.test(str)); // true 案例### 检验用户名为中文的 /^[\\u4e00-\\u9fa5]{0,}$/ 检验密码强度/^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$/ 密码的强度必须是包含大小写字母和数字的组合不能使用特殊字符,长度在8-10之间 检测电子邮箱地址/[\\\\w!#$%&amp;&#39;*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;’+/=?^_`{|}~-]+)@(?:\\w?\\.)+\\w?/` 检测手机号的/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\\\d{8}$/ 检测身份证的15位的:/^[1-9]\\\\d{7}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}$/ 18位的:/^[1-9]\\\\d{5}[1-9]\\\\d{3}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}([0-9]|X)$/ 检验金额的精确到2位小数。 /^[0-9]+(.[0-9]{2})?$/ 判断ie版本/^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$/ 校验IP-v4地址/\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b/ 提取url链接/^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&amp;=]*)?/ 写在最后这个JavaScript中的正则表达式RegExp对象就讲到到这里，内容还是挺多的，需要慢慢吸收转化，可以多几个例子练习。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://guanqi.xyz/tags/正则表达式/"}]},{"title":"js获取url参数的方法","slug":"js-method-to-get-the-url-parameter","date":"2019-01-23T13:36:21.000Z","updated":"2019-07-14T07:57:33.044Z","comments":true,"path":"/note/js-method-to-get-the-url-parameter/","link":"","permalink":"https://guanqi.xyz/note/js-method-to-get-the-url-parameter/","excerpt":"","text":"导语：今天说一下如何获取url参数值。 思路 通过location的search就可以获取到url中问号后面的值。 字符串过滤到问号 通过split方法分割参数集合 循环赋值 匹配对应的参数值 返回值 封装的方法1234567891011121314151617181920212223242526272829function getUrlParams(name) &#123; // 不传name返回所有值，否则返回对应值 var url = window.location.search; if (url.indexOf('?') == 1) &#123; return false; &#125; url = url.substr(1); url = url.split('&amp;'); var name = name || ''; var nameres; // 获取全部参数及其值 for(var i=0;i&lt;url.length;i++) &#123; var info = url[i].split('='); var obj = &#123;&#125;; obj[info[0]] = decodeURI(info[1]); url[i] = obj; &#125; // 如果传入一个参数名称，就匹配其值 if (name) &#123; for(var i=0;i&lt;url.length;i++) &#123; for (const key in url[i]) &#123; if (key == name) &#123; nameres = url[i][key]; &#125; &#125; &#125; &#125; else &#123; nameres = url; &#125; // 返回结果 return nameres;&#125; 实例例如： 12345const url = 'http://www.abc.com/test.php?id=1&amp;from=index';var res = getUrlParams();var res1 = getUrlParams('id');console.log(res); // [&#123;id: \"1\"&#125;, &#123;from: \"index\"&#125;]console.log(res1); // 1 写在最后这是一个比较简单的方法。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/tags/javascript/"},{"name":"url参数","slug":"url参数","permalink":"https://guanqi.xyz/tags/url参数/"}]},{"title":"es6之const命令","slug":"es6-const-command","date":"2019-01-23T13:31:21.000Z","updated":"2019-07-14T07:57:06.387Z","comments":true,"path":"/note/es6-const-command/","link":"","permalink":"https://guanqi.xyz/note/es6-const-command/","excerpt":"","text":"导语：今天学习一下const命令。 声明一个常量const声明一个只读常量，一旦声明，常量的值便不可改变。 例子如下： 12const food = 12;food = 23; // Uncaught TypeError: Assignment to constant variable. 还可以声明一个变量const可以声明一个变量，声明以后，必须初始化，否则变错。 例子如下： 1const food; // Uncaught SyntaxError: Missing initializer in const declaration 其他特性const和let有许多相似点： 只在其声明的块级作用域中有效； 不存在作用域提升，是暂时性死区，必须先声明，后使用； 不能重复声明，否则会报错 例子如下： 1234567891011121314151617//1.只在其声明的块级作用域中有效&#123; const food = 'apple';&#125;console.log(food); // Uncaught ReferenceError: food is not defined//2.暂时性死区&#123; console.log(HI); // Uncaught ReferenceError: HI is not defined const HI = 'hello';&#125;//3.不能重复声明&#123; const food = 'apple'; const food = 'orange'; // Uncaught SyntaxError: Identifier 'food' has already been declared&#125; const的声明变量的本质const声明的变量，并不是说变量的值不能改变，而是对于变量指向那个的内存地址所保存的数据不得改动。 如果声明的变量是基本数据，那值就保存在变量指向的那个内存地址，可以理解为对于常量。 但是如果声明的变量是一个引用数据类型，那只能保证变量保存的指针地址不变，至于变量里面的属性和值，就不能保证了。 注意：如果把这个声明的引用数据类型变量指向另一个对象，就会报错。 例如： 12345678910111213// 常量是一个对象const About = &#123;&#125;;About.us = 'usb';About.ua = 'usc';console.log(About); // &#123;us: \"usb\", ua: \"usc\"&#125;About = &#123;&#125;; // Uncaught TypeError: Assignment to constant variable.//常量是一个数组const BALL = [];BALL.length = 2;BALL[0] = 'haha';BALL = []; // Uncaught TypeError: Assignment to constant variable. 补充：声明变量的方法 ES5的var和function命令。 ES6的let和const命令。 最后总结其实，const也不是很难，只要你细心，就会发现非常的简单。","categories":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/tags/es6/"},{"name":"const","slug":"const","permalink":"https://guanqi.xyz/tags/const/"}]},{"title":"es6之块级作用域","slug":"block-level-scope-of-es6","date":"2019-01-23T13:30:21.000Z","updated":"2019-07-07T09:39:47.784Z","comments":true,"path":"/note/block-level-scope-of-es6/","link":"","permalink":"https://guanqi.xyz/note/block-level-scope-of-es6/","excerpt":"","text":"导语：今天，来探讨一下ES6中的块级作用域。 全局作用域和函数作用域在ES5中，只全局作用域和函数作用域。这会导致函数作用域覆盖了全局作用域；亦或者循环中的变量泄露为全局变量。 例如： 123456789101112131415// 1.函数作用域覆盖了全局作用域,发生了变量提升，函数声明大于var声明的变量，因此函数里面的a提到了前面，在打印a，初始化一个undefined给a,所以打印出了undefined。var a = '1';function fn() &#123; console.log(a); if (3&lt;2) &#123; var a = 3; &#125;&#125;fn(); // undefined// 2.循环中的变量泄露为全局变量for(var i=0;i&lt;5;i++) &#123; console.log(i);&#125;console.log(i); // 5; ES6的块级作用域用let命令新增了块级作用域，外层作用域无法获取到内层作用域，非常安全明了。即使外层和内层都使用相同变量名，也都互不干扰。 1234567891011121314151617181920212223242526272829303132333435// 1.外层作用域无法获取到内层作用域function fn1() &#123; let a = 41; if(1 == 1) &#123; let a = 3; console.log(2,a); // 2 3 &#125; console.log(1,a); // 1 41&#125;fn1();&#123; &#123; let food = 'apple'; &#125; console.log(food); // Uncaught ReferenceError: food is not defined&#125;&#123; &#123; let food = 'apple'; &#125; console.log(food); // Uncaught ReferenceError: food is not defined&#125;// 2. 外层和内层都使用相同变量名，也都互不干扰&#123; &#123; let food = 'apple'; console.log(food); // apple &#125; let food = 'orange'; console.log(food); // orange&#125; 块级作用域和和函数声明在ES5中，函数只能在顶级作用域和函数作用域中声明，不能在块级作用域中声明。但是在ES6中，函数可以在块级作用域中声明。 但是会有一定的问题，因为函数声明会被提到代码的最前面。所以会报错，最好在ES6中用函数表达式来表示一个函数。 例如： 123456789101112131415161718//1.函数声明报错&#123; if (4 &lt; 2) &#123; function fn() &#123; console.log('我在函数里面！'); &#125; &#125;&#125;fn(); // Uncaught TypeError: fn is not a function//2.函数表达式没错&#123; let fa = '111'; let fn = function () &#123; console.log('我在函数里面！'); &#125; console.log(fa,fn); // 111 ƒ () &#123; console.log('我在函数里面！');&#125;&#125; 注意：ES6中允许函数在块级作用域中可以声明的条件是必须在大括号里面，否则就会报错。 12345678// 1.报错的情况if (4&gt;2) &#123; let fn = function () &#123;&#125;;&#125;//2.报错的情况if (4&gt;2) let fn = function () &#123;&#125;; // Uncaught SyntaxError: Lexical declaration cannot appear in a single-statement context 最后总结今天就将这些，下次再会。期待再更新。","categories":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/tags/es6/"},{"name":"块级作用域","slug":"块级作用域","permalink":"https://guanqi.xyz/tags/块级作用域/"}]},{"title":"es6之set数据结构","slug":"es6-set-data-structure","date":"2019-01-22T10:30:21.000Z","updated":"2019-07-14T07:56:11.502Z","comments":true,"path":"/note/es6-set-data-structure/","link":"","permalink":"https://guanqi.xyz/note/es6-set-data-structure/","excerpt":"","text":"导语：set是ES6中的新增的数据结构，是一种构造函数，类似于数组，但是里面的元素都是唯一的，不重复的。 学习set例如： 12345const set = new Set();[1,2,3,4,5,2,1,2,1,2].forEach( x =&gt; set.add(x) );for(let i of set) &#123; console.log(i); // 1 2 3 4 5&#125; set的属性set的属性包括constructor（set原型）和size（用来记录set的大小）。 用法：Set.prototype.constructor,Set.prototype.size。 例如： 123let set = new Set([1,2,3,2,2,2,1,2,34,4,45,523]);console.log(set.constructor); // ƒ Set() &#123; [native code] &#125;console.log(set.size); // 7 set的方法set的操作方法 add(val); 添加某个值 delete(val); // 删除某个值，返回布尔值，表示结果。 has(val); // 判断该值是否存在于Set中。 clear(); // 清楚所有的值 例如： 123456789101112let set = new Set();//1.add();set.add(12).add(32);console.log(set); // Set(2) &#123;12, 32&#125;// 2.delete(val);set.delete(32);console.log(set); // Set(1) &#123;12&#125;//3.has(val);console.log(set.has(88)); // false//4.clear();set.clear();console.log(set); // Set(0) &#123;&#125; set的遍历方法set的键和值是同一个值。 keys() 返回键名的方法 values() 返回键值的方法 entries() 返回键值对的方法 forEach() 用回调函数遍历各个元素的方法 例如： 123456789101112131415let set = new Set([2,2,2,1,5,34,45,33,23,32]);for(let item of set.keys()) &#123; console.log(item); // // 2 1 5 34 45 33 23 32&#125;for(let item of set.values()) &#123; console.log(item); // // 2 1 5 34 45 33 23 32&#125;for(let item of set.entries()) &#123; console.log(item); // [2, 2] [1, 1] [5, 5] [34, 34] [45, 45] [33, 33] [23, 23] [32, 32]&#125;set.forEach((value,key) =&gt; console.log(key+ '=' +value)); // 2=2 1=1 5=5 34=34 45=45 33=33 23=23 32=32 应用...运算符和Array.from以及map和filter都可以遍历set结构。 ...运算符例如： 12let set = new Set('123456654321');console.log([...set]); // [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"] ...和数组加起来可以去重 例如： 123let arr = [1,2,3,4,6,3,3,1,3,4];let removeRepeat = [...new Set(arr)];console.log(removeRepeat); //[1, 2, 3, 4, 6] map方法例如： 12let set = new Set([1,2,3,4]);console.log(new Set([...set].map(x =&gt; x*2))); // &#123;2, 4, 6, 8&#125; filter方法例如： 12let set = new Set([1,2,3,4]);console.log(new Set([...set].filter(x =&gt; x%2 === 0))); // &#123;2, 4&#125; Array.from例如： 12let set = new Set([1,2,3,4]);console.log(new Set(Array.from(set, x =&gt; x*2))); // &#123;2, 4, 6, 8&#125; 小案例使用这个set可以实现数学中的交集，并集效果。 例如： 12345678let a = new Set([1,2,3]);let b = new Set([3,4,5]);let numa = new Set([...a,...b]);console.log(numa); // &#123;1, 2, 3, 4, 5&#125;//并集let numb = new Set([...a].filter(x =&gt; b.has(x)));console.log(numb); // &#123;3&#125; 学习WeakSetWeakSet和Set类似，也是没有重复的值。注意的是，它里面的成员只能是对象，其他数据类型不接受。 例如： 123456let ws = new WeakSet(1); // Uncaught TypeError: number 1 is not iterable (cannot read property Symbol(Symbol.iterator))let wsa = new WeakSet('1'); // Uncaught TypeError: Invalid value used in weak setlet wsb = new WeakSet(&#123;x:1&#125;); // Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))let wsc = new WeakSet([1,3]); // Uncaught TypeError: Invalid value used in weak setlet wsc = new WeakSet([[1,2],[3,4]]);console.log(wsc); // WeakSet &#123;Array(2), Array(2)&#125; 结论：从上面的例子中，可以看出1.WeakSet构造函数的参数不接受字符串，数字，普通对象，数组（数组中的参数必须是对象）；接受数组（数组中的参数是对象的数组）。 WeakSet的方法 WeakSet.prototype.add(val)添加一个值; WeakSet.prototype.delete(val)删除一个值; WeakSet.prototype.has(val)是否有这个值; 例如： 1234567891011let wset = new WeakSet([[1,3,4],[23,4,52,2]]);//1.添加值wset.add([12,33,23]);console.log(wset); // WeakSet &#123;Array(3), Array(4), Array(3)&#125;//2.删除值wset.delete([12,33,23]);console.log(wset); // WeakSet &#123;Array(4), Array(3)&#125;//3.是否有这个值console.log(wset.has([12,33,23])); // false WeakSet的属性由于WeakSet中的值都是弱属性，随时可能消失，被垃圾回收，遍历机制无法保证值是否还存在，所以不能用size和forEach()。 例如： 12345let wset = new WeakSet([[1,3,4],[23,4,52,2]]);console.log(wset.size); // undefinedfor(let i=0;i&lt;wset.length;i++) &#123; console.log(wset[i]);&#125; 写在最后Set和WeakSet就介绍到这里，赶快用起来吧！","categories":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/tags/es6/"},{"name":"set","slug":"set","permalink":"https://guanqi.xyz/tags/set/"}]},{"title":"es6之let命令","slug":"es6-let-command","date":"2019-01-19T09:30:21.000Z","updated":"2019-07-14T07:55:42.042Z","comments":true,"path":"/note/es6-let-command/","link":"","permalink":"https://guanqi.xyz/note/es6-let-command/","excerpt":"","text":"导语：今天学习一下let命令。 let命令的用法let是es6中的声明一个变量的命令，只在它声明的代码块中有效，出了这个代码块就会报错。也非常适合for循环，在循环中i的值只在循环语句中生效，在外边取不到的。 var命令声明的是一个全局的变量，i是指向全局的变量，只会输出最后的值。而let只在循环语句块里面生效，每次循环都会重新声明一个i的，所以每次循环都能拿到对应的值。 for循环的变量是父作用域，和在循环体内let定义的变量（子作用域）不在同一个作用域。 例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//1.在自身所在代码块中有效&#123; let a = 1; var b = 2;&#125;console.log(b); // 2console.log(a); // a is not defined//2.在for循环语句块中有效for(var i=0;i&lt;10;i++) &#123; //...&#125;console.log(i); // 10for(let j=0;j&lt;10;j++) &#123; //...&#125;console.log(j); // j is not definedvar arr = [];for(var a=0;a&lt;10;a++) &#123; arr[a] = function () &#123; console.log(a); &#125;&#125;console.log(a[4]); // 10for(let b=0;b&lt;10;b++) &#123; arr[b] = function () &#123; console.log(b); &#125;&#125;console.log(b[4]); // 4// 3.for循环的变量和循环体内的变量for(var i=0;i&lt;10;i++) &#123; let i = 'fed'; console.log(i);&#125;/** 结果是* fed* fed* fed*/ let命令不存在作用域提升var命令是会发生作用域提升的，在声明之前，是undefined,未声明便有默认值了。而let定义的变量必须在声明后使用。 12345console.log(fa); // undefinedvar fa = 1;console.log(fb); // fb is not definedlet fb = 2; let存在暂时性死区“暂时性死区”（temporal dead zone，简称 TDZ）是指在ES6的规定中，如果区块中存在let和const命令的，这两个命令声明的变量就已经形成了封闭作用域。在此之前声明的变量，都会报错。 例如：下面声明了一个全局变量，但是在块级作用域中let又声明了一个变量。 12345678var food = 'apple';if(typeof 'str' == 'string') &#123; food = 'banana'; // Uncaught ReferenceError: food is not defined let food; console.log(food); // undefined food = 'orange'; console.log(food); // orange&#125; 注意：暂时性四区会有一些不好的地方。 typeof检测不安全 12typeof x; // Uncaught ReferenceError: x is not definedlet x; 不允许重复声明简而言之，就是不允许在同一作用域内，声明两个一样的变量。 例如： 123456789&#123; let a = 1; var a = 2; // Uncaught SyntaxError: Identifier 'a' has already been declared&#125;// 或者&#123; let b = 1; let b = 2; // Uncaught SyntaxError: Identifier 'b' has already been declared&#125; 注意：不能在函数参数内重复声明参数，否则报错。 12345function wait(x,y) &#123; let x = 1; // Uncaught SyntaxError: Identifier 'x' has already been declared let y = 2; // Uncaught SyntaxError: Identifier 'y' has already been declared&#125;wait(3,5); 顶层对象在ES6之前，顶级对象的属性和全局变量是一致的，所以导致出现很多问题。 只有运行开才能捕捉到错误，没法一开始就检测出错误。 顶层对象是随时随地可以读取和写入的，所以不利于模块化编程。 window其实指的是游览器窗口，顶层对象有一个实体含义。 所以es6改进了一点，就是let，const声明的全局变量不属于顶层对象的属性。 例如： 1234var a = 1;let b = 2;console.log(window.a); // 1console.log(window.b); // undefined 学以致用let命令古语有云：学了就用处处行，不学不用等于零。所以我写了一个关于let的小例子。 这是一个选项卡的案例，在之前，我们还要定义btns[i].index = i,而现在用let命令就方便多了。 12345678910111213141516171819202122232425262728293031.tab &#123; width: 300px; height: 30px; border: 1px solid #fff;&#125;.tab &gt; span &#123; float: left; display: block; width: 98px; height: 28px; line-height: 28px; text-align: center; border: 1px solid #aaa; cursor: pointer;&#125;span.active &#123; color: #fff; background-color: #f00; border: 1px solid #f00;&#125;.content, .content &gt; p &#123; width: 300px; height: 300px;&#125;.content &gt; p &#123; display: none; border: 1px solid #aaa;&#125;p.active &#123; display: block;&#125; 12345678910&lt;div class=\"tab\"&gt; &lt;span class=\"active\"&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=\"content\"&gt; &lt;p class=\"active\"&gt;1的内容&lt;/p&gt; &lt;p&gt;2的内容&lt;/p&gt; &lt;p&gt;3的内容&lt;/p&gt;&lt;/div&gt; 123456789101112let btns = document.querySelectorAll('.tab span');let contents = document.querySelectorAll('.content p');for (let i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function() &#123; for (let j = 0; j &lt; btns.length; j++) &#123; btns[j].className = ''; contents[j].className = ''; &#125; this.className = 'active'; contents[i].className = 'active'; &#125;&#125; 写在最后上面就是一些介绍如何正确的使用let命令，在实践中用起来吧。","categories":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/tags/es6/"},{"name":"let","slug":"let","permalink":"https://guanqi.xyz/tags/let/"}]},{"title":"ajax技术详解","slug":"detailed-ajax-technology","date":"2019-01-18T13:16:21.000Z","updated":"2019-07-14T07:55:03.460Z","comments":true,"path":"/note/detailed-ajax-technology/","link":"","permalink":"https://guanqi.xyz/note/detailed-ajax-technology/","excerpt":"","text":"导语：今天来讲一下ajax的有关知识点。 ajax概念ajax全称叫Asynchronous JavaScript and XML,意思是异步的 JavaScript 和 XML。 ajax是现有标准的一种新方法，不是编程语言，可以在不刷新网页的情况下，和服务器交换数据并且更新部分页面内容，不需要任何插件，只需要游览器允许运行JavaScript就可以。 而传统的网页（不使用ajax的）如果需要更新页面内容，就需要重新请求服务器，返回网页内容，重新渲染刷新页面。 ajax的原理原理：ajax的运行过程包括以下几个方面 Browser游览器通过事件触发方法，本地通过XMLHttpRequest对象，创建并且发送请求通过互联网到服务器； Server服务器收到请求的内容，响应请求，发送所需数据到游览器； Browser游览器通过XMLHttpRequest对象的onreadystatechange的方法收到请求的数据后，解析和渲染数据到页面中。 注意：ajax依赖的标准有以下几个 XMLHttpRequest对象,异步的与服务器交换数据 JavaScript/DOM,信息显示/交互 XML,作为转换数据的格式 XMLHttpRequest的使用创建XMLHttpRequest对象，通过new实例化一个XMLHttpRequest对象。 1var xhr = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP'); // 兼容ie和Firefox，google chrome,opera,safari 发送请求使用XMLHttpRequest对象的open和send方法 open方法使用open(method,url,async),接受三个参数。 第一个是method请求的类型，如：get和post; 第二个是url请求地址，即文件在服务器的位置； 第三个是是否处理异步处理请求,值为true和false； 例如： 1xhr.open('get','https://www.abc.com/service.php?tamp='+Date.parse(new Date()),true); send方法使用send(string)接受的参数为请求类型为post传递的值，为get类型时候不传值。 例如： 1send('tamp='+Date.parse(new Date()); onreadystatechange事件当readyState属性发生变化时，就会触发onreadystatechange事件，该事件通过回调函数获取到响应的数据信息。 readyState值: 值为0表示：请求未初始化； 值为1表示：服务器连接已建立； 值为2表示：请求已接收； 值为3表示：请求处理中； 值为4表示:请求已完成，且响应已就绪； status值： 200: 请求成功 404: 未找到页面 简单的get请求12345678910111213var xhr;if (!xhr &amp;&amp; typeof xhr !== 'object') &#123; var xhr = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP');&#125;xhr.open('get','https://www.abc.com/service.php?tamp='+Date.parse(new Date()),true);xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; console.log(xhr.responseText); &#125; &#125;&#125;xhr.send(); 模拟数据模拟的JSON数据123456789101112131415161718192021// 保存为data.json文件&#123; \"msg\": \"get_succ\", \"code\": 201, \"data\": &#123; \"list\": [ &#123; \"id\":1, \"name\": \"alun\" &#125;, &#123; \"id\":2, \"name\": \"mark\" &#125;, &#123; \"id\":3, \"name\": \"jean\" &#125; ] &#125;&#125; 模拟的Nodejs的api 请确保你的系统安装有node.js环境。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 保存为node.js文件// 引入http模块const http = require('http');const port = 3000;const success = &#123; msg: \"get_succ\", code: 201, data: &#123; list: [ &#123;\"id\":1,\"name\": \"alun\"&#125;, &#123;\"id\":2,\"name\": \"mark\"&#125;, &#123;\"id\":3,\"name\": \"jean\"&#125; ] &#125;&#125;const error = &#123; msg: \"get_fail\", code: 101, data: &#123; info: 'this request failed,again try!' &#125;&#125;const authy = &#123; msg: \"no visited!\", code: 403, data: &#123; info: 'not visited!' &#125;&#125;// 建立http服务const serve = http.createServer((req,res) =&gt; &#123; var lawDomainList = \"http://localhost:9925\"; res.setHeader('Content-Type', 'text/plain;charset=utf8'); res.setHeader(\"Access-Control-Allow-Origin\",lawDomainList); if (req.url == '/api') &#123; res.end(JSON.stringify(success)); &#125; else &#123; res.end(JSON.stringify(error)); &#125; res.end(authy);&#125;)// 监听端口serve.listen(port,function()&#123; console.log('serve is running on port 3000!');&#125;) 封装的ajax函数1234567891011121314151617181920212223242526272829303132// 保存为ajax.js文件$_g = &#123; get: function (url) &#123; return xmlHttp('get', url); &#125;, post: function (url, data) &#123; return xmlHttp('post', url, data); &#125;,&#125;function xmlHttp(method, url, data) &#123; if (method == 'post' &amp;&amp; !data) &#123; throw new Error(\"post提交缺少data\"); &#125; if (!url &amp;&amp; typeof url !== 'string') &#123; throw new Error('参数传递有误，请检查url是否为字符串'); &#125; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP'); xhr.open(method, url, true); xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(this.response, this); &#125; else &#123; reject(this); &#125; &#125; &#125; xhr.send(JSON.stringify(data)); &#125;)&#125; 示例：获取数据渲染页面 通过点击按钮获取数据，渲染列表。 123&lt;button class=\"btn\"&gt;请求数据&lt;/button&gt;&lt;ul class=\"res\"&gt;结果：暂无结果&lt;/ul&gt;&lt;script src=\"ajax.js\"&gt;&lt;/script&gt; 123456789101112131415161718192021let btn = document.querySelector('.btn');let resbox = document.querySelector('.res');btn.onclick = function() &#123; var url = 'http://localhost:3000/api'; // node api var urlJson = 'data.json'; // mock api $g.get(url).then(function(res) &#123; if (typeof res == 'string') &#123; let responTxt = JSON.parse(res); if (responTxt.msg == 'get_succ' &amp;&amp; responTxt.code == 201) &#123; let list = responTxt.data.list; let str = ''; for (let i=0;i&lt;list.length;i++) &#123; str += '&lt;li&gt;'+ list[i].id + ':' + list[i].name + '&lt;/li&gt;'; &#125; resbox.innerHTML = str; &#125; &#125; &#125;).catch(function(err)&#123; throw new Error(err); &#125;);&#125; 写在最后这只是我总结的一小部分知识点，其实这个技术还是有很多地方没有说到，以后再补充吧！","categories":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"https://guanqi.xyz/tags/ajax/"}]},{"title":"前端项目汇总","slug":"front-end-project-summary","date":"2019-01-16T13:30:21.000Z","updated":"2019-07-14T07:50:35.988Z","comments":true,"path":"/note/front-end-project-summary/","link":"","permalink":"https://guanqi.xyz/note/front-end-project-summary/","excerpt":"","text":"导语：之前我做了许多的小项目，包括当当网pc、哔哩哔哩h5，豆瓣网h5(由于豆瓣api接口权限问题，暂时无法访问),更多内容请访问 https://guanqi.xyz/demo/ 查看。 当当网pc 当当网pc 当当网是初学前端时候做的一个案例，这个案例包括登录，注册，首页，二级页，详情页，购物车页面这几个部分。 你可以先注册，然后登录，到首页看看，二级页看看，再到详情页添加商品到购物车（有待完善），最后在购物车结算。 建议在电脑上游览，点击这里预览一下效果吧！ 哔哩哔哩h5 哔哩哔哩h5 当当网是初学前端时候做的一个案例，这个案例包括登录，注册，首页，二级页，详情页，搜索页页面这几个部分。 你可以看频道内容，也可以看排行榜，还可以登录，注册（完善中），也可以看详情页视频。 建议在手机上游览，点击这里预览一下效果吧！","categories":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/categories/前端案例/"}],"tags":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/tags/前端案例/"},{"name":"项目汇总","slug":"项目汇总","permalink":"https://guanqi.xyz/tags/项目汇总/"}]},{"title":"js之对象详解","slug":"detailed-explanation-of-the-object-of-js","date":"2019-01-16T13:16:21.000Z","updated":"2019-07-14T07:49:01.720Z","comments":true,"path":"/note/detailed-explanation-of-the-object-of-js/","link":"","permalink":"https://guanqi.xyz/note/detailed-explanation-of-the-object-of-js/","excerpt":"","text":"导语:今天说一下有关对象操作方法的文章。 目录 什么是对象 创建对象 对象的属性 作为关联数组的对象 Object的属性和方法 什么是对象在js中数据类型分为两类，一个是基本数据类型，另一个是引用数据类型。基本数据类型包括文本字符串string、布尔boolean、数字number、未定义nudefined、空值null,而引用数据类型就是对象，包括普通的Object、数组Array、函数function、日期Date、正则表达式RegExp、字符串对象String、数字对象Number、布尔对象Boolean。今天要说的就是Object,普通的对象。 你可以把它当成一种无序的属性的集合，每个属性都有自己的名字和值，这个值可以是数组，也可以是对象，其他的也可以。 创建对象创建对象有很多种方法，今天介绍常见的几种方法。 直接量创建例如： 12345var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;; 使用new运算符创建例如: 1var obj = new Object(); 对象的属性对象有很多的的属性和属性的值，属性用.来表示。在.左边的是要访问其属性的对象的引用名，它不能是字符串或者是表达式；在.右边的是属性名。 定义一个对象直接量定义简单方便，直接在一个花括号里面写属性和值，属性之间用逗号隔开。 例如： 1234567var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;var name = obj.name;console.log(name); // 'guan' 增加一个对象的属性和值直接在对象里面添加属性即可，或者使用.定义一个新的属性值。 例如：直接拿上面的示例。 1234567var obj = &#123; name: 'guan', age: 21, sex: 'man', address: '浙江杭州'&#125;;obj.telephone = '0571-12340001'; 修改一个对象的属性和值使用.可以改变一个新的属性值。 例如：直接拿上面的示例。 123456var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;obj.name = 'mark'; 循环对象的属性和值在js中,使用for/in方法可以遍历对象的属性和属性值。 例如： 123456789var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;for (var key in obj) &#123; console.log(key + '=' + obj[key]); //name=guan age=21 sex=man&#125; 检测对象的属性是否存在用in或者undefined判断，但是in运算符不常用，如果差不多会返回undefined。 12345678910111213141516var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;// 1. 用inif ('name' in obj) &#123; obj.name = 'lee'; //lee&#125;console.log(obj.name); //lee//2.用判断if (obj.name !== undefined) &#123; obj.name = 'lee';&#125;console.log(obj.name); //lee 删除对象的属性和属性值可以用delete运算符删除对象的属性，实际上是彻底从对象中删除这个属性，删除以后for/in方法和in运算符都不会找到该属性，如果打印该属性，会的到一个undefined。 例如： 12345678var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;delete obj.name;console.log(obj.name); //undefined 作为关联数组的对象在js中，数组是一种特殊的对象，所以也可以用对象来关联数组。 以下表示方法是相等的: 12object.propertyobject['property'] 例如： 123456789var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;var name = obj['name'];console.log(obj.name == name); //true Object的属性和方法在js中，所有的对象都继承自Object类，所以它们都有通用的方法和属性。 constructor属性在js中，每一个对象都有一个constructor属性,所以可以根据这个来检测某个数据是否属于对象。 例如： 12345678910var arr = [1,2,3];console.log(arr.constructor == Array); //true//还可以这样判断function isArray(arr) &#123; if (typeof arr == 'object' &amp;&amp; arr.constructor == Array) &#123; console.log('arr is array'); &#125;&#125;isArray(arr); //arr is array instanceof运算符instanceof运算符可以检查constructor的值 因此上面可以写成。 例如： 12345678910var arr = [1,2,3];console.log(arr instanceof == Array); //true//还可以这样判断function isArray(arr) &#123; if (typeof arr == 'object' &amp;&amp; arr instanceof Array) &#123; console.log('arr is array'); &#125;&#125;isArray(arr); //arr is array toString()方法这个方法没有参数，可以把对象转换为一个字符串。 例如： 123var obj = &#123;x:1,y:1&#125;;var str = obj.toString();console.log(str); // [object Object] toLocaleString()方法这个方法返回对象的一个本地化的字符串。 例如： 123var now = new Date();var str = now.toLocaleString();console.log(str); // 2019/1/16 下午9:45:55 hasOwnProperty()方法这个方法是检测对象的某个属性是否是自身的属性，而不是继承的属性。 例如： 12345678var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;console.log(obj.hasOwnProperty('name')); //trueconsole.log(obj.hasOwnProperty('address')); //false valueOf()方法这个方法把对象转化为某个基本数据类型，也就是一个数字，而不是字符串的时候才会调用的方法。 最后总结对象的使用方法就是这些，最常用也是最基本的属性和方法。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/tags/javascript/"},{"name":"对象","slug":"对象","permalink":"https://guanqi.xyz/tags/对象/"}]},{"title":"前端案例汇总","slug":"front-end-case-summary","date":"2019-01-16T02:30:21.000Z","updated":"2019-07-14T07:41:54.105Z","comments":true,"path":"/note/front-end-case-summary/","link":"","permalink":"https://guanqi.xyz/note/front-end-case-summary/","excerpt":"","text":"导语：本篇主要是汇总了一些日常开发中做的一些的案例，更多内容请访问 https://guanqi.xyz/demo 查看。 目录 小米首页 天猫首页 帅康首页 58首页 换肤 商品放大镜 时钟canvas 刮刮卡 妈妈的礼物 骰子 统计表 选项卡(tab切换) banner(轮播图) 小米首页 小米首页 这个demo是关于小米首页的，建议在pc上面查看，大家可以点击这个链接查看。 天猫首页 天猫首页 这个demo是关于天猫首页的，建议在pc上面查看，大家可以点击这个链接查看。 帅康首页 帅康首页 这个demo是关于帅康首页的，建议在pc上面查看，大家可以点击这个链接查看。 58首页 58首页 这个demo是关于58首页的，建议在手机上面查看，大家可以点击这个链接查看。 换肤 换肤 这个demo是关于换肤的，建议在pc上面查看，大家可以点击这个链接查看。 商品放大镜 商品放大镜 这个demo是关于商品放大镜的，建议在pc上面查看，大家可以点击这个链接查看。 时钟canvas 时钟 这个demo是关于时钟的，建议在pc上面查看，大家可以点击这个链接查看。 刮刮卡 刮刮卡 这个demo是关于刮刮卡的，建议在pc上面查看，大家可以点击这个链接查看。 妈妈的礼物 妈妈的礼物 这个demo是关于妈妈的礼物的，建议在pc上面查看，大家可以点击这个链接查看。 骰子 骰子 这个demo是关于骰子的，建议在pc上面查看，大家可以点击这个链接查看。 统计表 统计表 这个demo是关于统计表的，建议在pc上面查看，大家可以点击这个链接查看。 选项卡(tab切换) 选项卡 这个demo是关于选项卡的，建议在pc上面查看，大家可以点击这个链接查看。 banner(轮播图) banner 这个demo是关于banner的，建议在pc上面查看，大家可以点击这个链接查看。 最后总结这里收录了部分精品,以后会补充。","categories":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/categories/前端案例/"}],"tags":[{"name":"前端案例","slug":"前端案例","permalink":"https://guanqi.xyz/tags/前端案例/"},{"name":"案例汇总","slug":"案例汇总","permalink":"https://guanqi.xyz/tags/案例汇总/"}]},{"title":"js之数组的操作方法","slug":"js-array-operation-method","date":"2019-01-06T13:16:21.000Z","updated":"2019-07-14T07:39:22.788Z","comments":true,"path":"/note/js-array-operation-method/","link":"","permalink":"https://guanqi.xyz/note/js-array-operation-method/","excerpt":"","text":"导语：今天给大家带来一篇有关数组操作方法的文章。 目录 新建数组 添加数组中的元素 修改数组中的元素 删除数组元素内容 合并数组 删除指定数组 截取指定数组 新建数组 方法一：通过new运算符创建一个数组构造函数。 1var arr = new Array(); 方法二：通过方括号直接创建直接量数组。 1var arr = [1,2,3]; 添加数组中的元素 方法一：通过下标添加元素。 123var arr = new Array();arr[0] = 'kwan';arr[1] = 18; 方法二：通过array的push方法来添加。 说明一点：push是往数组末尾添加新元素。 12345var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;arr.push(4); // result is [5,1,2,3,4]; 方法三：通过array的unshift方法来添加。 说明一点：unshift是网数组最前面添加一个新元素。 12345var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;arr.unshift(4); // result is [4,1,2,3]; 修改数组中的元素通过下标修改元素内容。 1234567var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;//下标修改arr[0] = 4;console.log(arr); // result is [4,2,3]; 删除数组元素内容 方法一：通过array的pop方法来添加。 说明一点：pop是往数组删除末尾元素。 12345var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;arr.pop(); // result is [1,2]; 方法二：通过array的shift方法来添加。 说明一点：shift是网数组删除最前面一个元素。 12345var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;arr.shift(); // result is [2,3]; 合并数组用concat方法来合并另外一个数组。 1234var arr = [1,2,3];var arr1 = [4,5,6];var arr2 = arr.concat(arr1);console.log(arr2); // [1,2,3,4,5,6]; 删除指定数组用splice方法来合并另外一个数组。 注意：splice方法接受两个参数，一个从哪里开始，一个是到哪里结束。 123var arr = [1,2,3];arr.splice(0,1);console.log(arr); // [2,3]; 截取指定数组用slice方法来合并另外一个数组。 注意：slice方法接受两个参数，一个从哪里开始，一个是到哪里结束（但是不包括这个结束的元素本身）。如果是负数，就从倒数第几个。 12var arr = [1,2,3];console.log(arr.slice(0,1);); // [1]; 写在最后今天的数组操作方法就介绍这么多，以后会持续更新的。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/tags/javascript/"},{"name":"数组操作","slug":"数组操作","permalink":"https://guanqi.xyz/tags/数组操作/"}]},{"title":"markdown使用笔记","slug":"markdown-notes","date":"2018-11-24T06:03:21.000Z","updated":"2019-07-14T07:37:52.563Z","comments":true,"path":"/note/markdown-notes/","link":"","permalink":"https://guanqi.xyz/note/markdown-notes/","excerpt":"","text":"导语：今天主要讲的就是markdown这门标记语言，说要标记语言，你们可能会想到html，对的，它就是一门超文本标记语言，用来展示网页内容结构的。 目录 介绍 用途 语法 介绍markdown它是用于文档的快速排版，类似于word。 它有以下特点： 轻量 简单 通用 用途 写博客 正因为它有那些特点，语法简单容易学，而且功能还比较强大，所以非常多的人用它来写博客。最流行的博客平台有很多都支持markdown，比如说wordpress，zblog等博客平台，还有github等代码托管平台。 写说明 在github上随处可见各种仓库都有README.md结尾的说明文档，帮助开发者更好的了解这个仓库存放的东西是什么，都有哪些功能作用，可以用来做什么。 转化 转化这个用途，就不太常见了，它主要是把markdown文件转化为ppt,word等文件文档格式。用于学术研究，数据计算等领域。 语法 标题 文本 图片 链接 列表 表格 代码 标题在markdown的语法规则中，标题是用 # 号来标记的，一共有六级，分别是1-6类似于html的标题标签。# 号从大到小，内容从大到小，# 号越多，级别越小，内容越详细。 语法如下: 123456# 标题1## 标题2### 标题3#### 标题4##### 标题5###### 标题6 文本文本也是markdown的特色之一。包括粗体，斜体，删除，引用，分割线。 123456789101112131415161718// 1.粗体用两个*号包围内容。 *我是斜体*// 2.斜体用一对*号包围内容。**我是粗体**// 3.删除用一对两个波浪线表示 ~~我是删除内容~~// 4.引用是用大于号来表示，大于号越多，程度越深。 &gt; 我是引用的内容&gt;&gt; 我是引用的内容&gt;&gt;&gt;&gt;&gt; 我是引用的内容//5.分割线是用来区分各段落的不同内容的。---我是分割线--- 图片说明图片使用最前面一个英文叹号，中间是方括号括起来，写说明，后面是一个花括号，写图片地址。 语法：![我是图片](xxx.jpg) 这样就是表示一个图片。 例如： 图片占位图 链接链接的使用方法和图片有些类似，就是去掉了叹号，后面的都不变，前面还是方括号，用来链接地址文字说明，后面是花括号，用于链接的网络地址。 语法： [链接说明](http://www.example.com) 例如：百度 列表列表是用来展示要点，一列一列显示内容，用于内容比较多的时候使用。 语法： 无序列表：+和-。+就是一级列表，-就是二级列表。 有序列表：用数字加点，要空格。 例如： 12345678910111213141516// 这是无序列表。+ 水果 - 香蕉 - 苹果 - 葡萄+ 蔬菜+ 谷物+ 天气// 这是有序列表。1. 水果2. 蔬菜3. 谷物4. 天气 表格表格是用于展示某一个统计内容的，范围比较广。 语法: 123456表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容两点是左右，点在左边就文字居左。 例如： 序号 姓名 成绩 排名 1 张三 98 优秀 2 李四 46 不及格 3 王五 63 合格 代码可以用代码或者代码块来写代码，是广大程序员必爱之物。 语法： 两个斜点表示一个代码条，并且高亮显示； 三个斜点一排，排成两排，中间写点内容，就是代码块，用来展示很多段代码。你可以在第一排旁边写上你要写代码的内容类型，比如：html,css,javascript或js,php等等都可以广泛的支持各种标记、编程语言。 效果如下： 代码条 例如：css 代码块 例如：这是一段html标记语言代码块。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Markdown学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Markdown&lt;/h1&gt; &lt;p&gt;欢迎学习markdown课程。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 例如：这是一段css标记语言代码块。 123456h1 &#123; color: #f00;&#125;p &#123; line-height: 20px;&#125; 例如：这是一段js标记语言代码块。 1document.write('你好，欢迎学习markdown教程'); 写在最后Markdown是一门非常不错的，值得每个人学习的文本编辑器都支持的标记语法的语言，希望每个人都能学会，这里我只是把我日常写作中常用的做了一个总结汇总，都某时记不得的时候，再来回顾。","categories":[{"name":"markdown","slug":"markdown","permalink":"https://guanqi.xyz/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://guanqi.xyz/tags/markdown/"},{"name":"富文本","slug":"富文本","permalink":"https://guanqi.xyz/tags/富文本/"}]},{"title":"雅虎军规总结","slug":"summary-of-yahoo-military-regulations","date":"2018-11-18T14:16:21.000Z","updated":"2019-07-14T07:32:33.650Z","comments":true,"path":"/note/summary-of-yahoo-military-regulations/","link":"","permalink":"https://guanqi.xyz/note/summary-of-yahoo-military-regulations/","excerpt":"","text":"导语：雅虎军规是雅虎的开发人员在总结了网站的不合理部分后，提出的优化网站性能提高的一套方法规则，非常适合初学者绕过这些坎。这篇博文，是我在网络上搜集的一些关于雅虎军规的内容，图片归原作者所有，总结一起，供大家参考使用，希望对你们以后的开发过程中有所帮助。 http 目录 尽可能的减少http请求数 使用CDN（内容分发网络） 添加Expire/Cache-Control头 启用Gzip压缩 将css放在页面最上面 将script放在页面最下面 避免在CSS中使用Expressions 把js和css文件放到外部文件中 减少DNS查询 压缩JavaScript和Css 避免重定向 移除重复的脚步 配置实体标签（ETag） 使用Ajax缓存 尽可能的减少http请求数HTTP：从客户端到服务器端的请求消息。包括消息首行中，对资源的请求方法资源的标识符以及使用的协议。 请求过程：当你打开网页的时候，你所看到的文字，图片，多媒体，这一切内容，都是你从服务器获取的，每一个内容的获取，就是一个http请求。 http 使用CDN（内容分发网络）CDN：内容分发网络，意思就是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 CDN 通俗来说：就是在离你最近的地方，放置一台性能好、链接顺畅的副本服务器，让你能够以最近的距离，最快的速度获取内容。 CDN 添加Expire/Cache-Control头Expire头：内容是一个时间值，值就是资源在本地的过期时间，存在本地；在本地缓存阶段，找到一个对应的资源值，当前时间还没有超过资源的过期时间，就直接使用这个资源，不会发送http请求。 Cache-Control头C：是http协议中常用的头部之一，负责页面的缓存机制，如果该头部指示缓存，缓存的内容也会存在本地，操作流程和expire相似，但也有不同的地方，Cache-Control有更多的选项，而且有更多的处理方式。 启用Gzip压缩看图： Gzip压缩 举个例子： Gzip压缩 将css放在页面最上面CSS：CSS，就是层叠样式表。 CSS01 为了提高游览器加载速度，建议放在html的head标签内。 CSS02 CSS03 将script放在页面最下面页面DOM加载顺序： js01 为了顺利加载各种资源，把js放在页面最下面，可以正常运行脚本，也为获取DOM元素更流畅。 避免在CSS中使用Expressions定义： CSS—Expressions 例子： CSS—Expressions 把js和css文件放到外部文件中情况1：写在页面内，如果只是的单独一个页面使用js和css文件，可以写在页面里面；还有就是不经常访问的页面；并且脚本和样式很少。这样写可以： 减少页面请求 提升页面渲染速度 情况2：单独提取，如果是大量页面复用，那就需要引入js和css文件。这样写可以： 提高js和css的复用性 缩小页面体积 提高了js的css的可维护性 减少DNS查询DNS：（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。 DNS 缓存时间对比: 当缓存时间长时：减少DNS的重复查找，节省时间。 当缓存时间短时：及时的检测网站服务器的变化，保证正确性。 DNS 域名：（Domain Name），简称域名、网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。 可以使用单域和多域 DNS 压缩JavaScript和Css方法： 去除不必要的空白符，格式符，注释符。 简写方法名，参数名压缩js脚本。 例如：jquery 压缩JavaScript和Css 建议：：在网站上线项目前，将JavaScript和Css都进行压缩，使线上版本是最轻量级的，大幅提升网站性能。 避免重定向定义： 原始请求被重新转向了其他请求。 避免重定向 状态码： 301（Moved Permanently）：被移动到了另外的位置。 302 Found：被找到了，不在原始位置，临时重定向。 避免重定向 为什么避免重定向：多了一次请求。 避免重定向 移除重复的脚步例子: 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;移除重复的脚步&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=\"test\" type=\"text\" value=\"\"&gt; &lt;script&gt; var number = 0; &lt;/script&gt; &lt;script src=\"./test.js\"&gt;&lt;/script&gt; &lt;!-- 引用1次 正常 1 --&gt; &lt;script src=\"./test.js\"&gt;&lt;/script&gt; &lt;!-- 引用2次 不正常 2 --&gt;&lt;/body&gt;&lt;/html&gt; 123//js domnumber++;document.getElementById('test').value = number; 配置实体标签（ETag）定义：使用特殊的字符串来标识某个请求资源版本。 配置实体标签（ETag） 配置实体标签（ETag） 如果本地版本游览器一样，就使用本地的缓存文件，并且会返回304。 使用Ajax缓存定义：即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 使用Ajax缓存 方法：get和post POST：每次都执行，不被缓存。 get:同一地址不重复执行，可以被缓存。 get和post 写在最后这是我第一次总结前人的经验。","categories":[{"name":"前端规范","slug":"前端规范","permalink":"https://guanqi.xyz/categories/前端规范/"}],"tags":[{"name":"雅虎军规","slug":"雅虎军规","permalink":"https://guanqi.xyz/tags/雅虎军规/"},{"name":"性能优化","slug":"性能优化","permalink":"https://guanqi.xyz/tags/性能优化/"}]},{"title":"github配置教程","slug":"github-configuration-tutorial","date":"2018-11-18T14:16:21.000Z","updated":"2019-07-14T07:30:46.880Z","comments":true,"path":"/note/github-configuration-tutorial/","link":"","permalink":"https://guanqi.xyz/note/github-configuration-tutorial/","excerpt":"","text":"导语：github这个远程代码托管工具目前是世界上流行的,今天介绍一下如何配置GitHub。 目录 配置ssh 添加ssh key到GItHub Github新建项目 配置ssh检查本机是否有ssh key设置12//如果没有则提示： No such file or directory//如果有则进入~/.ssh路径下（ls查看当前路径文件，rm删除所有文件) 使用Git Bash生成新的ssh key1234567891011121314cd ~ #保证当前路径在”~”下ssh-keygen -t rsa -C \"xxxxxx@yy.com\" #建议填写自己真实有效的邮箱地址Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/xxxx_000/.ssh/id_rsa): #不填直接回车Enter passphrase (empty for no passphrase): #输入密码（可以为空）Enter same passphrase again: #再次确认密码（可以为空）Your identification has been saved in /c/Users/xxxx_000/.ssh/id_rsa. #生成的密钥Your public key has been saved in /c/Users/xxxx_000/.ssh/id_rsa.pub. #生成的公钥The key fingerprint is:e3:51:33:xx:xx:xx:xx:xxx:61:28:83:e2:81 xxxxxx@yy.com//本机已完成ssh key设置，其存放路径为：c:/Users/xxxx_000/.ssh/下。//可生成ssh key自定义名称的密钥，默认id_rsa。ssh-keygen -t rsa -C \"邮箱地址\" -f ~/.ssh/githug_blog_keys #生成ssh key的名称为githug_blog_keys，慎用容易出现其它异常。 添加ssh key到GItHub登录GitHub系统点击右上角账号头像的“▼”→Settings→SSH kyes→Add SSH key。 key 复制id_rsa.pub的公钥内容1) 进入c:/Users/xxxx_000/.ssh/目录下，打开id_rsa.pub文件，全选复制公钥内容。2) Title自定义，将公钥粘贴到GitHub中Add an SSH key的key输入框，最后“AddKey”。 配置账户12git config --global user.name “your_username” #设置用户名git config --global user.email “your_registered_github_Email” #设置邮箱地址(建议用注册giuhub的邮箱) 测试ssh keys是否设置成功1234567ssh -T git@github.comThe authenticity of host 'github.com(192.30.252.129)' can't be established.RSA key fingerprint is16:27:xx:xx:xx:xx:xx:4d:eb:df:a6:48.Are you sure you want to continueconnecting (yes/no)? yes #确认你是否继续联系，输入yesWarning: Permanently added'github.com,192.30.252.129' (RSA) to the list of known hosts.Enter passphrase for key'/c/Users/xxxx_000/.ssh/id_rsa': #生成sshkye是密码为空则无此项，若设置有密码则有此项且，输入生成ssh key时设置的密码即可。Hi xxx! You've successfullyauthenticated, but GitHub does not provide shell access. #出现词句话，说明设置成功。 Github项目Github新建项目点击按钮 新建 注意项目名（必须是：github的用户名.github.io） 新建 将项目clone到本地git clone https://github.com/&lt;你的用户名&gt;/&lt;仓库名字&gt;.git 然后输入命令，回车，等待clone完成。 将index.html推送到远程github仓库中123git add .git commit -m \"这里是注释信息，自己写\"git push origin master 写在最后git的配置就到这里。","categories":[{"name":"git","slug":"git","permalink":"https://guanqi.xyz/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://guanqi.xyz/tags/git/"},{"name":"github配置","slug":"github配置","permalink":"https://guanqi.xyz/tags/github配置/"}]},{"title":"使用gulp编译es6","slug":"compile-es6-with-gulp","date":"2018-10-22T13:30:21.000Z","updated":"2019-07-14T07:26:59.138Z","comments":true,"path":"/note/compile-es6-with-gulp/","link":"","permalink":"https://guanqi.xyz/note/compile-es6-with-gulp/","excerpt":"","text":"导语：今天，来探讨一下gulp构建工具的使用。 安装依赖包 安装前你需要安装node.js和npm以及gulp三个包。 然后执行以下命令 1npm init 然后在安装 babel和babel-core两个包 1npm install --save-dev gulp-babel babel-preset-env 1npm install babel-cor --save-dev 建立文件夹 新建一个名为gulpfile.js的文件夹,然后引入包 12345678910111213const gulp = require('gulp');const babel = require('gulp-babel');gulp.task('default', () =&gt; gulp.src('es6/*.js') .pipe(babel(&#123; presets: ['env'] &#125;)) .pipe(gulp.dest('dist')));gulp.task('babel',() =&gt; &#123;gulp.watch('es6/*.js',['default'])&#125;); 新建一个名为src 的文件夹,然后写点js. 123456&#123; let a = 3; let arr = [1,2,3];&#125;console.log(a);console.log(arr); 运行任务$ gulp $ gulp babel 这样就大功告成了！","categories":[{"name":"gulp","slug":"gulp","permalink":"https://guanqi.xyz/categories/gulp/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://guanqi.xyz/tags/es6/"},{"name":"gulp","slug":"gulp","permalink":"https://guanqi.xyz/tags/gulp/"}]},{"title":"git命令使用教程","slug":"git-command-using-tutorial","date":"2018-09-25T09:30:21.000Z","updated":"2019-07-14T07:24:58.809Z","comments":true,"path":"/note/git-command-using-tutorial/","link":"","permalink":"https://guanqi.xyz/note/git-command-using-tutorial/","excerpt":"","text":"导语：这是一个学习git-bash以及命令的教程! 目录 常用命令 分支 标签 其他 常用命令git add &quot;&lt;filename&gt;&quot;含义：这是将文件从本地文件夹提交到git storage (暂存区)。 例如：git add test.txt git commit -m &quot;&lt;message&gt;&quot;含义：这是将暂存区的文件提交到当前分支(master)。 例如： git commit -m &quot;add files&quot; git pull origin &lt;branch name&gt;含义： 这是将远程仓库的git文件拉到本地。 例如：git pull origin master git push origin &lt;branch name&gt;含义： 这是将本地分支的git文件推送到远程仓库。 例如：git push origin master 分支创建分支git branch &lt;分支名字&gt; 例如：git branch dev 切换到指定分支git checkout dev 创建并且切换到指定分支git branch -b &lt;分支名字&gt; 例如：git branch -b dev 删除分支git branch -d &lt;分支名字&gt; 例如：git branch -d dev 强制删除分支git branch -D &lt;分支名字&gt; 例如：git branch -D dev 删除远程分支git push origin -D &lt;分支名字&gt; 例如：git push origin -D dev 合并分支git merge &lt;分支名称&gt; 例如：git merge dev 标签创建标签git tag &lt;标签名字&gt; 例如: git tag v0.1 查看所有标签git tag 查看标签信息git show v0.1 创建带有说明的标签git tag -a v0.1 -m &quot;add tags&quot; 删除标签git tag -d &lt;标签名字&gt; 推送标签到远程仓库 推送本地全部标签：git push origin --tags 推送特定标签：git push origin v0.1 删除远程仓库标签git push origin :refs/tags/v0.1 其他忽略其他文件 有时候我们并不希望一些东西在我们的提交内容里面，比如node_moundle 在文件夹下面创建.gitignore就可以忽略不希望提交的内容。 12# windowsDesktop.ini 最后这一期的git讲解就到这里。","categories":[{"name":"git","slug":"git","permalink":"https://guanqi.xyz/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://guanqi.xyz/tags/git/"},{"name":"git命令","slug":"git命令","permalink":"https://guanqi.xyz/tags/git命令/"}]},{"title":"Vue基础教程","slug":"vue-basic-tutorial","date":"2018-05-06T13:54:21.000Z","updated":"2019-07-14T07:00:27.967Z","comments":true,"path":"/note/vue-basic-tutorial/","link":"","permalink":"https://guanqi.xyz/note/vue-basic-tutorial/","excerpt":"","text":"导语：今天给大家讲解vue的基础知识点。 目录 引入vue 声明式渲染 创建vue实例 数据绑定 方法 插值 指令 缩写 引入vue 下载vue.js文件：点击下载 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; CDN线上，引入地址：https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.common.js &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.common.js&quot;&gt;&lt;/script&gt; 新建html文件，在head标签内引入 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;引入vue&lt;/title&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- //内容 --&gt; &lt;/div&gt; &#123;&#123; 1+2 &#125;&#125; &lt;script&gt; new Vue(&#123; el: '#app' &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 声明式渲染两个花括号中间可以写表达式，判断，数据类型，就是不能写循环。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;引入vue&lt;/title&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;&#123; msg &#125;&#125; &lt;script&gt; new Vue(&#123; el: '#app', data: &#123; msg: '111' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 创建vue实例 首先引入vue.js文件 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 然后实例化一个vue 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最后定义vue的管理边界 注意： 如果你不定义管理边界，就可能无法应用vue中的属性和方法。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 在这里写vue.js --&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 数据绑定数据： 这里的数据就是你要渲染到页面中的值,这个数据发生变化，视图中的数据也会发生变化。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 在这里写vue.js --&gt; &lt;input type=\"text\" v-model=\"str\"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; str: '' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方法方法： 就是js中的函数和事件监听。 例如：弹出一个信息。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 在这里写vue.js --&gt; &lt;input type=\"text\" v-model=\"str\"&gt; &lt;p&gt;&#123;&#123; str &#125;&#125;&lt;/p&gt; &lt;button @click=\"alertInfo\"&gt;弹出信息&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; str: '' &#125;, methods: &#123; alertInfo () &#123; alert('这就是vue'); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 插值文本插值 这是数据绑定最常见的形式，使用的Mustache语法 (双大括号) 。 例如：&lt;span&gt;这个将不会改变: &lt;/span&gt; 原生html内容这个你需要使用v-html来实现。 例如： 1.&lt;p&gt;这是html内容：&lt;/p&gt; 2.&lt;p v-html=&quot;str&quot;&gt;&lt;/p&gt; 注意：你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。 指令 指令 (Directives) 是带有 v- 前缀的特殊特性，响应式的作用于DOM。 v-if含义：这个是根据传入的值来决定是否移除绑定的元素，它的值是true或者false 例如：&lt;p v-if=&quot;true&quot;&gt;我是vue&lt;/p&gt; 修饰符修饰符：以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。 &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;表单内容&lt;/form&gt; 缩写v- 作为一种识别特性，常常会缩写，以便提高代码效率。 v-onv-on是绑定元素要触发的各种事件的，可以缩写成@&lt;事件名&gt;=&quot;&lt;触发的函数名&gt;&quot; 例如： 1234//1.原样：&lt;button v-on:click=\"checkForm\"&gt;&lt;/button&gt;//2.缩写：&lt;button @click=\"checkForm\"&gt;&lt;/button&gt; v-bindv-bind是绑定元素属性的一种指令，可以缩写成:&lt;属性名&gt;=&quot;&lt;属性值&gt;&quot; 例如： 1234&lt;!-- 1.原样： --&gt;&lt;a v-bind:href=\"url\"&gt;链接&lt;/a&gt;&lt;!-- 2.缩写： --&gt;&lt;a :href=\"url\"&gt;链接&lt;/a&gt;","categories":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/categories/vuejs/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/tags/vuejs/"},{"name":"vue基础","slug":"vue基础","permalink":"https://guanqi.xyz/tags/vue基础/"}]},{"title":"初识webpack","slug":"first-knowledge-of-webpack","date":"2018-04-01T08:07:39.000Z","updated":"2019-07-14T07:22:56.806Z","comments":true,"path":"/note/first-knowledge-of-webpack/","link":"","permalink":"https://guanqi.xyz/note/first-knowledge-of-webpack/","excerpt":"","text":"导语：今天，咱们正式介绍一下前端构建打包神器，webpack。这是一款非常流行的打包工具，和各种框架都非常搭配。 目录 简介 核心概念 简介大家好！今天我开始分享有关web前端的故事。俗话说：“男怕入错行，女怕嫁错郎”。如果能够进入发展前景比较好的行业是一个不错的选择，对自己以后的成长与发展都会起到很大的作用。虽然说目前还看不出什么，但是相信随着时间的流逝，这个行业会越来越好。而我选择的这个行业，就是互联网行业，属于服务业。而我目前从事的是前端，这个从2015年兴盛起来的职业，目前已经度过了寒冬，正迎来蓬勃的生机。 核心概念接下来就解释一下这四个核心的概念。 入口(entry) 输出(output) loader 插件(plugins) 入口(entry)入口：所谓入口，就是指示webpack应该使用哪个模块来作为内部依赖的开始，它会根据入口来生成一个bundles文件。 例如： 123module.exports = &#123; entry: './path/to/my/entry/file.js'&#125;; 上面就是指定入口文件，就是file.js。 输出(output)出口：就是打包输出到哪个文件夹下面去。 例如： 1234567const path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;&#125;; 上面就是指定出口文件dist，文件名称叫dist文件夹下面的这个文件my-first-webpack.bundle.js。 loaderloader:就是让webpack去处理那些非JavaScript文件，并且导入任何类型的模块，比如css。并且，进行处理。它可以将所有类型的文件，转化为可以直接引用的模块。 例如： 123456789101112131415//定义规则const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; //解析规则 ] &#125;&#125;;// 到处配置module.exports = config; 这个就是，模块打包规则。test,use,就是告诉webpack遇到引用txt文件的，使用raw-loader转化一下。 插件(plugins)这是最后一个核心概念。有时候，前面的不一定处理过来，所以靠扩展插件来提高打包效率是一个非常有效的方法。它可以执行更多复杂的任务，例如：打包优化，压缩，重新定义环境变量等等。 插件的使用方法见下面的代码。 1234567891011121314151617const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config; 总结我们今天先说到这里，下次继续聊webpack。","categories":[{"name":"前端工具","slug":"前端工具","permalink":"https://guanqi.xyz/categories/前端工具/"}],"tags":[{"name":"前端工具","slug":"前端工具","permalink":"https://guanqi.xyz/tags/前端工具/"},{"name":"webpack","slug":"webpack","permalink":"https://guanqi.xyz/tags/webpack/"}]},{"title":"js系统命令常用方法","slug":"js-system-command-common-method","date":"2017-12-25T07:27:21.000Z","updated":"2019-07-14T09:30:05.450Z","comments":true,"path":"/note/js-system-command-common-method/","link":"","permalink":"https://guanqi.xyz/note/js-system-command-common-method/","excerpt":"","text":"导语：在日常开发过程中，也会遇到使用系统命令的需求，比如复制一段文本什么的，现在就总结一下如何使用系统命令。 简介document.execCommand()方法处理Html数据时常用语法格式如下: document.execCommand(sCommand[,交互方式, 动态参数]) 其中：sCommand为指令参数（如下例中的’2D-Position’），交互方式参数如果是true的话将显示对话框，如果为false的话，则不显示对话框（下例中的’false’即表示不显示对话框），动态参数一般为一可用值或属性值（如下例中的’true’）。 document.execCommand(&#39;2D-Position&#39;,&#39;false&#39;,&#39;true&#39;); 调用execCommand()可以实现浏览器菜单的很多功能. 如保存文件,打开新文件,撤消、重做操作…等等. 有了这个方法,就可以很容易的实现网页中的文本编辑器. 如果灵活运用,可以很好的辅助我们完成各种项目. 常用方法使用的例子如下: 全选格式: document.execCommand(&#39;selectAll&#39;) 说明: 将选种网页中的全部内容！ 打开格式: document.execCommand(&#39;open&#39;) 说明:这跟VB等编程设计中的webbrowser控件中的命令有些相似，大家也可依此琢磨琢磨。 另存为格式: document.execCommand(&#39;saveAs&#39;) 说明: 将该网页保存到本地盘的其它目录！ 打印格式: document.execCommand(&#39;print&#39;) 说明: 当然，你必须装了打印机！ 案例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//相当于单击文件中的打开按钮document.execCommand('Open');//将当前页面另存为document.execCommand('SaveAs');//剪贴选中的文字到剪贴板;document.execCommand('Cut','false',null);//删除选中的文字;document.execCommand('Delete','false',null);//改变选中区域的字体;document.execCommand('FontName','false',sFontName);//改变选中区域的字体大小;document.execCommand('FontSize','false',sSize|iSize);//设置前景颜色;document.execCommand('ForeColor','false',sColor);//使绝对定位的对象可直接拖动;document.execCommand('2D-Position','false','true');//使对象定位变成绝对定位;document.execCommand('AbsolutePosition','false','true');//设置背景颜色;document.execCommand('BackColor','false',sColor);//使选中区域的文字加粗;document.execCommand('Bold','false',null);//复制选中的文字到剪贴板;document.execCommand('Copy','false',null);//设置指定锚点为书签;document.execCommand('CreateBookmark','false',sAnchorName);//将选中文本变成超连接,若第二个参数为true,会出现参数设置对话框;document.execCommand('CreateLink','false',sLinkURL);//设置当前块的标签名;document.execCommand('FormatBlock','false',sTagName);//相当于单击文件中的打开按钮document.execCommand('Open');//将当前页面另存为document.execCommand('SaveAs');//剪贴选中的文字到剪贴板;document.execCommand('Cut','false',null);//删除选中的文字;document.execCommand('Delete','false',null);//改变选中区域的字体;document.execCommand('FontName','false',sFontName);//改变选中区域的字体大小;document.execCommand('FontSize','false',sSize|iSize);//设置前景颜色;document.execCommand('ForeColor','false',sColor);//使绝对定位的对象可直接拖动;document.execCommand('2D-Position','false','true');//使对象定位变成绝对定位;document.execCommand('AbsolutePosition','false','true');//设置背景颜色;document.execCommand('BackColor','false',sColor);//使选中区域的文字加粗;document.execCommand('Bold','false',null);//复制选中的文字到剪贴板;document.execCommand('Copy','false',null);//设置指定锚点为书签;document.execCommand('CreateBookmark','false',sAnchorName);//将选中文本变成超连接,若第二个参数为true,会出现参数设置对话框;document.execCommand('CreateLink','false',sLinkURL);//设置当前块的标签名;document.execCommand('FormatBlock','false',sTagName); 复制粘贴版第一种：原生12&lt;span id=\"spanid\"&gt;12345678&lt;/span&gt;&lt;input type=\"button\" onClick=\"savetext()\" value=\"点击复制代码\" /&gt; 1234567891011function savetext() &#123; var Url2=document.getElementById(\"spanid\").innerText; var oInput = document.createElement('input'); oInput.value = Url2; document.body.appendChild(oInput); oInput.select(); // 选择对象 document.execCommand(\"Copy\"); // 执行浏览器复制命令 oInput.className = 'oInput'; oInput.style.display='none'; alert('复制成功');&#125; 在这里预览。 第二种：clipboard.js 安装clipboard 1npm install clipboard --save 引入包 12&lt;script src=\"https://cdn.bootcss.com/clipboard.js/2.0.4/clipboard.min.js\"&gt;&lt;/script&gt;//或者 使用方法 12&lt;span class=\"topword\"&gt;&#123;&#123;promocode1&#125;&#125;&lt;/span&gt;&lt;button class=\"btn\" @click=\"copyContent\"&gt;Copy&lt;/button&gt; 12345678910111213141516171819202122232425data () &#123; return &#123; clipboard: null//存到vue的data里 &#125;&#125;,copyContent() &#123; this.clipboard = new ClipboardJS(\".btn\", &#123; target: function () &#123; return document.querySelector(\".topword\"); &#125; &#125; ); this.clipboard.on(\"success\", function(e) &#123; console.log(e.text); alert('复制成功了~~~~~~~~~~~~') &#125;); //如果是vue模块话开发就这样写，先require一下，然后new const clipboard = require(\"clipboard\"); this.clipboard = new clipboard (\".btn\", &#123; target: function () &#123; return document.querySelector(\".topword\"); &#125; &#125; );&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guanqi.xyz/tags/javascript/"},{"name":"exex","slug":"exex","permalink":"https://guanqi.xyz/tags/exex/"}]},{"title":"node连接mysql","slug":"node-connection-mysql","date":"2017-12-23T07:27:21.000Z","updated":"2019-07-14T09:21:28.844Z","comments":true,"path":"/note/node-connection-mysql/","link":"","permalink":"https://guanqi.xyz/note/node-connection-mysql/","excerpt":"","text":"导语：今天介绍一下如何在nodejs中使用MySQL数据库来构建后台管理系统。 下载mysql依赖安装一下依赖包。 12npm i -D mysqlnpm i -D node-mysql 引入配置包在根目录下的model/db.js文件中引入包。 123456789101112131415161718192021const mysql = require('mysql');const client = (sql, arg, callback) =&gt; &#123; //1.创建连接 let config = mysql.createConnection(&#123; host: 'localhost', user: 'root', password: 'root', database: 'vue' &#125;) //2.开始连接 config.connect() //3.对数据库进行增删查改 config.query(sql, arg, (err, data) =&gt; &#123; callback &amp;&amp; callback(err, data) &#125;) //4.关闭数据库 config.end()&#125;module.exports = client; 具体使用方法这里以一个注册登录为例展示使用方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112var express = require('express');var router = express.Router();var db = require('../model/db');/* GET users listing. */router.get('/', function(req, res, next) &#123; res.send('respond with a resource');&#125;);router.get('/user/list', function (req, res, next) &#123; db('select * from user', [], (err, data) =&gt; &#123; if (err) &#123; res.json(&#123; code: 101, info: '获取失败', data: err &#125;) &#125; if (data) &#123; res.json(&#123; code: 200, info: '获取成功', data: data &#125;) &#125; &#125;)&#125;)router.post('/user/reg', function (req, res, next) &#123; console.log(req.body); db('select * from user where username = \"' + req.body.userName + '\"', [], (err, data) =&gt; &#123; if (err) &#123; res.json(&#123; code: 101, info: '获取失败', data: err &#125;) &#125; if (data) &#123; if (data.length !== 0) &#123; res.json(&#123; code: 109, info: '用户已存在!', data: [] &#125;) &#125; else &#123; db('insert into user(id, username, password, isAdmin) values(?, ?, ?, ?)', [req.body.userId, req.body.userName, req.body.userPwd, 1], (err, data) =&gt; &#123; if (err) &#123; res.json(&#123; code: 101, info: '注册失败', data: err &#125;) &#125; if (data) &#123; res.json(&#123; code: 200, info: '注册成功', data: data &#125;) &#125; &#125;) &#125; &#125; &#125;)&#125;)router.post('/user/login', function (req, res, next) &#123; console.log(req.body); db('select * from user where username = \"' + req.body.userName + '\"', [], (err, data) =&gt; &#123; if (err) &#123; res.json(&#123; code: 101, info: '获取失败', data: err &#125;) &#125; if (data) &#123; if (data.length !== 0) &#123; if (data[0].username != req.body.userName) &#123; res.json(&#123; code: 109, info: '用户昵称错误!', data: [] &#125;) &#125; else if (data[0].password != req.body.userPwd) &#123; res.json(&#123; code: 109, info: '密码错误!', data: [] &#125;) &#125; else &#123; res.json(&#123; code: 200, info: '登录成功!', data: [] &#125;) &#125; &#125; else &#123; res.json(&#123; code: 109, info: '用户不存在!', data: [] &#125;) &#125; &#125; &#125;)&#125;)module.exports = router; 调用接口1node bin/www.js 这时候我们就可以调用接口了。 解决跨域问题方法： 1234567app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", '*'); res.header(\"Access-Control-Allow-Headers\", \"Content-Type\"); res.header(\"Access-Control-Allow-Methods\",\"*\");//允许访问的方式 res.header(\"Content-Type\", \"application/json;charset=utf-8\"); next();&#125;); 调用接口：一个注册案例。 这里使用axios。 12345678910111213141516171819202122//用户信息this.userInfo = &#123; isLogin: true, userId: Date.parse(new Date()), userName: this.user.name, userPwd: this.user.pwd, token: 'auth' + Date.parse(new Date())&#125;//注册this.$axios.post(api.addUser, this.userInfo).then((res) =&gt; &#123; if (res.data.code === 109) &#123; this.isSucc = false this.isShowTip = true this.tipText = res.data.info &#125; else &#123; this.isSucc = true this.isShowTip = true this.tipText = res.data.info &#125;&#125;).catch((error) =&gt; &#123; console.error(error)&#125;) 最后今天就到这里。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/tags/nodejs/"},{"name":"mysql","slug":"mysql","permalink":"https://guanqi.xyz/tags/mysql/"}]},{"title":"Node常用命令","slug":"node-common-command","date":"2017-12-21T07:27:21.000Z","updated":"2019-07-14T07:19:40.452Z","comments":true,"path":"/note/node-common-command/","link":"","permalink":"https://guanqi.xyz/note/node-common-command/","excerpt":"","text":"导语：现今的包管理器有很多，包括npm,yard,bower,今天介绍两个包管理器，分别是npm和bower,本篇采用git工具安装。&gt; node package manager ,Node 的包管理器。 目录 安装node bower安装命令 npm初始化 安装node验证是否安装node。 12node -vnpm -v 安装包 安装到当前目录 1npm install &lt;包名&gt; 出现error network 重新安装 安装指定版本 在cmd中: 12npm install &lt;包名&gt;@版本号npm install jquery@1.12.4 搜索包1npm search &lt;包名&gt; 查看包的版本信息1npm list &lt;包名&gt; 查看安装的包列表1npm ls 更新包1npm update &lt;包名&gt; 卸载包1npm uninstall jquery bower安装命令bower安装包bower install &lt;包名&gt; --save,在当前目录安装包，并将版本信息添加到bower.json中 bower install &lt;包名&gt;@版本号，安装指定的版本号 bower查看包的信息bower info &lt;包名&gt; 查看包的详细信息 bower搜索包bower search &lt;包名&gt; bower包列表bower list bower卸载包bower uninstall &lt;包名&gt; npm初始化npm init 会生成一个packagejson的文件，项目的配置信息。 1npm init 12345678910111213141516171819&#123; \"name\": \"day06\", //项目名 \"version\": \"1.0.0\", //版本号 \"description\": \"this is a npm project\", //项目的描述 \"main\": \"index.js\", //程序的入口文件 \"dependencies\": &#123; //项目依赖的包!!!重要的 \"jquery\": \"^1.12.4\", \"zepto\": \"^1.2.0\" &#125;, \"devDependencies\": &#123;&#125;, //开发阶段依赖的包!!!重要的 \"scripts\": &#123; //命令 \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [ //关键词 \"npm\" ], \"author\": \"guanqi\", //作者 \"license\": \"ISC\" //协议&#125; 安装并添加依赖npm install &lt;包名&gt; --save 会将当前目录下的安装包，并将包的信息，添加到package.json中的dependencies选项中 npm install &lt;包名&gt; --save-dev安装开发阶段用的工具包，并不是项目必须有的。这个命令会将包安装到当前目录下的安装包，并将包的版本信息，添加到package.json中的devDependencies选项中 全局安装npm install &lt;包&gt; -g , -g代表全局安装，不会在package.json中看到 写在最后心动不如行动，快练习一下巩固知识。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/tags/nodejs/"},{"name":"node命令","slug":"node命令","permalink":"https://guanqi.xyz/tags/node命令/"}]},{"title":"Node简介","slug":"introduction-to-node","date":"2017-12-10T10:04:21.000Z","updated":"2019-07-14T07:14:40.053Z","comments":true,"path":"/note/introduction-to-node/","link":"","permalink":"https://guanqi.xyz/note/introduction-to-node/","excerpt":"","text":"导语：Node.js是一个很不错的后端服务器编程语言,下面介绍Node的概念以及使用方法。 目录 简介 作者 适用场景 Global REPL环境 运行Node 简介官网中文官网 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js是构建在 chorme的V8引擎上的一个js运行时 Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. 事件驱动(回调函数) 非阻塞异步I/O 单线程单进程 Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 作者Ryan Dahl 适用场景 高并发(双11) 站内信 实时聊天 缺点：不适合大量的计算 Global在游览器中全局对象（顶层对象）是window在node中全局对象叫Global Buffer process console setTimeout setInterval clearTimeout clearInterval REPL环境进入的方法，在cmd中输入node,然后enter，就可以进入node的REPL环境。 Read 读，读取用户输入，解析输入的JS数据结构并存储在内存中 Eval 执行，执行输入的数据结构 Print 打印，输出结果 Loop 循环 ，循环操作以上步骤，直到CTRL+C以后 退出REPL环境，用Ctrl+C两次 运行Node运行Node.js的代码 1node &lt;文件名&gt; 最后总结node是非常优秀的使用js编写的后端编程语言。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://guanqi.xyz/tags/nodejs/"},{"name":"node简介","slug":"node简介","permalink":"https://guanqi.xyz/tags/node简介/"}]},{"title":"todocmvc练习vue版","slug":"todocmvc-practice-vue-version","date":"2017-10-23T06:42:21.000Z","updated":"2019-07-14T07:11:04.810Z","comments":true,"path":"/note/todocmvc-practice-vue-version/","link":"","permalink":"https://guanqi.xyz/note/todocmvc-practice-vue-version/","excerpt":"","text":"导语：todomvc是一个练习各大框架的网站,你可以在上面用各种框架练习这个demo,这里使用vue框架进行练习。 目录 安装依赖 引入vue 功能实现 安装依赖安装依赖的css，js。 1npm install 引入vue1&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; 功能实现下面是一些常用的方法。 定义初始化数据在app.js中，实例化Vue，然后定义初始化数据 12345678910let vm = new Vue(&#123; el: '#app', data: &#123; datas: [ &#123;id: 121,title: 'html5',isCompleted: false&#125;, &#123;id: 122,title: 'css3',isCompleted: false&#125;, &#123;id: 123,title: 'js6',isCompleted: false&#125;, ] &#125;&#125;) 绑定假数据到li上如果当前的isCompleted是true,就是显示选中状态 12345678&lt;li :class=\"&#123;completed: isCom&#125;\" v-for=\"(item,index) in datas\"&gt; &lt;div class=\"view\"&gt; &lt;input class=\"toggle\" type=\"checkbox\"&gt; &lt;label&gt;&#123;&#123; item.title &#125;&#125;&lt;/label&gt; &lt;button class=\"destroy\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class=\"edit\" value=\"Create a TodoMVC template\"&gt;&lt;/li&gt; 双向数据绑定1&lt;input class=\"new-todo\" placeholder=\"What needs to be done?\" v-model=\"val\"&gt; 1val: '', //显式声明 输入框数据 回车输入数据1&lt;input class=\"new-todo\" placeholder=\"What needs to be done?\" @keyup.enter=\"addItem\" v-model=\"val\"&gt; 12345678910111213methods: &#123; addItem()&#123; if(this.val)&#123; //val存在或者非空的时候才会去添加 this.datas.push(&#123; //console.log(new Date().getTime()); id: new Date().getTime(), //为了保持id的唯一 title: this.val, isCompleted: false, &#125;); this.val = ''; //填完数据以后清空输入框的内容 &#125; &#125;&#125; 显示总计通过一个方法来计算数组数据的长度 1234567891011121314151617181920212223methods: &#123; addItem()&#123; if(this.val)&#123; //val存在或者非空的时候才会去添加 this.datas.push(&#123; //console.log(new Date().getTime()); id: new Date().getTime(), //为了保持id的唯一 title: this.val, isCompleted: false, &#125;); this.val = ''; //填完数据以后清空输入框的内容 &#125; &#125;, clearCompleted()&#123; let arr = []; //遍历datas,如果当前选项是未选中,就把它留下 this.datas.forEach(function(elem)&#123; if(!elem.isCompleted)&#123; arr.push(elem); &#125; &#125;,this) this.datas = arr; &#125;&#125; 绑定计算属性 1&lt;span class=\"todo-count\"&gt;&lt;strong&gt;&#123;&#123; legTotal &#125;&#125;&lt;/strong&gt; item left&lt;/span&gt; 显示隐藏completed通过v-show来控制显示隐藏 1&lt;button class=\"clear-completed\" v-show=\"isShowClear\"&gt;Clear completed&lt;/button&gt; 1234567891011//在计算属性中compluted：&#123; isShowClear()&#123; for(let i=0;i&lt;this.datas.length;i++)&#123; if(this.datas[i].isCompleted)&#123; return true &#125; &#125; return false &#125;&#125; completed删除选中项绑定点击事件 1&lt;button class=\"clear-completed\" v-show=\"isShowClear\" @click=\"clearCompleted\"&gt;Clear completed&lt;/button&gt; 在方法中写这个点击事件 12345678910clearCompleted()&#123; let arr = []; //遍历datas,如果当前选项是未选中,就把它留下 this.datas.forEach(function(elem)&#123; if(!elem.isCompleted)&#123; arr.push(elem); &#125; &#125;,this) this.datas = arr;&#125; 删除当前项添加点击事件 1&lt;button class=\"destroy\" @click=\"removeCurrent(index)\"&gt;&lt;/button&gt; 123removeCurrent(index)&#123; this.datas.splice(index,1);&#125; 全选全不选点击全选如果是true,让数据全部变成非选中状态; 1&lt;input id=\"toggle-all\" class=\"toggle-all\" type=\"checkbox\" @click=\"checkedAll\"&gt; 12345678910111213//在方法中checkedAll()&#123; if(this.isCheckedAll)&#123; //全部选中 this.datas.forEach(elem=&gt;&#123; elem.isCompleted = false; &#125;) &#125;else&#123; this.datas.forEach(elem=&gt;&#123; elem.isCompleted = true; &#125;) &#125; this.isCheckedAll = !this.isCheckedAll;&#125; 最后总结这是一个练习，是用vue写的，各方面都练习到了。","categories":[{"name":"vuejs","slug":"vuejs","permalink":"https://guanqi.xyz/categories/vuejs/"}],"tags":[{"name":"todomvc","slug":"todomvc","permalink":"https://guanqi.xyz/tags/todomvc/"}]},{"title":"使用hexo+coding搭建个人博客","slug":"use-hexo-coding-to-build-a-personal-blog","date":"2017-09-21T07:16:21.000Z","updated":"2019-07-14T07:05:22.527Z","comments":true,"path":"/note/use-hexo-coding-to-build-a-personal-blog/","link":"","permalink":"https://guanqi.xyz/note/use-hexo-coding-to-build-a-personal-blog/","excerpt":"","text":"导语:最近无数据库编程语言的博客程序大行其道,成为了博客爱好者的首选,这篇博文目的就是教大家如何建立自己的博客程序和网站。 目录 检测node和npm 安装hexo 切换主题 发布到coding 检测node和npm先检测一下有没有node.js和npm 12345678$ node -v//如果有，说明node.js安装成功！$ node -vv8.4.0//如果有，说明npm安装成功！$npm -v$ npm -v5.3.0 安装hexo在git-bash中运行以下命令安装hexo 安装hexo全局1npm install -g hexo-cli 建立文件夹123hexo init blogcd blognpm install 就能够建立起一个本地的服务器，端口是4000，打开浏览器 http://localhost:4000 就能访问属于你自己的博客了。 切换主题hexo博客程序有默认主题,但是你可以拥有自己的博客主题,下面介绍一款好的主题。 主题代码拷贝主题的拷贝也是直接使用 git 即可，首先进入到你博客的根目录，再打开 git-bash 运行 git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题12//在博客根目录下找到 _config.yml 文件，找到里面的 theme，改为theme: next 这时再运行一次 hexo s ，看看主题有没有生效吧。 发布到coding前提是你先注册一个coding账号 hexo 提供了一个部署命令 hexo deploy，首先需要安装一下 hexo-deployer-git插件 npm install hexo-deployer-git --save 然后配置一下_config.yml 文件： 1234deploy: type: git repoistory: https://git.coding.net/myblog/blog.git branch: master 预览效果 在 coding 上建立一个私人仓库，找到代码的 coding 地址，填好上面的配置，然后直接执行 hexo deploy 不出意外的话会让你填写 coding 的用户名和密码完成上传操作。如果你有配置 ssh 方式的话就更加方便了。 这个时候再到 coding 对应的项目里面打开 pages 服务，根据 coding 建议，因为不是 jekyll 项目，所以需要再新建一个.nojekyll 文件（空文件就行，其实不建立也行），等上一会就能够访问自己的博客了。 最后运行以下命令上传到coding 12hexo ghexo d 如果不行用git,输入以下命令 12345678mkdir blogcd bloggit initecho \"# blog\" &gt;&gt; README.mdgit add README.mdgit commit -m \"first commit\"git remote add origin https://git.coding.net/myblog/blog.gitgit push -u origin master 最后总结今天的hexo+coding配置免费博客就到这里，赶快体验一下吧！","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://guanqi.xyz/categories/博客搭建/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://guanqi.xyz/tags/hexo/"},{"name":"coding","slug":"coding","permalink":"https://guanqi.xyz/tags/coding/"}]},{"title":"SASS使用教程","slug":"sass-tutorial","date":"2017-09-19T00:42:21.000Z","updated":"2019-07-14T07:08:10.385Z","comments":true,"path":"/note/sass-tutorial/","link":"","permalink":"https://guanqi.xyz/note/sass-tutorial/","excerpt":"","text":"导语:本篇我想大家介绍SASS的一些知识，希望对大家有所帮助。 目录 SASS介绍 安装配置 语法介绍 SASS总结 SASS介绍SASS是世界上最成熟、最稳定、最强大的专业级CSS扩展语言！ SASS有以下四个特点: 兼容CSS:Sass完全兼容所有版本的CSS。我们对此严格把控，所以你可以无缝地使用任何可用的CSS库。 特性丰富:Sass拥有比其他任何CSS扩展语言更多的功能和特性。Sass核心团队不懈努力，一直使其保持领先地位 成熟:Sass已经经过其核心团队超过8年的精心打造。 行业认可:一次又一次地，行业把Sass作为首选CSS扩展语言。 社区庞大:数家科技企业和成百上千名开发者为Sass提供支持。 框架:有无数的框架使用Sass构建。比如Compass，Bourbon，和Susy。 安装配置安装前，你需要安装npm和gulp这两个工具。 安装ruby 由于sass基于ruby语言开发而成，所以安装sass前还需要安装ruby。 安装成功后，在cmd中输入以下命令： 123ruby -v//如果成功则会出现ruby 2.4.1p111 (2017-03-22 revision 58053) [x64-mingw32] 更换gem源 123456789101112//1.删除原gem源gem sources --remove https://rubygems.org///2.添加国内淘宝源gem sources -a https://ruby.taobao.org///3.打印是否替换成功gem sources -l//4.更换成功后打印如下*** CURRENT SOURCES ***https://ruby.taobao.org/ 安装sass 1234567891011//初始化npm$npm init//一路直下$ npm install sass --save-dev//查看版本$ sass -v//出现这说明安装成功Sass 3.5.1 (Bleeding Edge) 至此，已经安装好了sass。 语法介绍下面介绍一些语法知识。 导入@import &#39;reset&#39;所有的sass导入文件都可以忽略后缀名.scss。一般来说基础的文件命名方法以_开头，如_mixin.scss。这种文件在导入的时候可以不写下划线，可写成@import &quot;mixin&quot;。 注释12/**/多行注释//单行注释 变量声明变量用$符号 例如：$width:300px 默认变量加上default 例如：$width:300px!default 嵌套 选择器嵌套 12345678910div&#123; font-size: 20px; a&#123; span&#123; font-weight: 500; color: #ff0; font-size: 5em; &#125; &#125;&#125; 属性嵌套 12345678910111213div &#123; border: &#123; style: solid; left: &#123; width: 4px; color: #888; &#125; right: &#123; width: 2px; color: #ccc; &#125; &#125;&#125; 跳出嵌套 12345678910div&#123; font-size: 20px; a&#123; @at-root span&#123; font-weight: 500; color: #ff0; font-size: 5em; &#125; &#125;&#125; 伪类嵌套 12345678910111213div&#123; &amp;hover:&#123; color: #f00; &#125; font-size: 20px; a&#123; @at-root span&#123; font-weight: 500; color: #ff0; font-size: 5em; &#125; &#125;&#125; SASS总结通过学习SASS，我感受到了SASS强大的CSS编译功能，确实方便我们每个人进行CSS编译开发。","categories":[{"name":"前端工具","slug":"前端工具","permalink":"https://guanqi.xyz/categories/前端工具/"}],"tags":[{"name":"前端工具","slug":"前端工具","permalink":"https://guanqi.xyz/tags/前端工具/"},{"name":"css","slug":"css","permalink":"https://guanqi.xyz/tags/css/"},{"name":"sass","slug":"sass","permalink":"https://guanqi.xyz/tags/sass/"}]}]}