{"meta":{"title":"观奇笔记","subtitle":null,"description":"Front","author":"GuanQi","url":"https://gitguanqi.github.io"},"pages":[{"title":"","date":"2019-01-19T09:43:18.395Z","updated":"2019-01-19T09:43:18.395Z","comments":true,"path":"README.html","permalink":"https://gitguanqi.github.io/README.html","excerpt":"","text":"blog"},{"title":"categories","date":"2019-01-16T01:32:14.000Z","updated":"2019-01-16T01:32:29.712Z","comments":false,"path":"categories/index.html","permalink":"https://gitguanqi.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-16T01:31:24.000Z","updated":"2019-01-16T01:32:25.407Z","comments":false,"path":"tags/index.html","permalink":"https://gitguanqi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js中正则表达式使用方法","slug":"js-regexp-use","date":"2019-01-24T06:16:21.000Z","updated":"2019-01-24T10:01:29.551Z","comments":true,"path":"2019-01-24/js-regexp-use/","link":"","permalink":"https://gitguanqi.github.io/2019-01-24/js-regexp-use/","excerpt":"","text":"今天说一下有关js中正则表达式的一些知识点。正则表达式主要是在表单输入验证，以及一些文本字符处理中特表好用。 正则表达式的概念正则表达式是一个描述字符模式的对象，最早是诞生于Perl语言中，JavaScript继承了Perl语言的正则表达式的一些特性，方法和概念。在JavaScript中，有一个类RegExp表示正则表达式，而且String和RegExp都有对应的模式匹配和文本检索、替换的函数。 创建正则表达式创建正则表达式可以使用两种方法，这是js对象一以贯之的方法，就是new实例化一个对象，或者直接写正则表达式。 new运算符创建通过new运算符来实例化一个RegExp对象。 语法表达：new RegExp(code is here); 例如：创建一个验证数字的正则表达式。 1234//注意：这里使用test()方法来检测是否符合var numReg = new RegExp('a');var num = 'a123';console.log(numReg.test(num)); // true; 直接量创建直接量就是直接赋值，创建一个表达式。这个看着更加简洁好用，非常灵活。 例如：还是上面那个例子。 123var numReg = /a/;var num = 'a123';console.log(numReg.test(num)); // true; 正则表达式的匹配规则字符类之前都是直接写正则表达式，例如/abc/,只是匹配任意一个符合abc的字符，而如果想要匹配多个字符，就可以使用字符类来实现。 字符类是使用方括号[]，中间可以随意写一些匹配规则。 例如：我们要检测文本中是否包含0-9中的任意数字，就可以使用字符类。这里我们使用直接量比较方便。 12345var numReg = /[0-9]/;var num = 'a123';var str = 'hello';console.log(numReg.test(num)); // true;console.log(numReg.test(str)); // false; 补充：其他字符类 序号 字符 说明 1 […] 括号内的任意字符 2 [^…] 不再括号内的任意字符 3 .] 除换行符和Unicode行终止符之外的任意字符 4 \\w 任何ASCII(注释1)单字字符，等于[a-zA-Z0-9_] 5 \\W 任何非ASCII(注释1)单字字符，等于[^a-zA-Z0-9_] 6 \\s 任何Unicode空白符 7 \\S 任何非Unicode空白符的字符 8 \\d 任何ASCII数字，等于[0-9] 9 \\D 任何非ASCII数字，等于[^0-9] 10 [\\b] 退格直接量(特殊) 注释1：ASCII指的是美国信息交换标准代码。 以上就是一些字符类的说明，下面使用几个练习一下。 例如：一个检测是否包含数字、字母和下划线以及非空白符的正则表达式。 123var patten = /\\w\\s/;var str = 'abc 123';console.log(patten.test(str)); // true 避免重复定义上面的字符类，只能匹配单个，如果我们要匹配多个符合的字符，不能一直重复写吧，像这样/\\d\\d\\d/,那这样就不高效了。 为了解决上面的烦恼，正则表达式用一些方法来表示这种情况，下面是一些列表。 序号 字符 说明 1 {n,m} 表示匹配前一项至少n次，不能超过m次 2 {n,} 表示匹配前一项n次，或者更多次 3 {n} 表示匹配前一项正好n次 4 ? 表示匹配前一项0次或者1次，等于{0,1} 5 + 表示匹配前一项1次或者多次，等于{1,} 6 * 表示匹配前一项0次或者多次，等于{0,} 举个例子：匹配2到4位数字。 123var numReg = /\\d&#123;2,4&#125;/;var num = '123';console.log(numReg.test(num)); // true; 用于选择的字符正则表达式中有用于选择的字符|。这个是从左到右进行匹配，一旦左边符合就返回结果。 例如:匹配是带有ab或者cd或者ef的正则表达式。 123var numReg = /ab|cd|ef/;var num = 'ab123';console.log(numReg.test(num)); // true; 用于分组的字符正则表达式中有用于分组的字符()。 知识点：正则中括号的含义 把单独的项目组合成子表达式，例如：/java(script)?/匹配的是字符串java,后面可以有script，也可以没有。 在完整的模式中定义子模式,例如：/[a-z]+(\\d+)/,匹配的是尾部是否是数字。 例如:匹配是带有ab或者cd或者ef的正则表达式。 123var numReg = /ab|cd|ef/;var num = 'ab123';console.log(numReg.test(num)); // true; 用于引用的字符括号()也可以表示引用，允许在同一个正则表达式中的后面部分引用前面的子表达式。 例如：开始和结束的引号相匹配。\\1引用的是第一个带括号的子表达式。 12var quoat = /(['\"])[^'\"]*\\1/;console.log(quoat.test('1\"2\"3')); // true 补充：正则表达式的选择、分组和引用字符 序号 字符 说明 1 竖杠 选择，匹配的是该符号左边或者右边的子表达式 2 (…) 分组，组合，将一个项目组合成一个独立的单元，还可以供后面的引用使用 3 (?:…) 只组合，把项目组合到一个单元，但是不记与该组匹配的字符 4 \\n 和第n个分组第一次匹配的字符相匹配 匹配指定的位置先来看一个列表，里面罗列了需要用到的锚字符。 序号 字符 说明 1 ^ 匹配字符串的开头；如果是匹配多行，那就是匹配一行的开头 2 $ 匹配字符串的结尾；如果是匹配多行，那就是匹配一行的结尾 3 \\b 匹配一个词语的边界，例如在\\w和\\W之间的位置，注意：\\b是退格符 4 \\B 匹配一个非词语的边界 5 (?=p) 正前向声明，要求接下来的字符都有和模式p匹配，但是不包括匹配中的那些字符 6 (?!p) 反前向声明，要求接下来的字符都不和模式p匹配 例如：匹配一个用户名，以字母开头，数字结尾的正则表达式。 123var nameReg = /^[a-zA-Z]\\d$/;var name = 'a1';console.log(111,nameReg.test(name)); // true; 标志正则表达式的标志说明了高级模式里面匹配的规则。和上面的正则表达式的语法不同的是标志出现在/符合之外说明的，位于第二个\\之后。 正则表达式中的标志列表 序号 字符 说明 1 g 模式匹配应该是全局的，应该找出被检索字符串所有的匹配。 2 i 模式匹配应该是不区分大小写的匹配。 3 m 多行模式，^匹配一行的开头和字符串的开头，$匹配一行的结尾和字符串的结尾 例如：匹配全局的a 123var patten = /a/g;var str = 'an apple';console.log(patten.test(str)); // true String模式匹配的方法search()方法这个方法的参数是正则表达式，返回一个与之匹配的子串的位置；如果找不到就返回-1，如果参数不是正则表达式，会转换成正则表达式进行匹配。 注意：该方法不支持全局检索，只要找到便会返回结果。 例如：匹配一个查找a的位置的正则表达式。 123var patten = /a/i;var str = 'apple';console.log(str.search(patten)); // 0 replace()方法这个方法的第一个参数是正则表达式，第二个参数是要替换的字符串，也可以是一个函数。用于把匹配到的字符串替换成别的内容。 例如：把小写字母a替换成大写字母*。 123var patten = /a/g;var str = 'apple';console.log(str.replace(patten,\"*\")); // *pple match()方法这个是比较常用的String正则表达式方法，参数只有一个就是正则表达式。把匹配到的内容以数组的形式返回。 例如：解析一个url地址 123var urlReg = /(\\w+):\\/\\/([\\w.]+)\\/(\\S*)\\/(\\d*)/;var text = 'http://www.abc.com/post/1';console.log(text.match(urlReg)); // [\"http://www.abc.com/post/1\", \"http\", \"www.abc.com\", \"post\", \"1\", index: 0, input: \"http://www.abc.com/post/1\", groups: undefined] split()方法这个也是比较常用的String正则表达式方法，参数只有一个就是正则表达式或者一个字符。把字符串分解为一个子串数组，使用的分隔符就是它的参数。 例如： 12345var patten = /\\s/;var num = '123,456,789';var num1 = '123 456 789';console.log(num.split(',')); // [\"123\", \"456\", \"789\"]console.log(num1.split(patten)); // [\"123\", \"456\", \"789\"] RegExp对象的属性和方法Javascript中的正则表达式是用RegExp对象来表示的，除了构造函数RegExp()，这个对象可以接受两个参数，一个是正则表达式的字符串，另一个是正则表达式的标志。 例如：new RegExp(&quot;\\\\d{2}&quot;,&quot;g&quot;); RegExp对象的属性每个RegExp对象都有五个属性。包括以下： source是一个只读字符串，存放的是正则表达式的文本。 global是一个只读的布尔值，是否具有标志g ignoreCase是一个只读的布尔值，是否具有标志i multiline是一个只读的布尔值，是否具有标志m lastIndex是一个可读写的整数。对于具有标志g的模式，这个属性存储在字符串中下一次可以检索的位置，由方法exec()和test()使用 exec()方法该方法是对于一个指定的字符串进行匹配，把匹配到的内容返回一个的数组。 例如： 123var patten = /a/i;var str = 'apple';console.log(patten.exec(str)); // [\"a\", index: 0, input: \"apple\", groups: undefined] test()方法该方法和exec()方法类似，但是不只限于字符串，其他字符也支持；而且它返回的是一个布尔值，表示是否符合正则表达式的匹配规则。 123var patten = /a/i;var str = 'apple';console.log(patten.test(str)); // true 案例### 检验用户名为中文的 /^[\\u4e00-\\u9fa5]{0,}$/ 检验密码强度/^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$/ 密码的强度必须是包含大小写字母和数字的组合不能使用特殊字符,长度在8-10之间 检测电子邮箱地址/[\\\\w!#$%&amp;&#39;*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;’+/=?^_`{|}~-]+)@(?:\\w?\\.)+\\w?/` 检测手机号的/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\\\d{8}$/ 检测身份证的15位的:/^[1-9]\\\\d{7}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}$/ 18位的:/^[1-9]\\\\d{5}[1-9]\\\\d{3}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}([0-9]|X)$/ 检验金额的精确到2位小数。 /^[0-9]+(.[0-9]{2})?$/ 判断ie版本/^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$/ 校验IP-v4地址/\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b/ 提取url链接/^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&amp;=]*)?/ 写在最后这个JavaScript中的正则表达式RegExp对象就讲到到这里，内容还是挺多的，需要慢慢吸收转化，可以多几个例子练习。","categories":[{"name":"js","slug":"js","permalink":"https://gitguanqi.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gitguanqi.github.io/tags/js/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://gitguanqi.github.io/tags/正则表达式/"}]},{"title":"js获取url地址的参数的方法","slug":"js-url-params","date":"2019-01-23T13:36:21.000Z","updated":"2019-01-24T10:01:25.711Z","comments":true,"path":"2019-01-23/js-url-params/","link":"","permalink":"https://gitguanqi.github.io/2019-01-23/js-url-params/","excerpt":"","text":"今天说一下如何获取url参数值。 思路 通过location的search就可以获取到url中问号后面的值。 字符串过滤到问号 通过split方法分割参数集合 循环赋值 匹配对应的参数值 返回值 封装的方法1234567891011121314151617181920212223242526272829function getUrlParams(name) &#123; // 不传name返回所有值，否则返回对应值 var url = window.location.search; if (url.indexOf('?') == 1) &#123; return false; &#125; url = url.substr(1); url = url.split('&amp;'); var name = name || ''; var nameres; // 获取全部参数及其值 for(var i=0;i&lt;url.length;i++) &#123; var info = url[i].split('='); var obj = &#123;&#125;; obj[info[0]] = decodeURI(info[1]); url[i] = obj; &#125; // 如果传入一个参数名称，就匹配其值 if (name) &#123; for(var i=0;i&lt;url.length;i++) &#123; for (const key in url[i]) &#123; if (key == name) &#123; nameres = url[i][key]; &#125; &#125; &#125; &#125; else &#123; nameres = url; &#125; // 返回结果 return nameres;&#125; 实例例如： 12345const url = 'http://www.abc.com/test.php?id=1&amp;from=index';var res = getUrlParams();var res1 = getUrlParams('id');console.log(res); // [&#123;id: \"1\"&#125;, &#123;from: \"index\"&#125;]console.log(res1); // 1 写在最后这是一个比较简单的方法。","categories":[{"name":"js","slug":"js","permalink":"https://gitguanqi.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gitguanqi.github.io/tags/js/"},{"name":"url","slug":"url","permalink":"https://gitguanqi.github.io/tags/url/"}]},{"title":"es6之const命令","slug":"es6-const","date":"2019-01-23T13:31:21.000Z","updated":"2019-01-23T13:18:51.546Z","comments":true,"path":"2019-01-23/es6-const/","link":"","permalink":"https://gitguanqi.github.io/2019-01-23/es6-const/","excerpt":"","text":"hi,我又回来了，今天学习一下const命令。 声明一个常量const声明一个只读常量，一旦声明，常量的值便不可改变。 例子如下： 12const food = 12;food = 23; // Uncaught TypeError: Assignment to constant variable. 还可以声明一个变量const可以声明一个变量，声明以后，必须初始化，否则变错。 例子如下： 1const food; // Uncaught SyntaxError: Missing initializer in const declaration 其他特性const和let有许多相似点： 只在其声明的块级作用域中有效； 不存在作用域提升，是暂时性死区，必须先声明，后使用； 不能重复声明，否则会报错 例子如下： 1234567891011121314151617//1.只在其声明的块级作用域中有效&#123; const food = 'apple';&#125;console.log(food); // Uncaught ReferenceError: food is not defined//2.暂时性死区&#123; console.log(HI); // Uncaught ReferenceError: HI is not defined const HI = 'hello';&#125;//3.不能重复声明&#123; const food = 'apple'; const food = 'orange'; // Uncaught SyntaxError: Identifier 'food' has already been declared&#125; const的声明变量的本质const声明的变量，并不是说变量的值不能改变，而是对于变量指向那个的内存地址所保存的数据不得改动。 如果声明的变量是基本数据，那值就保存在变量指向的那个内存地址，可以理解为对于常量。 但是如果声明的变量是一个引用数据类型，那只能保证变量保存的指针地址不变，至于变量里面的属性和值，就不能保证了。 注意：如果把这个声明的引用数据类型变量指向另一个对象，就会报错。 例如： 12345678910111213// 常量是一个对象const About = &#123;&#125;;About.us = 'usb';About.ua = 'usc';console.log(About); // &#123;us: \"usb\", ua: \"usc\"&#125;About = &#123;&#125;; // Uncaught TypeError: Assignment to constant variable.//常量是一个数组const BALL = [];BALL.length = 2;BALL[0] = 'haha';BALL = []; // Uncaught TypeError: Assignment to constant variable. 补充：声明变量的方法 ES5的var和function命令。 ES6的let和const命令。 最后总结其实，const也不是很难，只要你细心，就会发现非常的简单。","categories":[{"name":"es6","slug":"es6","permalink":"https://gitguanqi.github.io/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://gitguanqi.github.io/tags/es6/"},{"name":"const","slug":"const","permalink":"https://gitguanqi.github.io/tags/const/"}]},{"title":"es6之块级作用域","slug":"es6-block","date":"2019-01-23T13:30:21.000Z","updated":"2019-01-23T13:16:19.050Z","comments":true,"path":"2019-01-23/es6-block/","link":"","permalink":"https://gitguanqi.github.io/2019-01-23/es6-block/","excerpt":"","text":"今天，来探讨一下ES6中的块级作用域。 全局作用域和函数作用域在ES5中，只全局作用域和函数作用域。这会导致函数作用域覆盖了全局作用域；亦或者循环中的变量泄露为全局变量。 例如： 123456789101112131415// 1.函数作用域覆盖了全局作用域,发生了变量提升，函数声明大于var声明的变量，因此函数里面的a提到了前面，在打印a，初始化一个undefined给a,所以打印出了undefined。var a = '1';function fn() &#123; console.log(a); if (3&lt;2) &#123; var a = 3; &#125;&#125;fn(); // undefined// 2.循环中的变量泄露为全局变量for(var i=0;i&lt;5;i++) &#123; console.log(i);&#125;console.log(i); // 5; ES6的块级作用域用let命令新增了块级作用域，外层作用域无法获取到内层作用域，非常安全明了。即使外层和内层都使用相同变量名，也都互不干扰。 1234567891011121314151617181920212223242526272829303132333435// 1.外层作用域无法获取到内层作用域function fn1() &#123; let a = 41; if(1 == 1) &#123; let a = 3; console.log(2,a); // 2 3 &#125; console.log(1,a); // 1 41&#125;fn1();&#123; &#123; let food = 'apple'; &#125; console.log(food); // Uncaught ReferenceError: food is not defined&#125;&#123; &#123; let food = 'apple'; &#125; console.log(food); // Uncaught ReferenceError: food is not defined&#125;// 2. 外层和内层都使用相同变量名，也都互不干扰&#123; &#123; let food = 'apple'; console.log(food); // apple &#125; let food = 'orange'; console.log(food); // orange&#125; 块级作用域和和函数声明在ES5中，函数只能在顶级作用域和函数作用域中声明，不能在块级作用域中声明。但是在ES6中，函数可以在块级作用域中声明。 但是会有一定的问题，因为函数声明会被提到代码的最前面。所以会报错，最好在ES6中用函数表达式来表示一个函数。 例如： 123456789101112131415161718//1.函数声明报错&#123; if (4 &lt; 2) &#123; function fn() &#123; console.log('我在函数里面！'); &#125; &#125;&#125;fn(); // Uncaught TypeError: fn is not a function//2.函数表达式没错&#123; let fa = '111'; let fn = function () &#123; console.log('我在函数里面！'); &#125; console.log(fa,fn); // 111 ƒ () &#123; console.log('我在函数里面！');&#125;&#125; 注意：ES6中允许函数在块级作用域中可以声明的条件是必须在大括号里面，否则就会报错。 12345678// 1.报错的情况if (4&gt;2) &#123; let fn = function () &#123;&#125;;&#125;//2.报错的情况if (4&gt;2) let fn = function () &#123;&#125;; // Uncaught SyntaxError: Lexical declaration cannot appear in a single-statement context 最后总结今天就将这些，下次再会。期待再更新。","categories":[{"name":"es6","slug":"es6","permalink":"https://gitguanqi.github.io/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://gitguanqi.github.io/tags/es6/"},{"name":"块级作用域","slug":"块级作用域","permalink":"https://gitguanqi.github.io/tags/块级作用域/"}]},{"title":"es6之set命令","slug":"es6-set","date":"2019-01-22T10:30:21.000Z","updated":"2019-01-23T13:20:42.569Z","comments":true,"path":"2019-01-22/es6-set/","link":"","permalink":"https://gitguanqi.github.io/2019-01-22/es6-set/","excerpt":"","text":"学习setset是ES6中的新增的数据结构，是一种构造函数，类似于数组，但是里面的元素都是唯一的，不重复的。 例如： 12345const set = new Set();[1,2,3,4,5,2,1,2,1,2].forEach( x =&gt; set.add(x) );for(let i of set) &#123; console.log(i); // 1 2 3 4 5&#125; set的属性set的属性包括constructor（set原型）和size（用来记录set的大小）。 用法：Set.prototype.constructor,Set.prototype.size。 例如： 123let set = new Set([1,2,3,2,2,2,1,2,34,4,45,523]);console.log(set.constructor); // ƒ Set() &#123; [native code] &#125;console.log(set.size); // 7 set的方法set的操作方法 add(val); 添加某个值 delete(val); // 删除某个值，返回布尔值，表示结果。 has(val); // 判断该值是否存在于Set中。 clear(); // 清楚所有的值 例如： 123456789101112let set = new Set();//1.add();set.add(12).add(32);console.log(set); // Set(2) &#123;12, 32&#125;// 2.delete(val);set.delete(32);console.log(set); // Set(1) &#123;12&#125;//3.has(val);console.log(set.has(88)); // false//4.clear();set.clear();console.log(set); // Set(0) &#123;&#125; set的遍历方法set的键和值是同一个值。 keys() 返回键名的方法 values() 返回键值的方法 entries() 返回键值对的方法 forEach() 用回调函数遍历各个元素的方法 例如： 123456789101112131415let set = new Set([2,2,2,1,5,34,45,33,23,32]);for(let item of set.keys()) &#123; console.log(item); // // 2 1 5 34 45 33 23 32&#125;for(let item of set.values()) &#123; console.log(item); // // 2 1 5 34 45 33 23 32&#125;for(let item of set.entries()) &#123; console.log(item); // [2, 2] [1, 1] [5, 5] [34, 34] [45, 45] [33, 33] [23, 23] [32, 32]&#125;set.forEach((value,key) =&gt; console.log(key+ '=' +value)); // 2=2 1=1 5=5 34=34 45=45 33=33 23=23 32=32 应用...运算符和Array.from以及map和filter都可以遍历set结构。 ...运算符例如： 12let set = new Set('123456654321');console.log([...set]); // [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"] ...和数组加起来可以去重 例如： 123let arr = [1,2,3,4,6,3,3,1,3,4];let removeRepeat = [...new Set(arr)];console.log(removeRepeat); //[1, 2, 3, 4, 6] map方法例如： 12let set = new Set([1,2,3,4]);console.log(new Set([...set].map(x =&gt; x*2))); // &#123;2, 4, 6, 8&#125; filter方法例如： 12let set = new Set([1,2,3,4]);console.log(new Set([...set].filter(x =&gt; x%2 === 0))); // &#123;2, 4&#125; Array.from例如： 12let set = new Set([1,2,3,4]);console.log(new Set(Array.from(set, x =&gt; x*2))); // &#123;2, 4, 6, 8&#125; 小案例使用这个set可以实现数学中的交集，并集效果。 例如： 12345678let a = new Set([1,2,3]);let b = new Set([3,4,5]);let numa = new Set([...a,...b]);console.log(numa); // &#123;1, 2, 3, 4, 5&#125;//并集let numb = new Set([...a].filter(x =&gt; b.has(x)));console.log(numb); // &#123;3&#125; 学习WeakSetWeakSet和Set类似，也是没有重复的值。注意的是，它里面的成员只能是对象，其他数据类型不接受。 例如： 123456let ws = new WeakSet(1); // Uncaught TypeError: number 1 is not iterable (cannot read property Symbol(Symbol.iterator))let wsa = new WeakSet('1'); // Uncaught TypeError: Invalid value used in weak setlet wsb = new WeakSet(&#123;x:1&#125;); // Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))let wsc = new WeakSet([1,3]); // Uncaught TypeError: Invalid value used in weak setlet wsc = new WeakSet([[1,2],[3,4]]);console.log(wsc); // WeakSet &#123;Array(2), Array(2)&#125; 结论：从上面的例子中，可以看出1.WeakSet构造函数的参数不接受字符串，数字，普通对象，数组（数组中的参数必须是对象）；接受数组（数组中的参数是对象的数组）。 WeakSet的方法 WeakSet.prototype.add(val)添加一个值; WeakSet.prototype.delete(val)删除一个值; WeakSet.prototype.has(val)是否有这个值; 例如： 1234567891011let wset = new WeakSet([[1,3,4],[23,4,52,2]]);//1.添加值wset.add([12,33,23]);console.log(wset); // WeakSet &#123;Array(3), Array(4), Array(3)&#125;//2.删除值wset.delete([12,33,23]);console.log(wset); // WeakSet &#123;Array(4), Array(3)&#125;//3.是否有这个值console.log(wset.has([12,33,23])); // false WeakSet的属性由于WeakSet中的值都是弱属性，随时可能消失，被垃圾回收，遍历机制无法保证值是否还存在，所以不能用size和forEach()。 例如： 12345let wset = new WeakSet([[1,3,4],[23,4,52,2]]);console.log(wset.size); // undefinedfor(let i=0;i&lt;wset.length;i++) &#123; console.log(wset[i]);&#125; 写在最后Set和WeakSet就介绍到这里，赶快用起来吧！","categories":[{"name":"es6","slug":"es6","permalink":"https://gitguanqi.github.io/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://gitguanqi.github.io/tags/es6/"},{"name":"set","slug":"set","permalink":"https://gitguanqi.github.io/tags/set/"}]},{"title":"es6之let命令","slug":"es6-let","date":"2019-01-19T09:30:21.000Z","updated":"2019-01-19T09:43:28.003Z","comments":true,"path":"2019-01-19/es6-let/","link":"","permalink":"https://gitguanqi.github.io/2019-01-19/es6-let/","excerpt":"","text":"let let命令的用法let是es6中的声明一个变量的命令，只在它声明的代码块中有效，出了这个代码块就会报错。也非常适合for循环，在循环中i的值只在循环语句中生效，在外边取不到的。 var命令声明的是一个全局的变量，i是指向全局的变量，只会输出最后的值。而let只在循环语句块里面生效，每次循环都会重新声明一个i的，所以每次循环都能拿到对应的值。 for循环的变量是父作用域，和在循环体内let定义的变量（子作用域）不在同一个作用域。 例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//1.在自身所在代码块中有效&#123; let a = 1; var b = 2;&#125;console.log(b); // 2console.log(a); // a is not defined//2.在for循环语句块中有效for(var i=0;i&lt;10;i++) &#123; //...&#125;console.log(i); // 10for(let j=0;j&lt;10;j++) &#123; //...&#125;console.log(j); // j is not definedvar arr = [];for(var a=0;a&lt;10;a++) &#123; arr[a] = function () &#123; console.log(a); &#125;&#125;console.log(a[4]); // 10for(let b=0;b&lt;10;b++) &#123; arr[b] = function () &#123; console.log(b); &#125;&#125;console.log(b[4]); // 4// 3.for循环的变量和循环体内的变量for(var i=0;i&lt;10;i++) &#123; let i = 'fed'; console.log(i);&#125;/** 结果是* fed* fed* fed*/ let命令不存在作用域提升var命令是会发生作用域提升的，在声明之前，是undefined,未声明便有默认值了。而let定义的变量必须在声明后使用。 12345console.log(fa); // undefinedvar fa = 1;console.log(fb); // fb is not definedlet fb = 2; let存在暂时性死区“暂时性死区”（temporal dead zone，简称 TDZ）是指在ES6的规定中，如果区块中存在let和const命令的，这两个命令声明的变量就已经形成了封闭作用域。在此之前声明的变量，都会报错。 例如：下面声明了一个全局变量，但是在块级作用域中let又声明了一个变量。 12345678var food = 'apple';if(typeof 'str' == 'string') &#123; food = 'banana'; // Uncaught ReferenceError: food is not defined let food; console.log(food); // undefined food = 'orange'; console.log(food); // orange&#125; 注意：暂时性四区会有一些不好的地方。 typeof检测不安全 12typeof x; // Uncaught ReferenceError: x is not definedlet x; 不允许重复声明简而言之，就是不允许在同一作用域内，声明两个一样的变量。 例如： 123456789&#123; let a = 1; var a = 2; // Uncaught SyntaxError: Identifier 'a' has already been declared&#125;// 或者&#123; let b = 1; let b = 2; // Uncaught SyntaxError: Identifier 'b' has already been declared&#125; 注意：不能在函数参数内重复声明参数，否则报错。 12345function wait(x,y) &#123; let x = 1; // Uncaught SyntaxError: Identifier 'x' has already been declared let y = 2; // Uncaught SyntaxError: Identifier 'y' has already been declared&#125;wait(3,5); 顶层对象在ES6之前，顶级对象的属性和全局变量是一致的，所以导致出现很多问题。 只有运行开才能捕捉到错误，没法一开始就检测出错误。 顶层对象是随时随地可以读取和写入的，所以不利于模块化编程。 window其实指的是游览器窗口，顶层对象有一个实体含义。 所以es6改进了一点，就是let，const声明的全局变量不属于顶层对象的属性。 例如： 1234var a = 1;let b = 2;console.log(window.a); // 1console.log(window.b); // undefined 学以致用let命令古语有云：学了就用处处行，不学不用等于零。所以我写了一个关于let的小例子。 这是一个选项卡的案例，在之前，我们还要定义btns[i].index = i,而现在用let命令就方便多了。 12345678910111213141516171819202122232425262728293031.tab &#123; width: 300px; height: 30px; border: 1px solid #fff;&#125;.tab &gt; span &#123; float: left; display: block; width: 98px; height: 28px; line-height: 28px; text-align: center; border: 1px solid #aaa; cursor: pointer;&#125;span.active &#123; color: #fff; background-color: #f00; border: 1px solid #f00;&#125;.content, .content &gt; p &#123; width: 300px; height: 300px;&#125;.content &gt; p &#123; display: none; border: 1px solid #aaa;&#125;p.active &#123; display: block;&#125; 12345678910&lt;div class=\"tab\"&gt; &lt;span class=\"active\"&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=\"content\"&gt; &lt;p class=\"active\"&gt;1的内容&lt;/p&gt; &lt;p&gt;2的内容&lt;/p&gt; &lt;p&gt;3的内容&lt;/p&gt;&lt;/div&gt; 123456789101112let btns = document.querySelectorAll('.tab span');let contents = document.querySelectorAll('.content p');for (let i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function() &#123; for (let j = 0; j &lt; btns.length; j++) &#123; btns[j].className = ''; contents[j].className = ''; &#125; this.className = 'active'; contents[i].className = 'active'; &#125;&#125; 写在最后上面就是一些介绍如何正确的使用let命令，在实践中用起来吧。","categories":[{"name":"es6","slug":"es6","permalink":"https://gitguanqi.github.io/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://gitguanqi.github.io/tags/es6/"},{"name":"let","slug":"let","permalink":"https://gitguanqi.github.io/tags/let/"}]},{"title":"ajax技术详解","slug":"js-ajax","date":"2019-01-18T13:16:21.000Z","updated":"2019-01-24T10:01:39.239Z","comments":true,"path":"2019-01-18/js-ajax/","link":"","permalink":"https://gitguanqi.github.io/2019-01-18/js-ajax/","excerpt":"","text":"今天来讲一下ajax的有关知识点。 ajax概念ajax全称叫Asynchronous JavaScript and XML,意思是异步的 JavaScript 和 XML。 ajax是现有标准的一种新方法，不是编程语言，可以在不刷新网页的情况下，和服务器交换数据并且更新部分页面内容，不需要任何插件，只需要游览器允许运行JavaScript就可以。 而传统的网页（不使用ajax的）如果需要更新页面内容，就需要重新请求服务器，返回网页内容，重新渲染刷新页面。 ajax的原理原理：ajax的运行过程包括以下几个方面 Browser游览器通过事件触发方法，本地通过XMLHttpRequest对象，创建并且发送请求通过互联网到服务器； Server服务器收到请求的内容，响应请求，发送所需数据到游览器； Browser游览器通过XMLHttpRequest对象的onreadystatechange的方法收到请求的数据后，解析和渲染数据到页面中。 注意：ajax依赖的标准有以下几个 XMLHttpRequest对象,异步的与服务器交换数据 JavaScript/DOM,信息显示/交互 XML,作为转换数据的格式 XMLHttpRequest的使用创建XMLHttpRequest对象，通过new实例化一个XMLHttpRequest对象。 1var xhr = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP'); // 兼容ie和Firefox，google chrome,opera,safari 发送请求使用XMLHttpRequest对象的open和send方法 open方法使用open(method,url,async),接受三个参数。 第一个是method请求的类型，如：get和post; 第二个是url请求地址，即文件在服务器的位置； 第三个是是否处理异步处理请求,值为true和false； 例如： 1xhr.open('get','https://www.abc.com/service.php?tamp='+Date.parse(new Date()),true); send方法使用send(string)接受的参数为请求类型为post传递的值，为get类型时候不传值。 例如： 1send('tamp='+Date.parse(new Date()); onreadystatechange事件当readyState属性发生变化时，就会触发onreadystatechange事件，该事件通过回调函数获取到响应的数据信息。 readyState值: 值为0表示：请求未初始化； 值为1表示：服务器连接已建立； 值为2表示：请求已接收； 值为3表示：请求处理中； 值为4表示:请求已完成，且响应已就绪； status值： 200: 请求成功 404: 未找到页面 简单的get请求。12345678910111213var xhr;if (!xhr &amp;&amp; typeof xhr !== 'object') &#123; var xhr = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP');&#125;xhr.open('get','https://www.abc.com/service.php?tamp='+Date.parse(new Date()),true);xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; console.log(xhr.responseText); &#125; &#125;&#125;xhr.send(); 模拟数据模拟的JSON数据123456789101112131415161718192021// 保存为data.json文件&#123; \"msg\": \"get_succ\", \"code\": 201, \"data\": &#123; \"list\": [ &#123; \"id\":1, \"name\": \"alun\" &#125;, &#123; \"id\":2, \"name\": \"mark\" &#125;, &#123; \"id\":3, \"name\": \"jean\" &#125; ] &#125;&#125; 模拟的Nodejs的api 请确保你的系统安装有node.js环境。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 保存为node.js文件// 引入http模块const http = require('http');const port = 3000;const success = &#123; msg: \"get_succ\", code: 201, data: &#123; list: [ &#123;\"id\":1,\"name\": \"alun\"&#125;, &#123;\"id\":2,\"name\": \"mark\"&#125;, &#123;\"id\":3,\"name\": \"jean\"&#125; ] &#125;&#125;const error = &#123; msg: \"get_fail\", code: 101, data: &#123; info: 'this request failed,again try!' &#125;&#125;const authy = &#123; msg: \"no visited!\", code: 403, data: &#123; info: 'not visited!' &#125;&#125;// 建立http服务const serve = http.createServer((req,res) =&gt; &#123; var lawDomainList = \"http://localhost:9925\"; res.setHeader('Content-Type', 'text/plain;charset=utf8'); res.setHeader(\"Access-Control-Allow-Origin\",lawDomainList); if (req.url == '/api') &#123; res.end(JSON.stringify(success)); &#125; else &#123; res.end(JSON.stringify(error)); &#125; res.end(authy);&#125;)// 监听端口serve.listen(port,function()&#123; console.log('serve is running on port 3000!');&#125;) 封装的ajax函数1234567891011121314151617181920212223242526272829303132333435363738394041// 保存为ajax.js文件$g = &#123; get: function(url) &#123; return new Promise(function(resolve,reject) &#123; if (!url &amp;&amp; !(typeof url == 'string')) &#123; throw new Error('SysantaxError: this get request must had url!'); &#125; var xhr = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP'); xhr.open('GET',url,true); xhr.onreadystatechange = function() &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(this.responseText,this); &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send(); &#125;) &#125;, post: function(url,data) &#123; return new Promise(function(resolve,reject) &#123; if (!url) &#123; throw new Error('SysantaxError: this post request must had url!'); &#125; if (!data) &#123; throw new Error('SysantaxError: this post request must had data!'); &#125; var xhr = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP'); xhr.open('POST',url,true); xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); xhr.onreadystatechange = function() &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(this.responseText,this); &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send(JSON.stringify(data)); &#125;) &#125;&#125; 示例：获取数据渲染页面 通过点击按钮获取数据，渲染列表。 123&lt;button class=\"btn\"&gt;请求数据&lt;/button&gt;&lt;ul class=\"res\"&gt;结果：暂无结果&lt;/ul&gt;&lt;script src=\"ajax.js\"&gt;&lt;/script&gt; 123456789101112131415161718192021let btn = document.querySelector('.btn');let resbox = document.querySelector('.res');btn.onclick = function() &#123; var url = 'http://localhost:3000/api'; // node api var urlJson = 'data.json'; // mock api $g.get(url).then(function(res) &#123; if (typeof res == 'string') &#123; let responTxt = JSON.parse(res); if (responTxt.msg == 'get_succ' &amp;&amp; responTxt.code == 201) &#123; let list = responTxt.data.list; let str = ''; for (let i=0;i&lt;list.length;i++) &#123; str += '&lt;li&gt;'+ list[i].id + ':' + list[i].name + '&lt;/li&gt;'; &#125; resbox.innerHTML = str; &#125; &#125; &#125;).catch(function(err)&#123; throw new Error(err); &#125;);&#125; 写在最后这只是我总结的一小部分知识点，其实这个技术还是有很多地方没有说到，以后再补充吧！","categories":[{"name":"js","slug":"js","permalink":"https://gitguanqi.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gitguanqi.github.io/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"https://gitguanqi.github.io/tags/ajax/"}]},{"title":"案例列表","slug":"example-list","date":"2019-01-16T13:30:21.000Z","updated":"2019-01-16T14:18:46.769Z","comments":true,"path":"2019-01-16/example-list/","link":"","permalink":"https://gitguanqi.github.io/2019-01-16/example-list/","excerpt":"","text":"之前我做了许多的案例，包括当当网pc、哔哩哔哩h5，今天介绍这两个案例。 当当网pc 当当网pc 当当网是初学前端时候做的一个案例，这个案例包括登录，注册，首页，二级页，详情页，购物车页面这几个部分。 你可以先注册，然后登录，到首页看看，二级页看看，再到详情页添加商品到购物车（有待完善），最后在购物车结算。 建议在电脑上游览，点击这里预览一下效果吧！ 哔哩哔哩h5 哔哩哔哩h5 当当网是初学前端时候做的一个案例，这个案例包括登录，注册，首页，二级页，详情页，搜索页页面这几个部分。 你可以看频道内容，也可以看排行榜，还可以登录，注册（完善中），也可以看详情页视频。 建议在手机上游览，点击这里预览一下效果吧！","categories":[{"name":"案例","slug":"案例","permalink":"https://gitguanqi.github.io/categories/案例/"}],"tags":[{"name":"案例","slug":"案例","permalink":"https://gitguanqi.github.io/tags/案例/"}]},{"title":"js中对象详解","slug":"js-object-use","date":"2019-01-16T13:16:21.000Z","updated":"2019-01-24T10:01:35.102Z","comments":true,"path":"2019-01-16/js-object-use/","link":"","permalink":"https://gitguanqi.github.io/2019-01-16/js-object-use/","excerpt":"","text":"今天说一下有关对象操作方法的文章。 什么是对象？在js中数据类型分为两类，一个是基本数据类型，另一个是引用数据类型。基本数据类型包括文本字符串string、布尔boolean、数字number、未定义nudefined、空值null,而引用数据类型就是对象，包括普通的Object、数组Array、函数function、日期Date、正则表达式RegExp、字符串对象String、数字对象Number、布尔对象Boolean。今天要说的就是Object,普通的对象。 你可以把它当成一种无序的属性的集合，每个属性都有自己的名字和值，这个值可以是数组，也可以是对象，其他的也可以。 创建对象创建对象有很多种方法，今天介绍常见的几种方法。 直接量创建例如：12345var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;; 使用new运算符创建例如:1var obj = new Object(); 对象的属性对象有很多的的属性和属性的值，属性用.来表示。在.左边的是要访问其属性的对象的引用名，它不能是字符串或者是表达式；在.右边的是属性名。 定义一个对象直接量定义简单方便，直接在一个花括号里面写属性和值，属性之间用逗号隔开。 例如：1234567var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;var name = obj.name;console.log(name); // 'guan' 增加一个对象的属性和值直接在对象里面添加属性即可，或者使用.定义一个新的属性值。 例如：直接拿上面的示例。 1234567var obj = &#123; name: 'guan', age: 21, sex: 'man', address: '浙江杭州'&#125;;obj.telephone = '0571-12340001'; 修改一个对象的属性和值使用.可以改变一个新的属性值。 例如：直接拿上面的示例。 123456var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;obj.name = 'mark'; 循环对象的属性和值在js中,使用for/in方法可以遍历对象的属性和属性值。 例如： 123456789var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;for (var key in obj) &#123; console.log(key + '=' + obj[key]); //name=guan age=21 sex=man&#125; 检测对象的属性是否存在用in或者undefined判断，但是in运算符不常用，如果差不多会返回undefined。 12345678910111213141516var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;// 1. 用inif ('name' in obj) &#123; obj.name = 'lee'; //lee&#125;console.log(obj.name); //lee//2.用判断if (obj.name !== undefined) &#123; obj.name = 'lee';&#125;console.log(obj.name); //lee 删除对象的属性和属性值可以用delete运算符删除对象的属性，实际上是彻底从对象中删除这个属性，删除以后for/in方法和in运算符都不会找到该属性，如果打印该属性，会的到一个undefined。 例如： 12345678var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;delete obj.name;console.log(obj.name); //undefined 作为关联数组的对象在js中，数组是一种特殊的对象，所以也可以用对象来关联数组。 以下表示方法是相等的: 12object.propertyobject['property'] 例如： 123456789var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;var name = obj['name'];console.log(obj.name == name); //true Object的属性和方法在js中，所有的对象都继承自Object类，所以它们都有通用的方法和属性。 constructor属性在js中，每一个对象都有一个constructor属性,所以可以根据这个来检测某个数据是否属于对象。 例如：12345678910var arr = [1,2,3];console.log(arr.constructor == Array); //true//还可以这样判断function isArray(arr) &#123; if (typeof arr == 'object' &amp;&amp; arr.constructor == Array) &#123; console.log('arr is array'); &#125;&#125;isArray(arr); //arr is array instanceof运算符instanceof运算符可以检查constructor的值 因此上面可以写成。 例如：12345678910var arr = [1,2,3];console.log(arr instanceof == Array); //true//还可以这样判断function isArray(arr) &#123; if (typeof arr == 'object' &amp;&amp; arr instanceof Array) &#123; console.log('arr is array'); &#125;&#125;isArray(arr); //arr is array toString()方法这个方法没有参数，可以把对象转换为一个字符串。 例如： 123var obj = &#123;x:1,y:1&#125;;var str = obj.toString();console.log(str); // [object Object] toLocaleString()方法这个方法返回对象的一个本地化的字符串。 例如： 123var now = new Date();var str = now.toLocaleString();console.log(str); // 2019/1/16 下午9:45:55 hasOwnProperty()方法这个方法是检测对象的某个属性是否是自身的属性，而不是继承的属性。 例如：12345678var obj = &#123; name: 'guan', age: 21, sex: 'man'&#125;;console.log(obj.hasOwnProperty('name')); //trueconsole.log(obj.hasOwnProperty('address')); //false valueOf()方法这个方法把对象转化为某个基本数据类型，也就是一个数字，而不是字符串的时候才会调用的方法。 最后总结对象的使用方法就是这些，最常用也是最基本的属性和方法。","categories":[{"name":"js","slug":"js","permalink":"https://gitguanqi.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gitguanqi.github.io/tags/js/"},{"name":"对象","slug":"对象","permalink":"https://gitguanqi.github.io/tags/对象/"}]},{"title":"Demo列表","slug":"demo-list","date":"2019-01-16T02:30:21.000Z","updated":"2019-01-16T04:49:45.422Z","comments":true,"path":"2019-01-16/demo-list/","link":"","permalink":"https://gitguanqi.github.io/2019-01-16/demo-list/","excerpt":"","text":"小米首页 小米首页 这个demo是关于小米首页的，建议在pc上面查看，大家可以点击这个链接查看。 天猫首页 天猫首页 这个demo是关于天猫首页的，建议在pc上面查看，大家可以点击这个链接查看。 帅康首页 帅康首页 这个demo是关于帅康首页的，建议在pc上面查看，大家可以点击这个链接查看。 58首页 58首页 这个demo是关于58首页的，建议在手机上面查看，大家可以点击这个链接查看。 换肤 换肤 这个demo是关于换肤的，建议在pc上面查看，大家可以点击这个链接查看。 商品放大镜 商品放大镜 这个demo是关于商品放大镜的，建议在pc上面查看，大家可以点击这个链接查看。 时钟canvas 时钟 这个demo是关于时钟的，建议在pc上面查看，大家可以点击这个链接查看。 刮刮卡 刮刮卡 这个demo是关于刮刮卡的，建议在pc上面查看，大家可以点击这个链接查看。 妈妈的礼物 妈妈的礼物 这个demo是关于妈妈的礼物的，建议在pc上面查看，大家可以点击这个链接查看。 骰子 骰子 这个demo是关于骰子的，建议在pc上面查看，大家可以点击这个链接查看。 统计表 统计表 这个demo是关于统计表的，建议在pc上面查看，大家可以点击这个链接查看。 选项卡(tab切换) 选项卡 这个demo是关于选项卡的，建议在pc上面查看，大家可以点击这个链接查看。 banner(轮播图) banner 这个demo是关于banner的，建议在pc上面查看，大家可以点击这个链接查看。","categories":[{"name":"demo","slug":"demo","permalink":"https://gitguanqi.github.io/categories/demo/"}],"tags":[{"name":"demo","slug":"demo","permalink":"https://gitguanqi.github.io/tags/demo/"}]},{"title":"手机上查看pc上的网页","slug":"pcpage-on-mobile","date":"2019-01-13T09:51:21.000Z","updated":"2019-01-16T03:34:02.080Z","comments":true,"path":"2019-01-13/pcpage-on-mobile/","link":"","permalink":"https://gitguanqi.github.io/2019-01-13/pcpage-on-mobile/","excerpt":"","text":"导语：前两天我在电脑上做了一个h5网页，但是只能在谷歌游览器的模拟设备上面看效果，但是没有办法在真机上测试效果。这两天，我发现了一个非常快捷的方法，可以让你轻轻松松在手机上测试电脑上你做的h5网页效果。 目录 准备工具 连接步骤 写在最后 准备工具 一台电脑 一部手机 一个局域网(wifi) 连接步骤第一步：连接网络手机和电脑同时连接上同一个局域网或者wifi，具体过程我就不演示了，身在互联网应该都是基本常识。 注意：一定要同一个wifi网络，否则无法测试。 第二步：电脑操作 1.打开cmd，输入ipconfig，会出来一下内容。 ipconfig 2.打开游览器，在地址栏输入箭头所指的地址，我的是这个http://192.168.1.104，然后你会看到电脑上显示你刚刚做好的网页。 第三步：手机操作把这个地址可以在你的手机游览器里面输入，你就会看到和电脑同样内容的网页。 写在最后最后你就会成功的看到你的手机游览器上面显示着你做好的页面，是不是很神奇呢。这个解决了困扰大部分开发人员的问题，就是做好h5的网页，不能够在真机上面看到真实的效果，利用这个方法就可以非常完美的检验你的劳动成果了，是不是非常好用。","categories":[{"name":"网页技巧","slug":"网页技巧","permalink":"https://gitguanqi.github.io/categories/网页技巧/"}],"tags":[{"name":"网页技巧","slug":"网页技巧","permalink":"https://gitguanqi.github.io/tags/网页技巧/"}]},{"title":"js中数组的操作方法","slug":"js-array-use","date":"2019-01-06T13:16:21.000Z","updated":"2019-01-24T10:01:36.304Z","comments":true,"path":"2019-01-06/js-array-use/","link":"","permalink":"https://gitguanqi.github.io/2019-01-06/js-array-use/","excerpt":"","text":"今天给大家带来一篇有关数组操作方法的文章。 新建数组 方法一：通过new运算符创建一个数组构造函数。 1var arr = new Array(); 方法二：通过方括号直接创建直接量数组。 1var arr = [1,2,3]; 添加数组中的元素 方法一：通过下标添加元素。 123var arr = new Array();arr[0] = 'kwan';arr[1] = 18; 方法二：通过array的push方法来添加。 说明一点：push是往数组末尾添加新元素。 12345var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;arr.push(4); // result is [5,1,2,3,4]; 方法三：通过array的unshift方法来添加。 说明一点：unshift是网数组最前面添加一个新元素。 12345var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;arr.unshift(4); // result is [4,1,2,3]; 修改数组中的元素通过下标修改元素内容。 1234567var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;//下标修改arr[0] = 4;console.log(arr); // result is [4,2,3]; 删除数组元素内容 方法一：通过array的pop方法来添加。 说明一点：pop是往数组删除末尾元素。 12345var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;arr.pop(); // result is [1,2]; 方法二：通过array的shift方法来添加。 说明一点：shift是网数组删除最前面一个元素。 12345var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;arr.shift(); // result is [2,3]; 合并数组用concat方法来合并另外一个数组。 1234var arr = [1,2,3];var arr1 = [4,5,6];var arr2 = arr.concat(arr1);console.log(arr2); // [1,2,3,4,5,6]; 删除指定数组用splice方法来合并另外一个数组。 注意：splice方法接受两个参数，一个从哪里开始，一个是到哪里结束。 123var arr = [1,2,3];arr.splice(0,1);console.log(arr); // [2,3]; 截取指定数组用slice方法来合并另外一个数组。 注意：slice方法接受两个参数，一个从哪里开始，一个是到哪里结束（但是不包括这个结束的元素本身）。如果是负数，就从倒数第几个。 12var arr = [1,2,3];console.log(arr.slice(0,1);); // [1]; 写在最后今天的数组操作方法就介绍这么多，以后会持续更新的。","categories":[{"name":"js","slug":"js","permalink":"https://gitguanqi.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gitguanqi.github.io/tags/js/"},{"name":"数组操作","slug":"数组操作","permalink":"https://gitguanqi.github.io/tags/数组操作/"}]},{"title":"markdown使用笔记","slug":"markdown-use","date":"2018-11-24T06:03:21.000Z","updated":"2019-01-16T03:30:46.703Z","comments":true,"path":"2018-11-24/markdown-use/","link":"","permalink":"https://gitguanqi.github.io/2018-11-24/markdown-use/","excerpt":"","text":"已经很久没有写过文章了，感觉这个冬天过的非常寒冷，自己平时工作也比较忙，所以没有更新文章。今天正好有时间，就想写点东西，为生活的自己，为远方的家人，增添一些精彩。 介绍今天主要讲的就是markdown这门标记语言，说要标记语言，你们可能会想到html，对的，它就是一门超文本标记语言，用来展示网页内容结构的。 那markdown不太一样，它是用于文档的快速排版，类似于word。 它有以下特点： 轻量 简单 通用 用途 写博客 写说明 转化 写博客正因为它有那些特点，语法简单容易学，而且功能还比较强大，所以非常多的人用它来写博客。最流行的博客平台有很多都支持markdown，比如说wordpress，zblog等博客平台，还有github等代码托管平台。 写说明在github上随处可见各种仓库都有README.md结尾的说明文档，帮助开发者更好的了解这个仓库存放的东西是什么，都有哪些功能作用，可以用来做什么。 转化转化这个用途，就不太常见了，它主要是把markdown文件转化为ppt,word等文件文档格式。用于学术研究，数据计算等领域。 语法 标题 文本 图片 链接 列表 表格 代码 标题在markdown的语法规则中，标题是用 # 号来标记的，一共有六级，分别是1-6类似于html的标题标签。# 号从大到小，内容从大到小，# 号越多，级别越小，内容越详细。 语法如下:123456# 标题1## 标题2### 标题3#### 标题4##### 标题5###### 标题6 下面是效果展示： 标题1标题2标题3标题4标题5标题6文本文本也是markdown的特色之一。包括粗体，斜体，删除，引用，分割线。 123451.粗体用两个*号包围内容。 2.斜体用一对*号包围内容。 3.删除用一对两个波浪线表示 4.引用是用大于号来表示，大于号越多，程度越深。 5.分割线是用来区分各段落的不同内容的。 下面是效果展示。 我是斜体 我是粗体 我是删除内容 我是引用的内容 我是引用的内容 我是引用的内容 我是分割线 图片说明图片使用最前面一个英文叹号，中间是方括号括起来，写说明，后面是一个花括号，写图片地址。 语法：![我是图片](xxx.jpg) 这样就是表示一个图片。 例如： 百度 链接链接的使用方法和图片有些类似，就是去掉了叹号，后面的都不变，前面还是方括号，用来链接地址文字说明，后面是花括号，用于链接的网络地址。 语法： [链接说明](http://www.example.com) 例如：百度 列表列表是用来展示要点，一列一列显示内容，用于内容比较多的时候使用。 语法： 无序列表：+和-。+就是一级列表，-就是二级列表。 有序列表：用数字加点，要空格。 例如： 这是无序列表。 水果 香蕉 苹果 葡萄 蔬菜 谷物 天气 这是有序列表。 水果 蔬菜 谷物 天气 表格表格是用于展示某一个统计内容的，范围比较广。 语法:123456表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容两点是左右，点在左边就文字居左。 例如： 12345序号|姓名|成绩|排名--|:--:|--:|--1|张三|98|优秀2|李四|46|不及格3|王五|63|合格 效果如下： 序号 姓名 成绩 排名 1 张三 98 优秀 2 李四 46 不及格 3 王五 63 合格 代码可以用代码或者代码块来写代码，是广大程序员必爱之物。 语法： 两个斜点表示一个代码条，并且高亮显示； 三个斜点一排，排成两排，中间写点内容，就是代码块，用来展示很多段代码。你可以在第一排旁边写上你要写代码的内容类型，比如：html,css,javascript或js,php等等都可以广泛的支持各种标记、编程语言。 效果如下： 代码条 例如：css 代码块 例如：这是一段html标记语言代码块。12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Markdown学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Markdown&lt;/h1&gt; &lt;p&gt;欢迎学习markdown课程。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 例如：这是一段css标记语言代码块。123456h1 &#123; color: #f00;&#125;p &#123; line-height: 20px;&#125; 例如：这是一段js标记语言代码块。1document.write('你好，欢迎学习markdown教程'); 写在最后Markdown是一门非常不错的，值得每个人学习的文本编辑器都支持的标记语法的语言，希望每个人都能学会，这里我只是把我日常写作中常用的做了一个总结汇总，都某时记不得的时候，再来回顾。","categories":[{"name":"标记语言","slug":"标记语言","permalink":"https://gitguanqi.github.io/categories/标记语言/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://gitguanqi.github.io/tags/markdown/"},{"name":"文本编辑","slug":"文本编辑","permalink":"https://gitguanqi.github.io/tags/文本编辑/"}]},{"title":"git配置教程","slug":"git-config","date":"2018-11-18T14:16:21.000Z","updated":"2019-01-16T03:21:08.221Z","comments":true,"path":"2018-11-18/git-config/","link":"","permalink":"https://gitguanqi.github.io/2018-11-18/git-config/","excerpt":"","text":"一.配置ssh1.检查本机是否有ssh key设置如果没有则提示： No such file or directory如果有则进入~/.ssh路径下（ls查看当前路径文件，rm删除所有文件） 2.使用Git Bash生成新的ssh key$ cd ~ #保证当前路径在”~”下123456789101112$ ssh-keygen -t rsa -C &quot;xxxxxx@yy.com&quot; #建议填写自己真实有效的邮箱地址Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/xxxx_000/.ssh/id_rsa): #不填直接回车Enter passphrase (empty for no passphrase): #输入密码（可以为空）Enter same passphrase again: #再次确认密码（可以为空）Your identification has been saved in /c/Users/xxxx_000/.ssh/id_rsa. #生成的密钥Your public key has been saved in /c/Users/xxxx_000/.ssh/id_rsa.pub. #生成的公钥The key fingerprint is:e3:51:33:xx:xx:xx:xx:xxx:61:28:83:e2:81 xxxxxx@yy.com//本机已完成ssh key设置，其存放路径为：c:/Users/xxxx_000/.ssh/下。//可生成ssh key自定义名称的密钥，默认id_rsa。$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; -f ~/.ssh/githug_blog_keys #生成ssh key的名称为githug_blog_keys，慎用容易出现其它异常。 3.添加ssh key到GItHub3.1 登录GitHub系统； 点击右上角账号头像的“▼”→Settings→SSH kyes→Add SSH key。 key 3.2 复制id_rsa.pub的公钥内容1) 进入c:/Users/xxxx_000/.ssh/目录下，打开id_rsa.pub文件，全选复制公钥内容。2) Title自定义，将公钥粘贴到GitHub中Add an SSH key的key输入框，最后“AddKey”。 4.配置账户12$ git config --global user.name “your_username” #设置用户名$ git config --global user.email “your_registered_github_Email” #设置邮箱地址(建议用注册giuhub的邮箱) 5.测试ssh keys是否设置成功1234567$ ssh -T git@github.comThe authenticity of host &apos;github.com(192.30.252.129)&apos; can&apos;t be established.RSA key fingerprint is16:27:xx:xx:xx:xx:xx:4d:eb:df:a6:48.Are you sure you want to continueconnecting (yes/no)? yes #确认你是否继续联系，输入yesWarning: Permanently added&apos;github.com,192.30.252.129&apos; (RSA) to the list of known hosts.Enter passphrase for key&apos;/c/Users/xxxx_000/.ssh/id_rsa&apos;: #生成sshkye是密码为空则无此项，若设置有密码则有此项且，输入生成ssh key时设置的密码即可。Hi xxx! You&apos;ve successfullyauthenticated, but GitHub does not provide shell access. #出现词句话，说明设置成功。 二、Github新建项目1.Github新建项目点击按钮 新建 2.注意项目名（必须是：github的用户名.github.io） 新建 3.将项目clone到本地$ git clone https://github.com/&lt;你的用户名&gt;/&lt;仓库名字&gt;.git 然后输入命令，回车，等待clone完成。 4.将index.html推送到远程github仓库中123git add .git commit -m &quot;这里是注释信息，自己写&quot;git push origin master 三.写在最后git的配置就到这里。","categories":[{"name":"git","slug":"git","permalink":"https://gitguanqi.github.io/categories/git/"}],"tags":[{"name":"github","slug":"github","permalink":"https://gitguanqi.github.io/tags/github/"}]},{"title":"雅虎军规总结","slug":"yahoo-rules","date":"2018-11-18T14:16:21.000Z","updated":"2019-01-16T02:58:31.663Z","comments":true,"path":"2018-11-18/yahoo-rules/","link":"","permalink":"https://gitguanqi.github.io/2018-11-18/yahoo-rules/","excerpt":"","text":"前言：雅虎军规是雅虎的开发人员在总结了网站的不合理部分后，提出的优化网站性能提高的一套方法规则，非常适合初学者绕过这些坎。这篇博文，是我在网络上搜集的一些关于雅虎军规的内容，图片归原作者所有，总结一起，供大家参考使用，希望对你们以后的开发过程中有所帮助。 http 1.尽可能的减少http请求数HTTP：从客户端到服务器端的请求消息。包括消息首行中，对资源的请求方法资源的标识符以及使用的协议。 请求过程：当你打开网页的时候，你所看到的文字，图片，多媒体，这一切内容，都是你从服务器获取的，每一个内容的获取，就是一个http请求。 http 2.使用CDN（内容分发网络）CDN：内容分发网络，意思就是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 CDN 通俗来说：就是在离你最近的地方，放置一台性能好、链接顺畅的副本服务器，让你能够以最近的距离，最快的速度获取内容。 CDN 3.添加Expire/Cache-Control头Expire头：内容是一个时间值，值就是资源在本地的过期时间，存在本地；在本地缓存阶段，找到一个对应的资源值，当前时间还没有超过资源的过期时间，就直接使用这个资源，不会发送http请求。 Cache-Control头C：是http协议中常用的头部之一，负责页面的缓存机制，如果该头部指示缓存，缓存的内容也会存在本地，操作流程和expire相似，但也有不同的地方，Cache-Control有更多的选项，而且有更多的处理方式。 4.启用Gzip压缩看图： Gzip压缩 举个例子： Gzip压缩 5.将css放在页面最上面CSS：CSS，就是层叠样式表。 CSS01 为了提高游览器加载速度，建议放在html的head标签内。 CSS02 CSS03 6.将script放在页面最下面页面DOM加载顺序： js01 为了顺利加载各种资源，把js放在页面最下面，可以正常运行脚本，也为获取DOM元素更流畅。 7.避免在CSS中使用Expressions定义： CSS—Expressions 例子： CSS—Expressions 8.把js和css文件放到外部文件中情况1：写在页面内，如果只是的单独一个页面使用js和css文件，可以写在页面里面；还有就是不经常访问的页面；并且脚本和样式很少。这样写可以： 减少页面请求 提升页面渲染速度 情况2：单独提取，如果是大量页面复用，那就需要引入js和css文件。这样写可以： 提高js和css的复用性 缩小页面体积 提高了js的css的可维护性 9.减少DNS查询DNS：（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。 DNS 缓存时间对比: 当缓存时间长时：减少DNS的重复查找，节省时间。 当缓存时间短时：及时的检测网站服务器的变化，保证正确性。 DNS 域名：（Domain Name），简称域名、网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。 可以使用单域和多域 DNS 10.压缩JavaScript和Css方法： 去除不必要的空白符，格式符，注释符。 简写方法名，参数名压缩js脚本。 例如：jquery 压缩JavaScript和Css 建议：：在网站上线项目前，将JavaScript和Css都进行压缩，使线上版本是最轻量级的，大幅提升网站性能。 11.避免重定向定义： 原始请求被重新转向了其他请求。 避免重定向 状态码： 301（Moved Permanently）：被移动到了另外的位置。 302 Found：被找到了，不在原始位置，临时重定向。 避免重定向 为什么避免重定向：多了一次请求。 避免重定向 12.移除重复的脚步例子: 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;移除重复的脚步&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=\"test\" type=\"text\" value=\"\"&gt; &lt;script&gt; var number = 0; &lt;/script&gt; &lt;script src=\"./test.js\"&gt;&lt;/script&gt; &lt;!-- 引用1次 正常 1 --&gt; &lt;script src=\"./test.js\"&gt;&lt;/script&gt; &lt;!-- 引用2次 不正常 2 --&gt;&lt;/body&gt;&lt;/html&gt; 123//js domnumber++;document.getElementById('test').value = number; 13.配置实体标签（ETag）定义：使用特殊的字符串来标识某个请求资源版本。 配置实体标签（ETag） 配置实体标签（ETag） 如果本地版本游览器一样，就使用本地的缓存文件，并且会返回304。 14.使用Ajax缓存定义：即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 使用Ajax缓存 方法：get和post POST：每次都执行，不被缓存。 get:同一地址不重复执行，可以被缓存。 get和post 写在最后这是我第一次总结前人的经验。","categories":[{"name":"前端规范","slug":"前端规范","permalink":"https://gitguanqi.github.io/categories/前端规范/"}],"tags":[{"name":"雅虎军规","slug":"雅虎军规","permalink":"https://gitguanqi.github.io/tags/雅虎军规/"},{"name":"前端规范","slug":"前端规范","permalink":"https://gitguanqi.github.io/tags/前端规范/"},{"name":"性能优化","slug":"性能优化","permalink":"https://gitguanqi.github.io/tags/性能优化/"}]},{"title":"前端杂谈","slug":"front-talk-one","date":"2018-11-18T13:16:21.000Z","updated":"2019-01-16T03:19:00.242Z","comments":true,"path":"2018-11-18/front-talk-one/","link":"","permalink":"https://gitguanqi.github.io/2018-11-18/front-talk-one/","excerpt":"","text":"一.故事简介1.起源今天，我想讲一讲有关前端的一些趣事。首先介绍一下我吧，我叫观奇笔记，内容更新其实不算多，主要是是我工作比较忙，没有时间去更新。 2.行业态势前端技术，作为一门新兴的技术，已经火了好几年了，现在已经进入了一个瓶颈期，就是需求量还是会不断地增加，但是要求肯定会提高的，不会是以前的蛮荒时代，见一个前端就招进去了，而是会不断的筛选，淘汰技术差的，留下技术好的，一个大浪淘沙的时代。 二.播种期好了，开始言归正传。我来讲一讲我的前端生涯之路，也算是对之前的一些总结吧。 1.高中时代我现在脑海中清晰的记得，我上高三的时候，我们的微机课老师在教室的黑板上写了一段代码。我还能回忆起来，大概就是以下这段。 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;表格&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 2.讲课感受我就被这个神奇的代码所吸引住了，当时老师还边说，边讲，边在黑板上用白色粉笔头画着，其实就是用粉笔头写代码。我当时就感觉这玩意真好，我要了解它，学会它。自此，想要学习html代码的种子便在我心中种下了，直到以后它生根，发芽，开花，直到结果。 三.萌芽期1.无缘计算机上了大学以后，本来说是想报考计算机专业，但是没想到人招满了，我便被安排到了第二个志愿–电子商务，我感觉电子商务还可以，就是做购物网站的，还可以继续我的代码编写，我就欣然接受了这个专业，但是学开就后悔了，里面教的html少，也就是学习Dreamweaver（现在想想真是感觉太搞笑了，哈哈！），asp，商务一类的课程非常多，比如市场营销，商务谈判，管理学，经营企业，不管怎么不好，还是学点，以后会用到的。 2.冲破牢笼我后来就是自己买书，一点一点的学习web前端，其实那时候还不能叫前端，只能算作一个网页开发师。写一些简单的网页结构，一些简单的样式。自己没有电脑，就去学校的机房学习，打开电脑，打开记事本，就可以学习了，按照书上的，网上的教程学习，一点点的学习。每练习一个例子，就用记事本保存起来，存成Unicode格式或者utf-8格式的，可以在游览器显示的那种，后缀就是.html或者.htm就可以了，最后，在游览器里面查看效果，看到自己写的代码能够被游览器引擎解析然后展现在游览器的窗口里面，顿时感觉心中非常开心。 四.写在最后好了，今天就讲到这里，以后陆续会和大家分享我的前端成长之路的。","categories":[{"name":"前端杂谈","slug":"前端杂谈","permalink":"https://gitguanqi.github.io/categories/前端杂谈/"}],"tags":[{"name":"前端杂谈","slug":"前端杂谈","permalink":"https://gitguanqi.github.io/tags/前端杂谈/"}]},{"title":"git工具命令使用教程","slug":"git-tool-command","date":"2018-09-25T09:30:21.000Z","updated":"2019-01-16T03:13:25.952Z","comments":true,"path":"2018-09-25/git-tool-command/","link":"","permalink":"https://gitguanqi.github.io/2018-09-25/git-tool-command/","excerpt":"","text":"这是一个学习git-bash以及命令的教程！ 常用命令git add 含义：这是将文件从本地文件夹提交到git storage (暂存区)。 例如：git add test.txt git commit -m ““含义：这是将暂存区的文件提交到当前分支(master)。 例如： git commit -m &quot;add files&quot; git pull origin 含义： 这是将远程仓库的git文件拉到本地。 例如：git pull origin master git push origin 含义： 这是将本地分支的git文件推送到远程仓库。 例如：git push origin master 分支（master）创建分支git branch &lt;分支名字&gt; 例如：git branch dev 切换到指定分支git checkout dev 创建并且切换到指定分支git branch -b &lt;分支名字&gt; 例如：git branch -b dev 删除分支git branch -d &lt;分支名字&gt; 例如：git branch -d dev 强制删除分支git branch -D &lt;分支名字&gt; 例如：git branch -D dev 删除远程分支git push origin -D &lt;分支名字&gt; 例如：git push origin -D dev 合并分支git merge &lt;分支名称&gt; 例如：git merge dev 标签创建标签git tag &lt;标签名字&gt; 例如: git tag v0.1 查看所有标签git tag 查看标签信息git show v0.1 创建带有说明的标签git tag -a v0.1 -m &quot;add tags&quot; 删除标签git tag -d &lt;标签名字&gt; 推送标签到远程仓库 推送本地全部标签：git push origin --tags 推送特定标签：git push origin v0.1 删除远程仓库标签git push origin :refs/tags/v0.1 其他忽略其他文件 有时候我们并不希望一些东西在我们的提交内容里面，比如node_moundle 在文件夹下面创建.gitignore就可以忽略不希望提交的内容。 12# windowsDesktop.ini 最后这一期的git讲解就到这里。","categories":[{"name":"git","slug":"git","permalink":"https://gitguanqi.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://gitguanqi.github.io/tags/git/"},{"name":"git-bash","slug":"git-bash","permalink":"https://gitguanqi.github.io/tags/git-bash/"}]},{"title":"Vue基础教程(三)","slug":"vue-use-three","date":"2018-05-10T00:42:21.000Z","updated":"2019-01-16T03:16:05.179Z","comments":true,"path":"2018-05-10/vue-use-three/","link":"","permalink":"https://gitguanqi.github.io/2018-05-10/vue-use-three/","excerpt":"","text":"hello,大家好！时隔一天，我又回来了。因为一些事情停了。经过前两节，大家应该对vuejs有了一些了解。今天继续讲解vuejs。 目录 插值 指令 缩写 插值文本插值 这是数据绑定最常见的形式，使用的Mustache”语法 (双大括号) 。 例如：&lt;span&gt;这个将不会改变: &lt;/span&gt; 原生html内容这个你需要使用v-html来实现。 例如： 1.&lt;p&gt;这是html内容：&lt;/p&gt; 2.&lt;p v-html=&quot;str&quot;&gt;&lt;/p&gt; 注意：你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。 指令 指令 (Directives) 是带有 v- 前缀的特殊特性，响应式的作用于DOM。 v-if含义：这个是根据传入的值来决定是否移除绑定的元素，它的值是true或者false 例如：&lt;p v-if=&quot;true&quot;&gt;我是vue&lt;/p&gt; 修饰符修饰符：以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。 &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;表单内容&lt;/form&gt; 缩写v- 作为一种识别特性，常常会缩写，以便提高代码效率。 v-onv-on是绑定元素要触发的各种事件的，可以缩写成@&lt;事件名&gt;=&quot;&lt;触发的函数名&gt;&quot; 例如： 1234//1.原样：&lt;button v-on:click=&quot;checkForm&quot;&gt;&lt;/button&gt;//2.缩写：&lt;button @click=&quot;checkForm&quot;&gt;&lt;/button&gt; v-bindv-bind是绑定元素属性的一种指令，可以缩写成:&lt;属性名&gt;=&quot;&lt;属性值&gt;&quot; 例如： 1234&lt;!-- 1.原样： --&gt;&lt;a v-bind:href=\"url\"&gt;链接&lt;/a&gt;&lt;!-- 2.缩写： --&gt;&lt;a :href=\"url\"&gt;链接&lt;/a&gt; 写在最后今天虽然只讲了一点，但贵在积累，积少成多，每天学习一点，相信总有一天能够技压群雄，加油！幸福生活是奋斗出来的。","categories":[{"name":"js框架","slug":"js框架","permalink":"https://gitguanqi.github.io/categories/js框架/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://gitguanqi.github.io/tags/vuejs/"}]},{"title":"Vue基础教程(二)","slug":"vue-use-two","date":"2018-05-08T02:42:21.000Z","updated":"2019-01-16T03:17:56.771Z","comments":true,"path":"2018-05-08/vue-use-two/","link":"","permalink":"https://gitguanqi.github.io/2018-05-08/vue-use-two/","excerpt":"","text":"今天一起来和大家探讨vue基础知识点，主要是一些基本用法，只有打好扎实的基础，才能在以后vue.js开发过程中少走弯路。 目录 创建vue实例 数据绑定 方法 一.创建vue实例 首先引入vue.js文件 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 然后实例化一个vue 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最后定义vue的管理边界 注意： 如果你不定义管理边界，就可能无法应用vue中的属性和方法。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 在这里写vue.js --&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二.数据绑定数据： 这里的数据就是你要渲染到页面中的值,这个数据发生变化，视图中的数据也会发生变化。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 在这里写vue.js --&gt; &lt;input type=\"text\" v-model=\"str\"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; str: '' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 三.方法方法： 就是js中的函数和事件监听。 例如：弹出一个信息。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue(2)&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 在这里写vue.js --&gt; &lt;input type=\"text\" v-model=\"str\"&gt; &lt;p&gt;&#123;&#123; str &#125;&#125;&lt;/p&gt; &lt;button @click=\"alertInfo\"&gt;弹出信息&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; str: '' &#125;, methods: &#123; alertInfo () &#123; alert('这就是vue'); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 四.写在最后今天虽然只讲了一点，但贵在积累，积少成多，每天学习一点，相信总有一天能够技压群雄，加油！幸福生活是奋斗出来的。","categories":[{"name":"js框架","slug":"js框架","permalink":"https://gitguanqi.github.io/categories/js框架/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://gitguanqi.github.io/tags/vuejs/"}]},{"title":"Vue基础教程(一)","slug":"vue-use-one","date":"2018-05-06T13:54:21.000Z","updated":"2019-01-16T03:17:18.089Z","comments":true,"path":"2018-05-06/vue-use-one/","link":"","permalink":"https://gitguanqi.github.io/2018-05-06/vue-use-one/","excerpt":"","text":"哈喽，大家好！今天给大家继续讲解vue的知识点。 目录 引入vue.js文件 声明式渲染 一.引入vue.js 下载vue.js文件：点击下载 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; CDN线上，引入地址：https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.common.js &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.common.js&quot;&gt;&lt;/script&gt; 新建html文件，在head标签内引入 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;引入vue&lt;/title&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; //内容 &lt;/div&gt; &#123;&#123; 1+2 &#125;&#125; &lt;script&gt; new Vue(&#123; el: '#app' &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 二.声明式渲染两个花括号中间可以写表达式，判断，数据类型，就是不能写循环。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;引入vue&lt;/title&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;&#123; msg &#125;&#125; &lt;script&gt; new Vue(&#123; el: '#app', data: &#123; msg: '111' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 写在最后今天虽然只讲了一点，但贵在积累，积少成多。","categories":[{"name":"js框架","slug":"js框架","permalink":"https://gitguanqi.github.io/categories/js框架/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://gitguanqi.github.io/tags/vuejs/"}]},{"title":"数据结构","slug":"dataset-description","date":"2018-05-05T06:30:21.000Z","updated":"2019-01-16T03:10:30.492Z","comments":true,"path":"2018-05-05/dataset-description/","link":"","permalink":"https://gitguanqi.github.io/2018-05-05/dataset-description/","excerpt":"","text":"数据结构 数据元素：数据的基本单位，每一个需要处理的对象都可以抽象成数据元素，简称元素。 数据结构：包含数据和结构。 数据：是需要处理的数据元素的集合，一般来说这些数据元素，具有某个共同的特征。例如：方向（东南西北） 结构：就是关系，即集合中各个数据元素之间存在的某种关系（或联系）。1.线性结构，2.树形结构，3.图状结构，4.集合。 数据元素之间的关系用前件和后件来描述。例如：连长是排长的后件，排长是连长的前件。 前后件关系是数据元素之间最基本的关系。 数据结构是指相互有关联的数据元素的集合。 数据是有结构的数据，结构是有数据之间关系决定的。 数据元素有逻辑和关系。数据结构逻辑结构和存储结构数据的逻辑结构 数据的逻辑结构指的是数据元素之间的逻辑关系（前后件关系）的数据结构。B=(D,R); B = 数据结构 D = 数据元素的集合 R = D上关系的集合。 B = (D,R)D = {早餐，午餐，晚餐}R = {(早餐，午餐),(午餐，晚餐)} 数据的存储结构 数据的存储结构：又称数据的物理结构，是数据的逻辑结构在计算机存储空间中的存放方式。 顺序存储结构：逻辑上相邻的数据元素，存储在物理上相邻的存储单元里。 200 k1 201 k2 202 k3 203 k4 204 k5 链式存储结构：每个节点中至少包含一个指针域，用指针来体现数据元素之间逻辑上的联 系。 Head Key Info 200 –&gt; 200 k1 204 201 202 k3 203 203 k4 207 204 k2 202 205 206 207 k5 ^ 链式存储的线性表 最后这是计算机基础知识，最普通的一个概念。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://gitguanqi.github.io/categories/计算机基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://gitguanqi.github.io/tags/数据结构/"}]},{"title":"初识webpack","slug":"front-talk-three","date":"2018-04-01T08:07:39.000Z","updated":"2019-01-16T03:20:38.946Z","comments":true,"path":"2018-04-01/front-talk-three/","link":"","permalink":"https://gitguanqi.github.io/2018-04-01/front-talk-three/","excerpt":"","text":"今天，咱们正式介绍一下前端打包神器，webpack。这是一款非常流行的打包工具，和各种框架都非常搭配。 一.简介大家好！今天我开始分享有关web前端的故事。俗话说：“男怕入错行，女怕嫁错郎”。如果能够进入发展前景比较好的行业是一个不错的选择，对自己以后的成长与发展都会起到很大的作用。虽然说目前还看不出什么，但是相信随着时间的流逝，这个行业会越来越好。而我选择的这个行业，就是互联网行业，属于服务业。而我目前从事的是前端，这个从2015年兴盛起来的职业，目前已经度过了寒冬，正迎来蓬勃的生机。 二.四个核心概念接下来就解释一下这四个核心的概念。 入口(entry) 输出(output) loader 插件(plugins) 1.入口(entry)入口：所谓入口，就是指示webpack应该使用哪个模块来作为内部依赖的开始，它会根据入口来生成一个bundles文件。 例如：123module.exports = &#123; entry: './path/to/my/entry/file.js'&#125;; 上面就是指定入口文件，就是file.js。 2.输出(output)出口：就是打包输出到哪个文件夹下面去。 例如：1234567const path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;&#125;; 上面就是指定出口文件dist，文件名称叫dist文件夹下面的这个文件my-first-webpack.bundle.js。 3.loaderloader:就是让webpack去处理那些非JavaScript文件，并且导入任何类型的模块，比如css。并且，进行处理。它可以将所有类型的文件，转化为可以直接引用的模块。 例如：123456789101112131415//定义规则const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; //解析规则 ] &#125;&#125;;// 到处配置module.exports = config; 这个就是，模块打包规则。test,use,就是告诉webpack遇到引用txt文件的，使用raw-loader转化一下。 4.插件(plugins)这是最后一个核心概念。有时候，前面的不一定处理过来，所以靠扩展插件来提高打包效率是一个非常有效的方法。它可以执行更多复杂的任务，例如：打包优化，压缩，重新定义环境变量等等。 插件的使用方法见下面的代码。1234567891011121314151617const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config; 四.总结我们今天先说到这里，下次继续聊webpack。","categories":[{"name":"前端杂谈","slug":"前端杂谈","permalink":"https://gitguanqi.github.io/categories/前端杂谈/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://gitguanqi.github.io/tags/webpack/"}]},{"title":"初识vue","slug":"front-talk-two","date":"2018-02-18T12:57:39.000Z","updated":"2019-01-16T03:20:25.629Z","comments":true,"path":"2018-02-18/front-talk-two/","link":"","permalink":"https://gitguanqi.github.io/2018-02-18/front-talk-two/","excerpt":"","text":"一.vue行业大家好！今天我开始分享有关web前端的故事。俗话说：“男怕入错行，女怕嫁错郎”。如果能够进入发展前景比较好的行业是一个不错的选择，对自己以后的成长与发展都会起到很大的作用。虽然说目前还看不出什么，但是相信随着时间的流逝，这个行业会越来越好。而我选择的这个行业，就是互联网行业，属于服务业。而我目前从事的是前端，这个从2015年兴盛起来的职业，目前已经度过了寒冬，正迎来蓬勃的生机。 二.vue是什么好了，废话不多说，现在就开始进入正题。有很多人看到这里，会禁不住的问，那vue是什么呢？vue是一套基于js写的框架，可以方便轻松的开发spa单页面应用程序。它是由前Google工程师尤雨溪开发的，它解决了开发者开发过程中的四个痛点。 三.四大痛点1.学习门槛低第一个就是，使得学习vue的门槛变得非常低，只要你会基础的html和css知识，懂得原生的js，那么恭喜您，已经拿到了学习vue的入场券。这对于web前端的小伙伴们来说是一个非常诱人的东西，你不需要掌握什么高深的技术知识，就可以轻松学习vue知识点。 2.学习成本低当然了，除了学习门槛比较低之外，学习成本也是比较低的，不你需要花费多大的时间，以及金钱。它是一个免费开源的js框架，为开发者提供高效率的开发框架。你需要点击进入它的官网，便可以看见它的开发文档。这套文档感觉非常通俗易懂，只要你仔细阅读，还是可以读懂的。它还提供了脚手架组件化开发工具，只有你下载下来一步步输入几行命令，就可以拥有很不错的开发环境。 3.覆盖设备广第三个就是，它跨设备，基本上各种设备都支持，不论是PC端，还是移动端，亦或者是手机app都可以。这种特点给了使用它的人极大的方便。 4.跨平台第四个就是跨平台，在这里我就一句话概括，既可以开发andriod，也可以开发ios应用。 四.总结以上就是web开发的四个痛点，vue都完美解决。我刚开始接触vue的时候，只是知道它是一种区别于MVC模式的MVVM模式。MVVM的本质就是通过数据绑定view和model，数据一旦发生变化，view和model也会发生变化。这种模式使得学习vue非常简单好用！ 我正在行驶在这一条vue大道上，我知道我的方向不变，始终会到达终点的。我始终相信，功夫不负有心人，只要努力坚持，一定会成功！","categories":[{"name":"前端杂谈","slug":"前端杂谈","permalink":"https://gitguanqi.github.io/categories/前端杂谈/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://gitguanqi.github.io/tags/vuejs/"}]},{"title":"node.js常用命令","slug":"node-command","date":"2017-12-21T07:27:21.000Z","updated":"2019-01-16T03:03:24.802Z","comments":true,"path":"2017-12-21/node-command/","link":"","permalink":"https://gitguanqi.github.io/2017-12-21/node-command/","excerpt":"","text":"安装node验证是否安装node12$node -v$npm -v npm node package manager ,Node 的包管理器 安装 包12# 安装到当前目录$ npm install &lt;包名&gt; 出现error network 重新安装 搜索包1$npm search &lt;包名&gt; 安装指定版本在cmd中: 12$ npm install &lt;包名&gt;@版本号$ npm install jquery@1.12.4 查看包的版本信息1$ npm list &lt;包名&gt; 查看安装的包列表1$npm ls 更新包1$ npm update &lt;包名&gt; 卸载包1$ npm uninstall jquery init 初始化npm init 会生成一个packagejson的文件，项目的配置信息1$ npm init 12345678910111213141516171819&#123; &quot;name&quot;: &quot;day06&quot;, //项目名 &quot;version&quot;: &quot;1.0.0&quot;, //版本号 &quot;description&quot;: &quot;this is a npm project&quot;, //项目的描述 &quot;main&quot;: &quot;index.js&quot;, //程序的入口文件 &quot;dependencies&quot;: &#123; //项目依赖的包!!!重要的 &quot;jquery&quot;: &quot;^1.12.4&quot; &quot;zepto&quot;: &quot;^1.2.0&quot; &#125;, &quot;devDependencies&quot;: &#123;&#125;, //开发阶段依赖的包!!!重要的 &quot;scripts&quot;: &#123; //命令 &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [ //关键词 &quot;npm&quot; ], &quot;author&quot;: &quot;guanqi&quot;, //作者 &quot;license&quot;: &quot;ISC&quot; //协议&#125; 安装并添加依赖$ npm install &lt;包名&gt; --save 会将当前目录下的安装包，并将包的信息，添加到package.json中的dependencies选项中 $ npm install &lt;包名&gt; --save-dev安装开发阶段用的工具包，并不是项目必须有的。这个命令会将包安装到当前目录下的安装包，并将包的版本信息，添加到package.json中的devDependencies选项中 全局安装$ npm install &lt;包&gt; -g , -g代表全局安装，不会在package.json中看到 安装包$ bower install &lt;包名&gt; --save,在当前目录安装包，并将版本信息添加到bower.json中 $ bower install &lt;包名&gt;@版本号，安装指定的版本号 查看包的信息$ bower info &lt;包名&gt; 查看包的详细信息 搜索包$ bower search &lt;包名&gt; 包列表$ bower list 卸载包$ bower uninstall &lt;包名&gt; 最后心动不如行动，快练习一下巩固知识。","categories":[{"name":"node","slug":"node","permalink":"https://gitguanqi.github.io/categories/node/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://gitguanqi.github.io/tags/nodejs/"},{"name":"node命令","slug":"node命令","permalink":"https://gitguanqi.github.io/tags/node命令/"}]},{"title":"Node.js简介","slug":"node-introduction","date":"2017-12-10T10:04:21.000Z","updated":"2019-01-19T07:36:04.177Z","comments":true,"path":"2017-12-10/node-introduction/","link":"","permalink":"https://gitguanqi.github.io/2017-12-10/node-introduction/","excerpt":"","text":"简介官网中文官网 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js是构建在 chorme的V8引擎上的一个js运行时 Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. 事件驱动(回调函数)非阻塞异步I/O单线程单进程 Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 作者Ryan Dahl 适用场景 高并发(双11) 站内信 实时聊天 缺点：不适合大量的计算 Global在游览器中全局对象（顶层对象）是window在node中全局对象叫Global Buffer process console setTimeout setInterval clearTimeout clearIntervalREPL环境 进入的方法，在cmd中输入node,然后enter，就可以进入node的REPL环境。 Read 读，读取用户输入，解析输入的JS数据结构并存储在内存中 Eval 执行，执行输入的数据结构 Print 打印，输出结果 Loop 循环 ，循环操作以上步骤，直到CTRL+C以后 退出REPL环境，用Ctrl+C两次 运行Node.js的代码$ node &lt;文件名&gt; 总结node.js是一个很不错的后端服务器编程语言。","categories":[{"name":"node","slug":"node","permalink":"https://gitguanqi.github.io/categories/node/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://gitguanqi.github.io/tags/nodejs/"},{"name":"node简介","slug":"node简介","permalink":"https://gitguanqi.github.io/tags/node简介/"}]},{"title":"todocmvc练习(vue版)","slug":"todomvc","date":"2017-10-23T06:42:21.000Z","updated":"2019-01-16T03:12:34.709Z","comments":true,"path":"2017-10-23/todomvc/","link":"","permalink":"https://gitguanqi.github.io/2017-10-23/todomvc/","excerpt":"","text":"安装依赖安装依赖的css，js 1$npm install 引入vue1&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; 定义初始化数据在app.js中，实例化Vue，然后定义初始化数据 1234567891011&#123; //为了形成块级作用域()() let vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; datas: [ &#123;id: 121,title: &apos;html5&apos;,isCompleted: false&#125;, &#123;id: 122,title: &apos;css3&apos;,isCompleted: false&#125;, &#123;id: 123,title: &apos;js6&apos;,isCompleted: false&#125;, ] &#125; &#125;) 绑定假数据到li上如果当前的isCompleted是true,就是显示选中状态 12345678&lt;li :class=\"&#123;completed: isCom&#125;\" v-for=\"(item,index) in datas\"&gt; &lt;div class=\"view\"&gt; &lt;input class=\"toggle\" type=\"checkbox\"&gt; &lt;label&gt;&#123;&#123; item.title &#125;&#125;&lt;/label&gt; &lt;button class=\"destroy\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class=\"edit\" value=\"Create a TodoMVC template\"&gt;&lt;/li&gt; 双向数据绑定1&lt;input class=\"new-todo\" placeholder=\"What needs to be done?\" v-model=\"val\"&gt; 1val: '', //显式声明 输入框数据 回车输入数据1&lt;input class=\"new-todo\" placeholder=\"What needs to be done?\" @keyup.enter=\"addItem\" v-model=\"val\"&gt; 123456789101112methods: &#123; addItem()&#123; if(this.val)&#123; //val存在或者非空的时候才会去添加 this.datas.push(&#123; //console.log(new Date().getTime()); id: new Date().getTime(), //为了保持id的唯一 title: this.val, isCompleted: false, &#125;); this.val = ''; //填完数据以后清空输入框的内容 &#125;&#125; 显示总计通过一个方法来计算数组数据的长度 123456789101112131415161718192021222324methods: &#123; addItem()&#123; if(this.val)&#123; //val存在或者非空的时候才会去添加 this.datas.push(&#123; //console.log(new Date().getTime()); id: new Date().getTime(), //为了保持id的唯一 title: this.val, isCompleted: false, &#125;); this.val = ''; //填完数据以后清空输入框的内容 &#125; &#125;, clearCompleted()&#123; let arr = []; //遍历datas,如果当前选项是未选中,就把它留下 this.datas.forEach(function(elem)&#123; if(!elem.isCompleted)&#123; arr.push(elem); &#125; &#125;,this) this.datas = arr; &#125; &#125;,&#125; 首先绑定计算属性 1&lt;span class=\"todo-count\"&gt;&lt;strong&gt;&#123;&#123; legTotal &#125;&#125;&lt;/strong&gt; item left&lt;/span&gt; 选中后显示隐藏completed通过v-show来控制显示隐藏 1&lt;button class=\"clear-completed\" v-show=\"isShowClear\"&gt;Clear completed&lt;/button&gt; 1234567891011//在计算属性中compluted： &#123; isShowClear()&#123; for(let i=0;i&lt;this.datas.length;i++)&#123; if(this.datas[i].isCompleted)&#123; return true &#125; &#125; return false &#125;&#125; 点击clear completed删除选中项绑定点击事件 1&lt;button class=\"clear-completed\" v-show=\"isShowClear\" @click=\"clearCompleted\"&gt;Clear completed&lt;/button&gt; 在方法中写这个点击事件 12345678910clearCompleted()&#123; let arr = []; //遍历datas,如果当前选项是未选中,就把它留下 this.datas.forEach(function(elem)&#123; if(!elem.isCompleted)&#123; arr.push(elem); &#125; &#125;,this) this.datas = arr;&#125;, 点击X号删除当前项添加点击事件 1&lt;button class=\"destroy\" @click=\"removeCurrent(index)\"&gt;&lt;/button&gt; 123removeCurrent(index)&#123; this.datas.splice(index,1); &#125; 全选全不选点击全选如果是true,让数据全部变成非选中状态; 1&lt;input id=\"toggle-all\" class=\"toggle-all\" type=\"checkbox\" @click=\"checkedAll\"&gt; 1234567891011121314//在方法中checkedAll()&#123; if(this.isCheckedAll)&#123; //全部选中 this.datas.forEach(elem=&gt;&#123; elem.isCompleted = false; &#125;) &#125;else&#123; this.datas.forEach(elem=&gt;&#123; elem.isCompleted = true; &#125;) &#125; this.isCheckedAll = !this.isCheckedAll;&#125; 总结这是一个练习，是用vue写的，各方面都练习到了。","categories":[{"name":"前端案例","slug":"前端案例","permalink":"https://gitguanqi.github.io/categories/前端案例/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://gitguanqi.github.io/tags/vuejs/"},{"name":"todomvc","slug":"todomvc","permalink":"https://gitguanqi.github.io/tags/todomvc/"}]},{"title":"babel编译教程","slug":"babel-use","date":"2017-09-21T09:30:21.000Z","updated":"2019-01-16T03:09:28.042Z","comments":true,"path":"2017-09-21/babel-use/","link":"","permalink":"https://gitguanqi.github.io/2017-09-21/babel-use/","excerpt":"","text":"babel安装安装前你需要安装node.js和npm以及gulp三个包。 然后执行以下命令 1$ npm init 然后在安装 babel和babel-core两个包 1$ npm install --save-dev gulp-babel babel-preset-env 1npm install babel-cor --save-dev 建立文件夹新建一个名为gulpfile.js的文件夹,然后引入包 12345678910111213const gulp = require(&apos;gulp&apos;);const babel = require(&apos;gulp-babel&apos;); gulp.task(&apos;default&apos;, () =&gt; gulp.src(&apos;es6/*.js&apos;) .pipe(babel(&#123; presets: [&apos;env&apos;] &#125;)) .pipe(gulp.dest(&apos;dist&apos;)));gulp.task(&apos;babel&apos;,() =&gt; &#123; gulp.watch(&apos;es6/*.js&apos;,[&apos;default&apos;])&#125;); 新建一个名为src 的文件夹,然后写点js. 1234567&#123; let a = 3; let arr = [1,2,3]; &#125;console.log(a);console.log(arr); 运行任务$ gulp $ gulp babel 这样就大功告成了！","categories":[{"name":"编译工具","slug":"编译工具","permalink":"https://gitguanqi.github.io/categories/编译工具/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://gitguanqi.github.io/tags/es6/"},{"name":"babel","slug":"babel","permalink":"https://gitguanqi.github.io/tags/babel/"}]},{"title":"使用hexo+coding搭建个人博客","slug":"hexo-coding-config","date":"2017-09-21T07:16:21.000Z","updated":"2019-01-16T02:58:03.990Z","comments":true,"path":"2017-09-21/hexo-coding-config/","link":"","permalink":"https://gitguanqi.github.io/2017-09-21/hexo-coding-config/","excerpt":"","text":"1.检测node和npm先检测一下有没有node.js和npm 12345678$ node -v//如果有，说明node.js安装成功！$ node -vv8.4.0//如果有，说明npm安装成功！$npm -v$ npm -v5.3.0 2.安装hexo在git-bash中运行以下命令安装hexo 安装hexo全局1$ npm install -g hexo-cli 建立文件夹123hexo init blogcd blognpm install 然后运行$ npm install 就能够建立起一个本地的服务器，端口是4000，打开浏览器 http://localhost:4000 就能访问属于你自己的博客了。 3.切换主题主题代码拷贝主题的拷贝也是直接使用 git 即可，首先进入到你博客的根目录，再打开 git-bash 运行 git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在博客根目录下找到 _config.yml 文件，找到里面的 theme，改为 theme: next 这时再运行一次 hexo s ，看看主题有没有生效吧。 4.发布到coding前提是你先注册一个coding账号 hexo 提供了一个部署命令 hexo deploy，首先需要安装一下 hexo-deployer-git插件 npm install hexo-deployer-git --save 然后配置一下_config.yml 文件： 1234deploy: type: git repoistory: https://git.coding.net/codinggq/problog.git branch: master 预览效果 在 coding 上建立一个私人仓库，找到代码的 coding 地址，填好上面的配置，然后直接执行 hexo deploy 不出意外的话会让你填写 coding 的用户名和密码完成上传操作。如果你有配置 ssh 方式的话就更加方便了。 这个时候再到 coding 对应的项目里面打开 pages 服务，根据 coding 建议，因为不是 jekyll 项目，所以需要再新建一个.nojekyll 文件（空文件就行，其实不建立也行），等上一会就能够访问自己的博客了。 最后运行以下命令上传到coding 12$ hexo g$ hexo d 如果不行用git,输入以下命令 12345678mkdir problogcd probloggit initecho &quot;# problog&quot; &gt;&gt; README.mdgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://git.coding.net/codinggq/problog.gitgit push -u origin master 5.写在最后今天的hexo+coding配置免费博客就到这里，赶快体验一下吧！","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"https://gitguanqi.github.io/categories/搭建博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://gitguanqi.github.io/tags/hexo/"},{"name":"coding","slug":"coding","permalink":"https://gitguanqi.github.io/tags/coding/"},{"name":"blog","slug":"blog","permalink":"https://gitguanqi.github.io/tags/blog/"}]},{"title":"栈及其基本运算","slug":"stock-learn","date":"2017-09-19T00:42:21.000Z","updated":"2019-01-16T03:11:20.867Z","comments":true,"path":"2017-09-19/stock-learn/","link":"","permalink":"https://gitguanqi.github.io/2017-09-19/stock-learn/","excerpt":"","text":"栈及其基本运算一.定义栈是一种特殊的线性表，所有的插入和删除都在表的同一端进行；在栈中，一端是封闭端，不允许进行插入和删除元素，另一端是开口端，允许插入和删除元素。 例如：子弹匣 通常用指针top来表示栈顶的位置，用指针bottom来指向栈底。 假设s=(a1,a2,a3,…an),a1=栈底元素，an=栈顶元素。先进后出，栈顶后入栈，先出栈，最晚被插入，最早被删除。 二.特点 栈顶元素总是最后被插入的元素，也是最早被删除的元素。 栈顶元素总是最早被插入的元素，也是最晚被删除的元素。 栈具有记忆作用。 在顺序存储结构下，栈的插入与删除运算都不需要移动表中其他数据元素。 栈顶指针top动态反映了栈中元素的变化情况。 栈的修改原则是“先进后出”（last in first out,lifo）,或后进先出（first in frist out,filo）,栈也被称为”后进先出“表。 三.基本运算栈的基本运算是： 入栈：在栈顶位置插入一个新元素。 退栈：取出栈顶元素并赋予制定变量。 读栈顶元素：将指针top指向的元素的值赋给一个指定的变量。 栈的存储可以采用顺序方式和链式方式来实现。 a.空栈 -&gt; b.插入元素A后 -&gt; c.插入元素b,c,e,f后 -&gt; d.删除元素e,f后 top F E D top D C C B B top A A A top 四.最后今天只是介绍了一部分，以后再补充。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://gitguanqi.github.io/categories/计算机基础/"}],"tags":[{"name":"栈运算","slug":"栈运算","permalink":"https://gitguanqi.github.io/tags/栈运算/"}]},{"title":"SASS使用教程","slug":"sass-use","date":"2017-09-19T00:42:21.000Z","updated":"2019-01-16T03:08:21.356Z","comments":true,"path":"2017-09-19/sass-use/","link":"","permalink":"https://gitguanqi.github.io/2017-09-19/sass-use/","excerpt":"","text":"本篇我想大家介绍SASS的一些知识，希望对大家有所帮助。 1.SASS介绍。 SASS是世界上最成熟、最稳定、最强大的专业级CSS扩展语言！ SASS有以下四个特点: 兼容CSSSass完全兼容所有版本的CSS。我们对此严格把控，所以你可以无缝地使用任何可用的CSS库。 特性丰富Sass拥有比其他任何CSS扩展语言更多的功能和特性。Sass核心团队不懈努力，一直使其保持领先地位 成熟Sass已经经过其核心团队超过8年的精心打造。 行业认可一次又一次地，行业把Sass作为首选CSS扩展语言。 社区庞大数家科技企业和成百上千名开发者为Sass提供支持。 框架有无数的框架使用Sass构建。比如Compass，Bourbon，和Susy。 2.SASS安装配置。安装前，你需要安装npm和gulp这两个工具。 安装ruby由于sass基于ruby语言开发而成，所以安装sass前还需要安装ruby。 安装成功后，在cmd中输入以下命令： 123ruby -v//如果成功则会出现ruby 2.4.1p111 (2017-03-22 revision 58053) [x64-mingw32] 接下来，更换成国内的gem源1234567891011//1.删除原gem源gem sources --remove https://rubygems.org///2.添加国内淘宝源gem sources -a https://ruby.taobao.org///3.打印是否替换成功gem sources -l//4.更换成功后打印如下*** CURRENT SOURCES ***https://ruby.taobao.org/ 最后，安装sass。123$npm init//一路直下$ npm install sass --save-dev 安装完成后查看版本 123$ sass -v//出现这说明安装成功Sass 3.5.1 (Bleeding Edge) 至此，已经安装好了sass。 3.SASS语法介绍。基础知识。 导入@import ‘reset’所有的sass导入文件都可以忽略后缀名.scss。一般来说基础的文件命名方法以_开头，如_mixin.scss。这种文件在导入的时候可以不写下划线，可写成@import “mixin”。 注释 /**/多行注释//单行注释 变量 声明变量用$符号 例如：$width:300px 默认变量加上default 例如：$width:300px!default 嵌套 选择器嵌套 例如： 12345678910div&#123; font-size: 20px; a&#123; span&#123; font-weight: 500; color: #ff0; font-size: 5em; &#125; &#125;&#125; 属性嵌套 12345678910111213div &#123; border: &#123; style: solid; left: &#123; width: 4px; color: #888; &#125; right: &#123; width: 2px; color: #ccc; &#125; &#125;&#125; 跳出嵌套 12345678910div&#123; font-size: 20px; a&#123; @at-root span&#123; font-weight: 500; color: #ff0; font-size: 5em; &#125; &#125;&#125; 伪类嵌套 12345678910111213div&#123; &amp;hover:&#123; color: #f00; &#125; font-size: 20px; a&#123; @at-root span&#123; font-weight: 500; color: #ff0; font-size: 5em; &#125; &#125;&#125; 还有一些，以后介绍。 4.SASS总结。通过学习SASS，我感受到了SASS强大的CSS编译功能，确实方便我们每个人进行CSS编译开发。","categories":[{"name":"编译工具","slug":"编译工具","permalink":"https://gitguanqi.github.io/categories/编译工具/"}],"tags":[{"name":"css编译","slug":"css编译","permalink":"https://gitguanqi.github.io/tags/css编译/"},{"name":"sass","slug":"sass","permalink":"https://gitguanqi.github.io/tags/sass/"}]},{"title":"gulp使用指南","slug":"gulp-use","date":"2017-09-17T00:16:21.000Z","updated":"2019-01-16T03:07:06.632Z","comments":true,"path":"2017-09-17/gulp-use/","link":"","permalink":"https://gitguanqi.github.io/2017-09-17/gulp-use/","excerpt":"","text":"我写这篇博客的目的只是为了帮助那些还不会gulp的人能够完整的使用gulp这个工具来协助你完成web开发！我希望这篇博客可以帮助你，那样我才会快乐! 这是一篇gulp使用指南！在阅读此篇之前，请确保你的电脑已经安装上npm包管理器！ gulp简介。gulp是一款自动化构建工具,由外国人开发,可以增强你的工作流程! gulp作用。 易于使用 通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。 构建快速 利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 插件高质 Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 易于学习 通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 gulp安装。在安装之前,你需要新建一个文件夹,但是名字不能为gulp。 首先，你需要运行以下命令：$ npm init 这是让npm初始化一下,一路按回车。 这时,你的根目录下就有了package.json这样一个配置文件！ 然后，你在安装一下gulp：$ npm install gulp --save-dev 这条命令是让gulp保存在根目录下，并且作为扩展工具。 最后,你查看一下gulp的版本号,如果出来,就说明成功了：123$ glup -v[20:11:34] CLI version 3.9.1[20:11:34] Local version 3.9.1 至此,便成功的安装好了,你现在激动不？好戏还在后面！ gulp案例。接下来,就由我给大家做一个案例,如何使用gulp这款工具。 首先,我们在根目录下新建一个文件夹,比如src,在它下面又有img,css,js,index.html;然后,开始下载必备的gulp包,这里有：1234567891011&quot;browser-sync&quot;: &quot;^2.18.13&quot;,&quot;gulp&quot;: &quot;^3.9.1&quot;,&quot;gulp-autoprefixer&quot;: &quot;^4.0.0&quot;,&quot;gulp-concat&quot;: &quot;^2.6.1&quot;,&quot;gulp-concat-css&quot;: &quot;^2.3.0&quot;,&quot;gulp-csscomb&quot;: &quot;^3.0.8&quot;,&quot;gulp-htmlmin&quot;: &quot;^3.0.0&quot;,&quot;gulp-imagemin&quot;: &quot;^3.3.0&quot;,&quot;gulp-less&quot;: &quot;^3.3.2&quot;,&quot;gulp-uglifycss&quot;: &quot;^1.0.8&quot;,&quot;gulp-uglyfly&quot;: &quot;^1.4.2&quot; 运行此条命令可以下载以上这些包： $ npm install &lt;你要下载的包名&gt; --save-dev 下载完以后,你需要到配置文件package.json中查看也没有添加到devDependencies中,如果有,就说明成功了！ 接着需用建立一个名为gulpfile.js的文件,然后输入以下命令： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//这些主要是引刚才下载的包var gulp = require('gulp'); var less = require('gulp-less');var uglifycss = require('gulp-uglifycss');var autoprefixer = require('gulp-autoprefixer');var csscomb = require('gulp-csscomb');var concat = require('gulp-concat');var uglyfly = require('gulp-uglyfly');var img = require('gulp-imagemin');var htmlmin = require('gulp-htmlmin');var browserSync = require('browser-sync').create();//接下来就是建立任务：//这个任务是把less编译成cssgulp.task('style',function()&#123; gulp.src(['src/css/*.less','!src/css/_*.less']) //入口文件 *在css下面以.less所有文件编译 .pipe(less()) .pipe(autoprefixer(&#123; browsers: ['Android 2.3', 'Android &gt;= 4', 'Chrome &gt;= 20', 'Firefox &gt;= 24', // Firefox 24 is the latest ESR 'Explorer &gt;= 8', 'iOS &gt;= 6', 'Opera &gt;= 12', 'Safari &gt;= 6'], cascade: false &#125;)) .pipe(csscomb()) .pipe(uglifycss()) //less编译 .pipe(gulp.dest('dest/css')) //出口文件&#125;);//这个任务是把所有的js文件合并成一个名为main.js的文件gulp.task('script',function()&#123; gulp.src('src/js/*.js') .pipe(concat('main.js')) .pipe(uglyfly()) .pipe(gulp.dest('dest/js'))&#125;);//这个任务是把图片复制,压缩gulp.task('img',function()&#123; gulp.src('src/img/*.*') .pipe(img()) .pipe(gulp.dest('dest/img'))&#125;);//这个任务是把所有的html文件压缩gulp.task('htmlmin',function()&#123; gulp.src('src/*.html') .pipe(htmlmin(&#123; collapseWhitespace: true, removeComments: true &#125;)) .pipe(gulp.dest('dest'))&#125;);//这个任务就是游览器热更新var reload = browserSync.reload;gulp.task('server',function()&#123; browserSync.init(&#123; server: &#123; baseDir: \"dest\" &#125; &#125;); gulp.watch('src/*.html',['htmlmin']).on(\"change\",reload); gulp.watch('src/js/*.js',['script']).on(\"change\",reload); gulp.watch('src/css/*.less',['style']).on(\"change\",reload); gulp.watch('src/img/*.*',['img']).on(\"change\",reload);&#125;) 最后大功告成！ 总结。gulp作为一款工具目前非常流行,希望大家多用它。此片博文还有许多不足之处,希望大家批评指正。","categories":[{"name":"打包工具","slug":"打包工具","permalink":"https://gitguanqi.github.io/categories/打包工具/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://gitguanqi.github.io/tags/gulp/"}]}]}